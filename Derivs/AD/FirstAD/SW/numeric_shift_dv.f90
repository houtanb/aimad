!
! Copyright (C) 2006-2014 Houtan Bastani and Luca Guerrieri
!
!
! This free software: you can redistribute it and/or modify
! it under the terms of the GNU General Public License as published by
! the Free Software Foundation, either version 3 of the License, or
! (at your option) any later version.
!
! It is distributed in the hope that it will be useful,
! but WITHOUT ANY WARRANTY; without even the implied warranty of
! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
! GNU General Public License for more details.
!
! You should have received a copy of the GNU General Public License
! along with Dynare.  If not, see <http://www.gnu.org/licenses/>.
!

!        Generated by TAPENADE     (INRIA, Tropics team)
!  Tapenade - Version 2.2 (r1239) - Wed 28 Jun 2006 04:59:55 PM CEST
!
!  Differentiation of numeric_shift in forward (tangent) mode: (multi-directional mode)
!   variations  of output variables: h q
!   with respect to input variables: h q
SUBROUTINE NUMERIC_SHIFT_DV(h, hd, q, qd, iq, qrows, qcols, neq, condn, nnumeric, nbdirs)
  IMPLICIT NONE

  DOUBLE PRECISION, INTENT(IN) :: condn
  INTEGER, INTENT(INOUT) :: iq
  INTEGER, INTENT(OUT) :: nnumeric
  INTEGER, INTENT(IN) :: neq, nbdirs, qrows, qcols
  DOUBLE PRECISION, DIMENSION(neq, neq*3), INTENT(INOUT) :: h
  DOUBLE PRECISION, DIMENSION(qrows, qcols), INTENT(INOUT) :: q
  DOUBLE PRECISION, DIMENSION(nbdirs,neq,neq*3), INTENT(INOUT) :: hd
  DOUBLE PRECISION, DIMENSION(nbdirs,qrows,qcols), INTENT(INOUT) :: qd

  DOUBLE PRECISION, DIMENSION(:), ALLOCATABLE :: d, work
  DOUBLE PRECISION, DIMENSION(:, :), ALLOCATABLE :: hpart, hpart2, hpartcopy, hprod, u, v
  DOUBLE PRECISION, DIMENSION(:, :, :), ALLOCATABLE :: hpart2d, hpartd, hprodd, ud

  INTEGER, DIMENSION(:), ALLOCATABLE :: order, selector
  INTEGER :: info, lleft, lright, lwork, nd, ns, rleft, rright, status
  LOGICAL, DIMENSION(:), ALLOCATABLE :: stablerows

  EXTERNAL dgesvd, get_stable_singvals, get_selector, svd_analytical_deriv, dgemm_dv
  INTRINSIC ANY, MAX

  info = 0
  lleft = 1
  nnumeric = 0
  rleft = qcols
  lright = qcols + 1
  rright = qcols + neq
  lwork = MAX(1,3*neq+neq,5*neq)

!  IF (1 .LT. 3*neq + neq) THEN
!    IF (3*neq + neq .LT. 5*neq) THEN
!      lwork = 5*neq
!    ELSE
!      lwork = 3*neq + neq
!    END IF
!  ELSE IF (1 .LT. 5*neq) THEN
!    lwork = 5*neq
!  ELSE
!    lwork = 1
!  END IF


  ALLOCATE( order(neq), hpart(neq,neq), hpartcopy(neq,neq), v(neq,neq), u(neq,neq), &
       d(neq), work(lwork), stablerows(neq), hprod(neq,3*neq), &
       hpartd(nbdirs,neq,neq), ud(nbdirs,neq,neq), hprodd(nbdirs, neq, neq*3), STAT=status )
  IF (status .NE. 0) THEN
     WRITE(*,*) '**** IN NUMERIC_SHIFT():: COULD NOT ALLOCATE MEMORY ****'
     RETURN
  END IF

  hpart = h(:,lright:rright)
  hpartd= hd(:,:,lright:rright)
  hpartcopy  = hpart

  ! order is an array with:
  ! order(1) = neq;
  ! order(2) = neq-1;
  ! ...
  ! order(neq) = 1
!  order = (/ ( i, i = neq, 1, -1 ) /)

  !
  ! CALL SVD
  !
  CALL dgesvd( 'A', 'A', neq, neq, hpart, neq, d, u, neq, v, neq, work, lwork, info )
  hpart = hpartcopy
  !u = u( :, order )
  !d = d( order )
  !v = v( order, : )
  CALL svd_analytical_deriv( hpart, hpartd, neq, u, ud, d, TRANSPOSE(v), nbdirs )
!  CALL svd_gary_analytical_deriv( hpart, hpartd, neq, u, ud, d, TRANSPOSE(v), nbdirs )
  !CALL writemat_total_3d(ud, nbdirs, neq, neq, 'ud_dv.m')


  ! if the ith entry on the diagonal of hpart is <= condn, the ith entry of
  ! stablerows is true
  CALL get_stable_singvals( d, neq, condn, stablerows, ns )
  DO WHILE( ANY(stablerows) .AND. (iq .LE. qrows) )
     ALLOCATE(selector(ns), STAT=status)
     IF (status .NE. 0) THEN
        WRITE(*,*) '**** IN NUMERIC_SHIFT():: COULD NOT ALLOCATE MEMORY ****'
        RETURN
     END IF
     selector(:) = 0.0d0
     CALL GET_SELECTOR(stablerows, neq, selector, ns)

     ! h = u'*h
     CALL DGEMM_DV('T', 'N', neq, 3*neq, neq, 1.d0, u, ud, neq, h, hd, neq, 0.d0, hprod, hprodd, neq, nbdirs)
     DO nd=1,nbdirs
        hd(nd, :, :) = hprodd(nd, :, :)
     END DO
     h = hprod


     IF (iq + ns .LE. qrows) THEN
        ALLOCATE(hpart2(ns, 3*neq), hpart2d(nbdirs, ns, 3*neq), STAT=status)
        IF (status .NE. 0) THEN
           WRITE(*,*) '**** IN NUMERIC_SHIFT():: COULD NOT ALLOCATE MEMORY ****'
           RETURN
        END IF
        hpart2d(: , :, :) = 0.D0
        hpart2(:, :) = 0.0d0

        CALL SHIFTRIGHT_DV(h(selector, :), hd(:, selector, :), ns, 3*neq, neq, hpart2, hpart2d, nbdirs)

        DO nd=1,nbdirs
           qd(nd, iq+1:iq+ns, :) = hd(nd, selector, lleft:rleft)
           hd(nd, selector, :) = hpart2d(nd, :, :)
        END DO
        q(iq+1:iq+ns, :) = h(selector, lleft:rleft)
        h(selector, :) = hpart2

        DEALLOCATE(hpart2, hpart2d, STAT=status)
        IF (status .NE. 0) THEN
           WRITE(*,*) '**** IN NUMERIC_SHIFT():: COULD NOT DEALLOCATE MEMORY ****'
           RETURN
        END IF

     ELSE
        WRITE(*, *)
        WRITE(*, *) '*****  problem in numeric_shift *****'
        WRITE(*, *)
        RETURN
     END IF

     DEALLOCATE(selector, STAT=status)
     IF (status .NE. 0) THEN
        WRITE(*,*) '**** IN NUMERIC_SHIFT():: COULD NOT DEALLOCATE MEMORY ****'
        RETURN
     END IF

     iq = iq + ns
     nnumeric = nnumeric + ns

     hpart(:,:) = 0.0d0
     hpartd(:,:,:) = 0.0d0
     hpart  = h(:,lright:rright)
     hpartd = hd(:,:,lright:rright)
     hpartcopy = hpart

     !
     ! CALL SVD
     !
     info = 0
     CALL dgesvd( 'A', 'A', neq, neq, hpart, neq, d, u, neq, v, neq, work, lwork, info )
     IF( info .NE. 0 ) THEN
        WRITE(*,*)
        WRITE(*,*) '**** IN NUMERIC_SHIFT_D():: Call to dgesvd() returned info != 0'
     END IF

     hpart = hpartcopy
     !u = u( :, order )
     !d = d( order )
     !v = v( order, : )
     CALL svd_analytical_deriv( hpart, hpartd, neq, u, ud, d, TRANSPOSE(v), nbdirs )
!     CALL svd_gary_analytical_deriv( hpart, hpartd, neq, u, ud, d, TRANSPOSE(v), nbdirs )
     CALL get_stable_singvals( d, neq, condn, stablerows, ns )
  END DO

  DEALLOCATE( order, hpart, hpartcopy, v, u, &
       d, work, stablerows, hprod, &
       hpartd, ud, hprodd, STAT=status )
  IF (status .NE. 0) THEN
     WRITE(*,*) '**** IN NUMERIC_SHIFT():: COULD NOT DEALLOCATE MEMORY ****'
     RETURN
  END IF
END SUBROUTINE NUMERIC_SHIFT_DV

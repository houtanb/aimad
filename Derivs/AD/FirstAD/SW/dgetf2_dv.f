!
! Copyright (C) 2006-2014 Houtan Bastani and Luca Guerrieri
!
!
! This free software: you can redistribute it and/or modify
! it under the terms of the GNU General Public License as published by
! the Free Software Foundation, either version 3 of the License, or
! (at your option) any later version.
!
! It is distributed in the hope that it will be useful,
! but WITHOUT ANY WARRANTY; without even the implied warranty of
! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
! GNU General Public License for more details.
!
! You should have received a copy of the GNU General Public License
! along with Dynare.  If not, see <http://www.gnu.org/licenses/>.
!

C        Generated by TAPENADE     (INRIA, Tropics team)
C  Tapenade - Version 2.2 (r1239) - Wed 28 Jun 2006 04:59:55 PM CEST
C
C  Differentiation of dgetf2 in forward (tangent) mode: (multi-directional mode)
C   variations  of output variables: a
C   with respect to input variables: a
      SUBROUTINE DGETF2_DV(m, n, a, ad, lda, ipiv, info, nbdirs)
      USE DIFFSIZES
      IMPLICIT NONE
C
C     End of DGETF2
C
      INTEGER ii1, ii2, info, ipiv(*), m, n
      INTEGER lda, nbdirs
      DOUBLE PRECISION a(lda, n), ad(nbdirsmax, lda, n)
      DOUBLE PRECISION one, zero
      PARAMETER (one=1.0d+0, zero=0.0d+0)
      DOUBLE PRECISION abs1
      DOUBLE PRECISION arg2, arg2d(nbdirsmax), arg3, arg3d(nbdirsmax)
      DOUBLE PRECISION DLAMCH
      INTEGER arg1, arg20, i, IDAMAX, j, jp, max1, min1, min2, nd,
     +        result1
      DOUBLE PRECISION sfmin
      EXTERNAL DLAMCH
      INTRINSIC MAX, ABS, MIN
C
C  -- LAPACK routine (version 3.1) --
C     Univ. of Tennessee, Univ. of California Berkeley and NAG Ltd..
C     November 2006
C
C     .. Scalar Arguments ..
C     ..
C     .. Array Arguments ..
C     ..
C
C  Purpose
C  =======
C
C  DGETF2 computes an LU factorization of a general m-by-n matrix A
C  using partial pivoting with row interchanges.
C
C  The factorization has the form
C     A = P * L * U
C  where P is a permutation matrix, L is lower triangular with unit
C  diagonal elements (lower trapezoidal if m > n), and U is upper
C  triangular (upper trapezoidal if m < n).
C
C  This is the right-looking Level 2 BLAS version of the algorithm.
C
C  Arguments
C  =========
C
C  M       (input) INTEGER
C          The number of rows of the matrix A.  M >= 0.
C
C  N       (input) INTEGER
C          The number of columns of the matrix A.  N >= 0.
C
C  A       (input/output) DOUBLE PRECISION array, dimension (LDA,N)
C          On entry, the m by n matrix to be factored.
C          On exit, the factors L and U from the factorization
C          A = P*L*U; the unit diagonal elements of L are not stored.
C
C  LDA     (input) INTEGER
C          The leading dimension of the array A.  LDA >= max(1,M).
C
C  IPIV    (output) INTEGER array, dimension (min(M,N))
C          The pivot indices; for 1 <= i <= min(M,N), row i of the
C          matrix was interchanged with row IPIV(i).
C
C  INFO    (output) INTEGER
C          = 0: successful exit
C          < 0: if INFO = -k, the k-th argument had an illegal value
C          > 0: if INFO = k, U(k,k) is exactly zero. The factorization
C               has been completed, but the factor U is exactly
C               singular, and division by zero will occur if it is used
C               to solve a system of equations.
C
C  =====================================================================
C
C     .. Parameters ..
C     ..
C     .. Local Scalars ..
C     ..
C     .. External Functions ..
C     ..
C     .. External Subroutines ..
C     ..
C     .. Intrinsic Functions ..
C     ..
C     .. Executable Statements ..
C
C     Test the input parameters.
C
      info = 0
      IF (m .LT. 0) THEN
        info = -1
      ELSE IF (n .LT. 0) THEN
        info = -2
      ELSE
        IF (1 .LT. m) THEN
          max1 = m
        ELSE
          max1 = 1
        END IF
        IF (lda .LT. max1) info = -4
      END IF
      IF (info .NE. 0) THEN
        arg1 = -info
        CALL XERBLA('DGETF2', arg1)
        DO ii1=1,n
          DO ii2=1,lda
            DO nd=1,nbdirs
              ad(nd, ii2, ii1) = 0.D0
            ENDDO
          ENDDO
        ENDDO
        RETURN
      ELSE IF (m .EQ. 0 .OR. n .EQ. 0) THEN
C
C     Quick return if possible
C
        RETURN
      ELSE
C
C     Compute machine safe minimum
C
        sfmin = DLAMCH('S')
        IF (m .GT. n) THEN
          min1 = n
        ELSE
          min1 = m
        END IF
C
        DO j=1,min1
C
C        Find pivot and test for singularity.
C
          arg1 = m - j + 1
          result1 = IDAMAX(arg1, a(j, j), 1)
          jp = j - 1 + result1
          ipiv(j) = jp
          IF (a(jp, j) .NE. zero) THEN
C
C           Apply the interchange to columns 1:N.
C
            IF (jp .NE. j) CALL DSWAP_DV(n, a(j, 1), ad(1, j, 1), lda, a
     +                                   (jp, 1), ad(1, jp, 1), lda,
     +                                   nbdirs)
C
C           Compute elements J+1:M of J-th column.
C
            IF (j .LT. m) THEN
              IF (a(j, j) .GE. 0.) THEN
                abs1 = a(j, j)
              ELSE
                abs1 = -a(j, j)
              END IF
              IF (abs1 .GE. sfmin) THEN
                arg1 = m - j
                DO nd=1,nbdirs
                  arg2d(nd) = -(one*ad(nd, j, j)/a(j, j)**2)
                ENDDO
                arg2 = one/a(j, j)
                CALL DSCAL_DV(arg1, arg2, arg2d, a(j+1, j), ad(1, j+1, j
     +                        ), 1, nbdirs)
              ELSE
                DO i=1,m-j
                  DO nd=1,nbdirs
                    ad(nd, j+i, j) = (ad(nd, j+i, j)*a(j, j)-a(j+i, j)*
     +                ad(nd, j, j))/a(j, j)**2
                  ENDDO
                  a(j+i, j) = a(j+i, j)/a(j, j)
                ENDDO
              END IF
            END IF
          ELSE IF (info .EQ. 0) THEN
C
C
            info = j
          END IF
          IF (m .GT. n) THEN
            min2 = n
          ELSE
            min2 = m
          END IF
C
          IF (j .LT. min2) THEN
C
C           Update trailing submatrix.
C
            arg1 = m - j
            arg20 = n - j
            arg3 = -one
            DO nd=1,nbdirs
              arg3d(nd) = 0.D0
            ENDDO
            CALL DGER_DV(arg1, arg20, arg3, arg3d, a(j+1, j), ad(1, j+1
     +                   , j), 1, a(j, j+1), ad(1, j, j+1), lda, a(j+1,
     +                   j+1), ad(1, j+1, j+1), lda, nbdirs)
          END IF
        ENDDO
        RETURN
      END IF
      END

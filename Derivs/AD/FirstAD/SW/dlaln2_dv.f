!
! Copyright (C) 2006-2014 Houtan Bastani and Luca Guerrieri
!
!
! This free software: you can redistribute it and/or modify
! it under the terms of the GNU General Public License as published by
! the Free Software Foundation, either version 3 of the License, or
! (at your option) any later version.
!
! It is distributed in the hope that it will be useful,
! but WITHOUT ANY WARRANTY; without even the implied warranty of
! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
! GNU General Public License for more details.
!
! You should have received a copy of the GNU General Public License
! along with Dynare.  If not, see <http://www.gnu.org/licenses/>.
!

C        Generated by TAPENADE     (INRIA, Tropics team)
C  Tapenade - Version 2.2 (r1239) - Wed 28 Jun 2006 04:59:55 PM CEST
C
C  Differentiation of dlaln2 in forward (tangent) mode: (multi-directional mode)
C   variations  of output variables: x scale
C   with respect to input variables: wr x smin a b
      SUBROUTINE DLALN2_DV(ltrans, na, nw, smin, smind, ca, a, ad, lda,
     +                     d1, d2, b, bd, ldb, wr, wrd, wi, x, xd, ldx,
     +                     scale, scaled, xnorm, info, nbdirs)
      USE DIFFSIZES
      IMPLICIT NONE
C
C     End of DLALN2
C
      INTEGER info, na, nw
      INTEGER lda, ldb, ldx, nbdirs
      DOUBLE PRECISION a(lda, *), ad(nbdirsmax, lda, *), b(ldb, *), bd(
     +                 nbdirsmax, ldb, *), x(ldx, *), xd(nbdirsmax, ldx
     +                 , *)
      LOGICAL ltrans
      DOUBLE PRECISION ca, d1, d2, scale, scaled(nbdirsmax), smin, smind
     +                 (nbdirsmax), wi, wr, wrd(nbdirsmax), xnorm
      DOUBLE PRECISION one, zero
      PARAMETER (one=1.0d0, zero=0.0d0)
      DOUBLE PRECISION two
      PARAMETER (two=2.0d0)
      DOUBLE PRECISION abs13, abs13d(nbdirsmax), abs14, abs17, abs17d(
     +                 nbdirsmax), abs18, abs18d(nbdirsmax), abs2, abs25
     +                 , abs25d(nbdirsmax), abs26, abs26d(nbdirsmax),
     +                 abs2d(nbdirsmax), abs3, x1, x1d(nbdirsmax), x4,
     +                 x4d(nbdirsmax), y1, y1d(nbdirsmax), y4, y4d(
     +                 nbdirsmax)
      DOUBLE PRECISION abs1, abs10, abs11, abs11d(nbdirsmax), abs12,
     +                 abs19, abs20, abs20d(nbdirsmax), abs21, abs21d(
     +                 nbdirsmax), abs22, abs22d(nbdirsmax), abs23,
     +                 abs24, abs27, abs27d(nbdirsmax), abs28, abs28d(
     +                 nbdirsmax), abs29, abs30, abs31, abs31d(nbdirsmax
     +                 ), abs32, abs32d(nbdirsmax), abs5, abs6, abs7,
     +                 bbnd, bbndd(nbdirsmax), bi1, bi1d(nbdirsmax), bi2
     +                 , bi2d(nbdirsmax), bignum, bnorm, bnormd(
     +                 nbdirsmax), br1, br1d(nbdirsmax), br2, br2d(
     +                 nbdirsmax), ci21, ci22, cmax, cmaxd(nbdirsmax),
     +                 cnorm, cr21, cr21d(nbdirsmax), cr22, cr22d(
     +                 nbdirsmax), csi, csid(nbdirsmax), csr, csrd(
     +                 nbdirsmax), li21, li21d(nbdirsmax), lr21, lr21d(
     +                 nbdirsmax), smini, sminid(nbdirsmax), smlnum,
     +                 temp, tempd(nbdirsmax), u22abs, u22absd(nbdirsmax
     +                 ), ui11, ui11r, ui11rd(nbdirsmax), ui12, ui12s,
     +                 ui12sd(nbdirsmax), ui22, ui22d(nbdirsmax), ur11,
     +                 ur11d(nbdirsmax), ur11r, ur11rd(nbdirsmax), ur12
     +                 , ur12d(nbdirsmax)
      DOUBLE PRECISION ur12s, ur12sd(nbdirsmax), ur22, ur22d(nbdirsmax)
     +                 , x2, x2d(nbdirsmax), x3, x5, x5d(nbdirsmax), x6
     +                 , xi1, xi1d(nbdirsmax), xi2, xi2d(nbdirsmax), xr1
     +                 , xr1d(nbdirsmax), xr2, xr2d(nbdirsmax), y2, y2d(
     +                 nbdirsmax), y3, y5, y5d(nbdirsmax), y6
      DOUBLE PRECISION arg1, arg1d(nbdirsmax), arg2, arg2d(nbdirsmax)
      DOUBLE PRECISION abs15, abs16, abs4, abs8, abs9, abs9d(nbdirsmax)
     +                 , ci(2, 2), cid(nbdirsmax, 2, 2), civ(4), civd(
     +                 nbdirsmax, 4), cr(2, 2), crd(nbdirsmax, 2, 2),
     +                 crv(4), crvd(nbdirsmax, 4)
      INTEGER icmax, ipivot(4, 4), j, nd
      DOUBLE PRECISION DLAMCH, result1
      LOGICAL rswap(4), zswap(4)
      INTRINSIC MAX, ABS
      DATA zswap /.false., .false., .true., .true./
      DATA rswap /.false., .true., .false., .true./
      DATA ipivot /1, 2, 3, 4, 2, 1, 4, 3, 3, 4, 1, 2, 4, 3, 2, 1/
C
C  -- LAPACK auxiliary routine (version 3.1) --
C     Univ. of Tennessee, Univ. of California Berkeley and NAG Ltd..
C     November 2006
C
C     .. Scalar Arguments ..
C     ..
C     .. Array Arguments ..
C     ..
C
C  Purpose
C  =======
C
C  DLALN2 solves a system of the form  (ca A - w D ) X = s B
C  or (ca A' - w D) X = s B   with possible scaling ("s") and
C  perturbation of A.  (A' means A-transpose.)
C
C  A is an NA x NA real matrix, ca is a real scalar, D is an NA x NA
C  real diagonal matrix, w is a real or complex value, and X and B are
C  NA x 1 matrices -- real if w is real, complex if w is complex.  NA
C  may be 1 or 2.
C
C  If w is complex, X and B are represented as NA x 2 matrices,
C  the first column of each being the real part and the second
C  being the imaginary part.
C
C  "s" is a scaling factor (.LE. 1), computed by DLALN2, which is
C  so chosen that X can be computed without overflow.  X is further
C  scaled if necessary to assure that norm(ca A - w D)*norm(X) is less
C  than overflow.
C
C  If both singular values of (ca A - w D) are less than SMIN,
C  SMIN*identity will be used instead of (ca A - w D).  If only one
C  singular value is less than SMIN, one element of (ca A - w D) will be
C  perturbed enough to make the smallest singular value roughly SMIN.
C  If both singular values are at least SMIN, (ca A - w D) will not be
C  perturbed.  In any case, the perturbation will be at most some small
C  multiple of max( SMIN, ulp*norm(ca A - w D) ).  The singular values
C  are computed by infinity-norm approximations, and thus will only be
C  correct to a factor of 2 or so.
C
C  Note: all input quantities are assumed to be smaller than overflow
C  by a reasonable factor.  (See BIGNUM.)
C
C  Arguments
C  ==========
C
C  LTRANS  (input) LOGICAL
C          =.TRUE.:  A-transpose will be used.
C          =.FALSE.: A will be used (not transposed.)
C
C  NA      (input) INTEGER
C          The size of the matrix A.  It may (only) be 1 or 2.
C
C  NW      (input) INTEGER
C          1 if "w" is real, 2 if "w" is complex.  It may only be 1
C          or 2.
C
C  SMIN    (input) DOUBLE PRECISION
C          The desired lower bound on the singular values of A.  This
C          should be a safe distance away from underflow or overflow,
C          say, between (underflow/machine precision) and  (machine
C          precision * overflow ).  (See BIGNUM and ULP.)
C
C  CA      (input) DOUBLE PRECISION
C          The coefficient c, which A is multiplied by.
C
C  A       (input) DOUBLE PRECISION array, dimension (LDA,NA)
C          The NA x NA matrix A.
C
C  LDA     (input) INTEGER
C          The leading dimension of A.  It must be at least NA.
C
C  D1      (input) DOUBLE PRECISION
C          The 1,1 element in the diagonal matrix D.
C
C  D2      (input) DOUBLE PRECISION
C          The 2,2 element in the diagonal matrix D.  Not used if NW=1.
C
C  B       (input) DOUBLE PRECISION array, dimension (LDB,NW)
C          The NA x NW matrix B (right-hand side).  If NW=2 ("w" is
C          complex), column 1 contains the real part of B and column 2
C          contains the imaginary part.
C
C  LDB     (input) INTEGER
C          The leading dimension of B.  It must be at least NA.
C
C  WR      (input) DOUBLE PRECISION
C          The real part of the scalar "w".
C
C  WI      (input) DOUBLE PRECISION
C          The imaginary part of the scalar "w".  Not used if NW=1.
C
C  X       (output) DOUBLE PRECISION array, dimension (LDX,NW)
C          The NA x NW matrix X (unknowns), as computed by DLALN2.
C          If NW=2 ("w" is complex), on exit, column 1 will contain
C          the real part of X and column 2 will contain the imaginary
C          part.
C
C  LDX     (input) INTEGER
C          The leading dimension of X.  It must be at least NA.
C
C  SCALE   (output) DOUBLE PRECISION
C          The scale factor that B must be multiplied by to insure
C          that overflow does not occur when computing X.  Thus,
C          (ca A - w D) X  will be SCALE*B, not B (ignoring
C          perturbations of A.)  It will be at most 1.
C
C  XNORM   (output) DOUBLE PRECISION
C          The infinity-norm of X, when X is regarded as an NA x NW
C          real matrix.
C
C  INFO    (output) INTEGER
C          An error flag.  It will be set to zero if no error occurs,
C          a negative number if an argument is in error, or a positive
C          number if  ca A - w D  had to be perturbed.
C          The possible values are:
C          = 0: No error occurred, and (ca A - w D) did not have to be
C                 perturbed.
C          = 1: (ca A - w D) had to be perturbed to make its smallest
C               (or only) singular value greater than SMIN.
C          NOTE: In the interests of speed, this routine does not
C                check the inputs for errors.
C
C =====================================================================
C
C     .. Parameters ..
C     ..
C     .. Local Scalars ..
C     ..
C     .. Local Arrays ..
C     ..
C     .. External Functions ..
C     ..
C     .. External Subroutines ..
C     ..
C     .. Intrinsic Functions ..
C     ..
C     .. Equivalences ..
C      EQUIVALENCE        ( CI( 1, 1 ), CIV( 1 ) ),
C     $                   ( CR( 1, 1 ), CRV( 1 ) )
C     ..
C     .. Data statements ..
C     ..
C     .. Executable Statements ..
C
C     Compute BIGNUM
C
      result1 = DLAMCH('Safe minimum')
      smlnum = two*result1
      bignum = one/smlnum
      IF (smin .LT. smlnum) THEN
        smini = smlnum
        DO nd=1,nbdirs
          sminid(nd) = 0.D0
        ENDDO
      ELSE
        DO nd=1,nbdirs
          sminid(nd) = smind(nd)
        ENDDO
        smini = smin
      END IF
C
C     Don't check for input errors
C
      info = 0
C
C     Standard Initializations
C
      scale = one
C
      IF (na .EQ. 1) THEN
C
C        1 x 1  (i.e., scalar) system   C X = B
C
        IF (nw .EQ. 1) THEN
          DO nd=1,nbdirs
            csrd(nd) = ca*ad(nd, 1, 1) - d1*wrd(nd)
          ENDDO
C
C           Real 1x1 system.
C
C           C = ca A - w D
C
          csr = ca*a(1, 1) - wr*d1
          IF (csr .GE. 0.) THEN
            cnorm = csr
          ELSE
            cnorm = -csr
          END IF
C
C           If | C | < SMINI, use C = SMINI
C
          IF (cnorm .LT. smini) THEN
            DO nd=1,nbdirs
              csrd(nd) = sminid(nd)
            ENDDO
            csr = smini
            cnorm = smini
            info = 1
          END IF
          IF (b(1, 1) .GE. 0.) THEN
            DO nd=1,nbdirs
              bnormd(nd) = bd(nd, 1, 1)
            ENDDO
            bnorm = b(1, 1)
          ELSE
            DO nd=1,nbdirs
              bnormd(nd) = -bd(nd, 1, 1)
            ENDDO
            bnorm = -b(1, 1)
          END IF
          IF (cnorm .LT. one .AND. bnorm .GT. one) THEN
            IF (bnorm .GT. bignum*cnorm) THEN
              DO nd=1,nbdirs
                scaled(nd) = -(one*bnormd(nd)/bnorm**2)
              ENDDO
              scale = one/bnorm
            ELSE
              DO nd=1,nbdirs
                scaled(nd) = 0.D0
              ENDDO
            END IF
          ELSE
            DO nd=1,nbdirs
              scaled(nd) = 0.D0
            ENDDO
          END IF
          DO nd=1,nbdirs
            xd(nd, 1, 1) = ((bd(nd, 1, 1)*scale+b(1, 1)*scaled(nd))*csr-
     +        b(1, 1)*scale*csrd(nd))/csr**2
          ENDDO
C
C           Compute X
C
          x(1, 1) = b(1, 1)*scale/csr
          IF (x(1, 1) .GE. 0.) THEN
            xnorm = x(1, 1)
          ELSE
            xnorm = -x(1, 1)
          END IF
        ELSE
          DO nd=1,nbdirs
            csrd(nd) = ca*ad(nd, 1, 1) - d1*wrd(nd)
          ENDDO
C
C           Complex 1x1 system (w is complex)
C
C           C = ca A - w D
C
          csr = ca*a(1, 1) - wr*d1
          csi = -(wi*d1)
          IF (csr .GE. 0.) THEN
            abs1 = csr
          ELSE
            abs1 = -csr
          END IF
          IF (csi .GE. 0.) THEN
            abs12 = csi
          ELSE
            abs12 = -csi
          END IF
          cnorm = abs1 + abs12
C
C           If | C | < SMINI, use C = SMINI
C
          IF (cnorm .LT. smini) THEN
            DO nd=1,nbdirs
              csrd(nd) = sminid(nd)
            ENDDO
            csr = smini
            csi = zero
            cnorm = smini
            info = 1
          END IF
          IF (b(1, 1) .GE. 0.) THEN
            DO nd=1,nbdirs
              abs2d(nd) = bd(nd, 1, 1)
            ENDDO
            abs2 = b(1, 1)
          ELSE
            DO nd=1,nbdirs
              abs2d(nd) = -bd(nd, 1, 1)
            ENDDO
            abs2 = -b(1, 1)
          END IF
          IF (b(1, 2) .GE. 0.) THEN
            DO nd=1,nbdirs
              abs13d(nd) = bd(nd, 1, 2)
            ENDDO
            abs13 = b(1, 2)
          ELSE
            DO nd=1,nbdirs
              abs13d(nd) = -bd(nd, 1, 2)
            ENDDO
            abs13 = -b(1, 2)
          END IF
          DO nd=1,nbdirs
            bnormd(nd) = abs2d(nd) + abs13d(nd)
          ENDDO
C
C           Check scaling for  X = B / C
C
          bnorm = abs2 + abs13
          IF (cnorm .LT. one .AND. bnorm .GT. one) THEN
            IF (bnorm .GT. bignum*cnorm) THEN
              DO nd=1,nbdirs
                scaled(nd) = -(one*bnormd(nd)/bnorm**2)
              ENDDO
              scale = one/bnorm
            ELSE
              DO nd=1,nbdirs
                scaled(nd) = 0.D0
              ENDDO
            END IF
          ELSE
            DO nd=1,nbdirs
              scaled(nd) = 0.D0
            ENDDO
          END IF
          DO nd=1,nbdirs
            arg1d(nd) = scaled(nd)*b(1, 1) + scale*bd(nd, 1, 1)
            csid(nd) = 0.D0
            arg2d(nd) = scaled(nd)*b(1, 2) + scale*bd(nd, 1, 2)
          ENDDO
C
C           Compute X
C
          arg1 = scale*b(1, 1)
          arg2 = scale*b(1, 2)
          CALL DLADIV_DV(arg1, arg1d, arg2, arg2d, csr, csrd, csi, csid
     +                   , x(1, 1), xd(1, 1, 1), x(1, 2), xd(1, 1, 2),
     +                   nbdirs)
          IF (x(1, 1) .GE. 0.) THEN
            abs3 = x(1, 1)
          ELSE
            abs3 = -x(1, 1)
          END IF
          IF (x(1, 2) .GE. 0.) THEN
            abs14 = x(1, 2)
          ELSE
            abs14 = -x(1, 2)
          END IF
          xnorm = abs3 + abs14
        END IF
      ELSE
        DO nd=1,nbdirs
          crd(nd, 1, 1) = ca*ad(nd, 1, 1) - d1*wrd(nd)
          crd(nd, 2, 2) = ca*ad(nd, 2, 2) - d2*wrd(nd)
        ENDDO
C
C
C        2x2 System
C
C        Compute the real part of  C = ca A - w D  (or  ca A' - w D )
C
        cr(1, 1) = ca*a(1, 1) - wr*d1
        cr(2, 2) = ca*a(2, 2) - wr*d2
        IF (ltrans) THEN
          DO nd=1,nbdirs
            crd(nd, 1, 2) = ca*ad(nd, 2, 1)
            crd(nd, 2, 1) = ca*ad(nd, 1, 2)
          ENDDO
          cr(1, 2) = ca*a(2, 1)
          cr(2, 1) = ca*a(1, 2)
        ELSE
          DO nd=1,nbdirs
            crd(nd, 2, 1) = ca*ad(nd, 2, 1)
            crd(nd, 1, 2) = ca*ad(nd, 1, 2)
          ENDDO
          cr(2, 1) = ca*a(2, 1)
          cr(1, 2) = ca*a(1, 2)
        END IF
        DO nd=1,nbdirs
          crvd(nd, 1) = crd(nd, 1, 1)
          crvd(nd, 2) = crd(nd, 2, 1)
          crvd(nd, 3) = crd(nd, 1, 2)
          crvd(nd, 4) = crd(nd, 2, 2)
        ENDDO
C
        crv(1) = cr(1, 1)
        crv(2) = cr(2, 1)
        crv(3) = cr(1, 2)
        crv(4) = cr(2, 2)
C
C
        IF (nw .EQ. 1) THEN
C
C           Real 2x2 system  (w is real)
C
C           Find the largest element in C
C
          cmax = zero
          icmax = 0
          DO nd=1,nbdirs
            cmaxd(nd) = 0.D0
          ENDDO
C
          DO j=1,4
            IF (crv(j) .GE. 0.) THEN
              abs4 = crv(j)
            ELSE
              abs4 = -crv(j)
            END IF
            IF (abs4 .GT. cmax) THEN
              IF (crv(j) .GE. 0.) THEN
                DO nd=1,nbdirs
                  cmaxd(nd) = crvd(nd, j)
                ENDDO
                cmax = crv(j)
              ELSE
                DO nd=1,nbdirs
                  cmaxd(nd) = -crvd(nd, j)
                ENDDO
                cmax = -crv(j)
              END IF
              icmax = j
            END IF
          ENDDO
C
C           If norm(C) < SMINI, use SMINI*identity.
C
          IF (cmax .LT. smini) THEN
            IF (b(1, 1) .GE. 0.) THEN
              DO nd=1,nbdirs
                x1d(nd) = bd(nd, 1, 1)
              ENDDO
              x1 = b(1, 1)
            ELSE
              DO nd=1,nbdirs
                x1d(nd) = -bd(nd, 1, 1)
              ENDDO
              x1 = -b(1, 1)
            END IF
            IF (b(2, 1) .GE. 0.) THEN
              DO nd=1,nbdirs
                y1d(nd) = bd(nd, 2, 1)
              ENDDO
              y1 = b(2, 1)
            ELSE
              DO nd=1,nbdirs
                y1d(nd) = -bd(nd, 2, 1)
              ENDDO
              y1 = -b(2, 1)
            END IF
            IF (x1 .LT. y1) THEN
              DO nd=1,nbdirs
                bnormd(nd) = y1d(nd)
              ENDDO
              bnorm = y1
            ELSE
              DO nd=1,nbdirs
                bnormd(nd) = x1d(nd)
              ENDDO
              bnorm = x1
            END IF
            IF (smini .LT. one .AND. bnorm .GT. one) THEN
              IF (bnorm .GT. bignum*smini) THEN
                DO nd=1,nbdirs
                  scaled(nd) = -(one*bnormd(nd)/bnorm**2)
                ENDDO
                scale = one/bnorm
              ELSE
                DO nd=1,nbdirs
                  scaled(nd) = 0.D0
                ENDDO
              END IF
            ELSE
              DO nd=1,nbdirs
                scaled(nd) = 0.D0
              ENDDO
            END IF
            temp = scale/smini
            DO nd=1,nbdirs
              tempd(nd) = (scaled(nd)*smini-scale*sminid(nd))/smini**2
              xd(nd, 1, 1) = tempd(nd)*b(1, 1) + temp*bd(nd, 1, 1)
              xd(nd, 2, 1) = tempd(nd)*b(2, 1) + temp*bd(nd, 2, 1)
            ENDDO
            x(1, 1) = temp*b(1, 1)
            x(2, 1) = temp*b(2, 1)
            xnorm = temp*bnorm
            info = 1
            RETURN
          ELSE
C
C           Gaussian elimination with complete pivoting.
C
            ur11 = crv(icmax)
            cr21 = crv(ipivot(2, icmax))
            ur12 = crv(ipivot(3, icmax))
            ur11r = one/ur11
            lr21 = ur11r*cr21
            DO nd=1,nbdirs
              cr21d(nd) = crvd(nd, ipivot(2, icmax))
              cr22d(nd) = crvd(nd, ipivot(4, icmax))
              ur12d(nd) = crvd(nd, ipivot(3, icmax))
              ur11d(nd) = crvd(nd, icmax)
              ur11rd(nd) = -(one*ur11d(nd)/ur11**2)
              lr21d(nd) = ur11rd(nd)*cr21 + ur11r*cr21d(nd)
              ur22d(nd) = cr22d(nd) - ur12d(nd)*lr21 - ur12*lr21d(nd)
            ENDDO
            cr22 = crv(ipivot(4, icmax))
            ur22 = cr22 - ur12*lr21
            IF (ur22 .GE. 0.) THEN
              abs5 = ur22
            ELSE
              abs5 = -ur22
            END IF
C
C           If smaller pivot < SMINI, use SMINI
C
            IF (abs5 .LT. smini) THEN
              DO nd=1,nbdirs
                ur22d(nd) = sminid(nd)
              ENDDO
              ur22 = smini
              info = 1
            END IF
            IF (rswap(icmax)) THEN
              DO nd=1,nbdirs
                br1d(nd) = bd(nd, 2, 1)
                br2d(nd) = bd(nd, 1, 1)
              ENDDO
              br1 = b(2, 1)
              br2 = b(1, 1)
            ELSE
              DO nd=1,nbdirs
                br1d(nd) = bd(nd, 1, 1)
                br2d(nd) = bd(nd, 2, 1)
              ENDDO
              br1 = b(1, 1)
              br2 = b(2, 1)
            END IF
            DO nd=1,nbdirs
              br2d(nd) = br2d(nd) - lr21d(nd)*br1 - lr21*br1d(nd)
            ENDDO
            br2 = br2 - lr21*br1
            IF (br1*(ur22*ur11r) .GE. 0.) THEN
              DO nd=1,nbdirs
                x2d(nd) = (br1d(nd)*ur22+br1*ur22d(nd))*ur11r + br1*ur22
     +            *ur11rd(nd)
              ENDDO
              x2 = br1*(ur22*ur11r)
            ELSE
              DO nd=1,nbdirs
                x2d(nd) = -((br1d(nd)*ur22+br1*ur22d(nd))*ur11r+br1*ur22
     +            *ur11rd(nd))
              ENDDO
              x2 = -(br1*(ur22*ur11r))
            END IF
            IF (br2 .GE. 0.) THEN
              DO nd=1,nbdirs
                y2d(nd) = br2d(nd)
              ENDDO
              y2 = br2
            ELSE
              DO nd=1,nbdirs
                y2d(nd) = -br2d(nd)
              ENDDO
              y2 = -br2
            END IF
            IF (x2 .LT. y2) THEN
              DO nd=1,nbdirs
                bbndd(nd) = y2d(nd)
              ENDDO
              bbnd = y2
            ELSE
              DO nd=1,nbdirs
                bbndd(nd) = x2d(nd)
              ENDDO
              bbnd = x2
            END IF
            IF (ur22 .GE. 0.) THEN
              abs6 = ur22
            ELSE
              abs6 = -ur22
            END IF
            IF (bbnd .GT. one .AND. abs6 .LT. one) THEN
              IF (ur22 .GE. 0.) THEN
                abs7 = ur22
              ELSE
                abs7 = -ur22
              END IF
              IF (bbnd .GE. bignum*abs7) THEN
                DO nd=1,nbdirs
                  scaled(nd) = -(one*bbndd(nd)/bbnd**2)
                ENDDO
                scale = one/bbnd
              ELSE
                DO nd=1,nbdirs
                  scaled(nd) = 0.D0
                ENDDO
              END IF
            ELSE
              DO nd=1,nbdirs
                scaled(nd) = 0.D0
              ENDDO
            END IF
C
            xr2 = br2*scale/ur22
            DO nd=1,nbdirs
              xr2d(nd) = ((br2d(nd)*scale+br2*scaled(nd))*ur22-br2*scale
     +          *ur22d(nd))/ur22**2
              xr1d(nd) = (scaled(nd)*br1+scale*br1d(nd))*ur11r + scale*
     +          br1*ur11rd(nd) - (xr2d(nd)*ur11r+xr2*ur11rd(nd))*ur12 -
     +          xr2*ur11r*ur12d(nd)
            ENDDO
            xr1 = scale*br1*ur11r - xr2*(ur11r*ur12)
            IF (zswap(icmax)) THEN
              DO nd=1,nbdirs
                xd(nd, 1, 1) = xr2d(nd)
                xd(nd, 2, 1) = xr1d(nd)
              ENDDO
              x(1, 1) = xr2
              x(2, 1) = xr1
            ELSE
              DO nd=1,nbdirs
                xd(nd, 1, 1) = xr1d(nd)
                xd(nd, 2, 1) = xr2d(nd)
              ENDDO
              x(1, 1) = xr1
              x(2, 1) = xr2
            END IF
            IF (xr1 .GE. 0.) THEN
              x3 = xr1
            ELSE
              x3 = -xr1
            END IF
            IF (xr2 .GE. 0.) THEN
              y3 = xr2
            ELSE
              y3 = -xr2
            END IF
            IF (x3 .LT. y3) THEN
              xnorm = y3
            ELSE
              xnorm = x3
            END IF
C
C           Further scaling if  norm(A) norm(X) > overflow
C
            IF (xnorm .GT. one .AND. cmax .GT. one) THEN
              IF (xnorm .GT. bignum/cmax) THEN
                temp = cmax/bignum
                DO nd=1,nbdirs
                  tempd(nd) = cmaxd(nd)/bignum
                  scaled(nd) = tempd(nd)*scale + temp*scaled(nd)
                  xd(nd, 1, 1) = tempd(nd)*x(1, 1) + temp*xd(nd, 1, 1)
                ENDDO
                x(1, 1) = temp*x(1, 1)
                DO nd=1,nbdirs
                  xd(nd, 2, 1) = tempd(nd)*x(2, 1) + temp*xd(nd, 2, 1)
                ENDDO
                x(2, 1) = temp*x(2, 1)
                xnorm = temp*xnorm
                scale = temp*scale
              END IF
            END IF
          END IF
        ELSE
C
C           Complex 2x2 system  (w is complex)
C
C           Find the largest element in C
C
          ci(1, 1) = -(wi*d1)
          ci(2, 1) = zero
          ci(1, 2) = zero
          ci(2, 2) = -(wi*d2)
          DO nd=1,nbdirs
            civd(nd, 1) = 0.D0
            civd(nd, 2) = 0.D0
            civd(nd, 3) = 0.D0
            civd(nd, 4) = 0.D0
            cid(nd, 1, 1) = 0.D0
            cid(nd, 2, 1) = 0.D0
            cid(nd, 1, 2) = 0.D0
            cid(nd, 2, 2) = 0.D0
          ENDDO
C
          civ(1) = ci(1, 1)
          civ(2) = ci(2, 1)
          civ(3) = ci(1, 2)
          civ(4) = ci(2, 2)
C
          cmax = zero
          icmax = 0
          DO nd=1,nbdirs
            cmaxd(nd) = 0.D0
          ENDDO
C
          DO j=1,4
            IF (crv(j) .GE. 0.) THEN
              abs8 = crv(j)
            ELSE
              abs8 = -crv(j)
            END IF
            IF (civ(j) .GE. 0.) THEN
              abs15 = civ(j)
            ELSE
              abs15 = -civ(j)
            END IF
            IF (abs8 + abs15 .GT. cmax) THEN
              IF (crv(j) .GE. 0.) THEN
                DO nd=1,nbdirs
                  abs9d(nd) = crvd(nd, j)
                ENDDO
                abs9 = crv(j)
              ELSE
                DO nd=1,nbdirs
                  abs9d(nd) = -crvd(nd, j)
                ENDDO
                abs9 = -crv(j)
              END IF
              IF (civ(j) .GE. 0.) THEN
                abs16 = civ(j)
              ELSE
                abs16 = -civ(j)
              END IF
              DO nd=1,nbdirs
                cmaxd(nd) = abs9d(nd)
              ENDDO
              cmax = abs9 + abs16
              icmax = j
            END IF
          ENDDO
C
C           If norm(C) < SMINI, use SMINI*identity.
C
          IF (cmax .LT. smini) THEN
            IF (b(1, 1) .GE. 0.) THEN
              DO nd=1,nbdirs
                abs17d(nd) = bd(nd, 1, 1)
              ENDDO
              abs17 = b(1, 1)
            ELSE
              DO nd=1,nbdirs
                abs17d(nd) = -bd(nd, 1, 1)
              ENDDO
              abs17 = -b(1, 1)
            END IF
            IF (b(1, 2) .GE. 0.) THEN
              DO nd=1,nbdirs
                abs25d(nd) = bd(nd, 1, 2)
              ENDDO
              abs25 = b(1, 2)
            ELSE
              DO nd=1,nbdirs
                abs25d(nd) = -bd(nd, 1, 2)
              ENDDO
              abs25 = -b(1, 2)
            END IF
            DO nd=1,nbdirs
              x4d(nd) = abs17d(nd) + abs25d(nd)
            ENDDO
            x4 = abs17 + abs25
            IF (b(2, 1) .GE. 0.) THEN
              DO nd=1,nbdirs
                abs18d(nd) = bd(nd, 2, 1)
              ENDDO
              abs18 = b(2, 1)
            ELSE
              DO nd=1,nbdirs
                abs18d(nd) = -bd(nd, 2, 1)
              ENDDO
              abs18 = -b(2, 1)
            END IF
            IF (b(2, 2) .GE. 0.) THEN
              DO nd=1,nbdirs
                abs26d(nd) = bd(nd, 2, 2)
              ENDDO
              abs26 = b(2, 2)
            ELSE
              DO nd=1,nbdirs
                abs26d(nd) = -bd(nd, 2, 2)
              ENDDO
              abs26 = -b(2, 2)
            END IF
            DO nd=1,nbdirs
              y4d(nd) = abs18d(nd) + abs26d(nd)
            ENDDO
            y4 = abs18 + abs26
            IF (x4 .LT. y4) THEN
              DO nd=1,nbdirs
                bnormd(nd) = y4d(nd)
              ENDDO
              bnorm = y4
            ELSE
              DO nd=1,nbdirs
                bnormd(nd) = x4d(nd)
              ENDDO
              bnorm = x4
            END IF
            IF (smini .LT. one .AND. bnorm .GT. one) THEN
              IF (bnorm .GT. bignum*smini) THEN
                DO nd=1,nbdirs
                  scaled(nd) = -(one*bnormd(nd)/bnorm**2)
                ENDDO
                scale = one/bnorm
              ELSE
                DO nd=1,nbdirs
                  scaled(nd) = 0.D0
                ENDDO
              END IF
            ELSE
              DO nd=1,nbdirs
                scaled(nd) = 0.D0
              ENDDO
            END IF
            temp = scale/smini
            DO nd=1,nbdirs
              tempd(nd) = (scaled(nd)*smini-scale*sminid(nd))/smini**2
              xd(nd, 1, 1) = tempd(nd)*b(1, 1) + temp*bd(nd, 1, 1)
              xd(nd, 2, 1) = tempd(nd)*b(2, 1) + temp*bd(nd, 2, 1)
              xd(nd, 1, 2) = tempd(nd)*b(1, 2) + temp*bd(nd, 1, 2)
              xd(nd, 2, 2) = tempd(nd)*b(2, 2) + temp*bd(nd, 2, 2)
            ENDDO
            x(1, 1) = temp*b(1, 1)
            x(2, 1) = temp*b(2, 1)
            x(1, 2) = temp*b(1, 2)
            x(2, 2) = temp*b(2, 2)
            xnorm = temp*bnorm
            info = 1
            RETURN
          ELSE
            DO nd=1,nbdirs
              ur11d(nd) = crvd(nd, icmax)
              cr22d(nd) = crvd(nd, ipivot(4, icmax))
              ur12d(nd) = crvd(nd, ipivot(3, icmax))
              cr21d(nd) = crvd(nd, ipivot(2, icmax))
            ENDDO
C
C           Gaussian elimination with complete pivoting.
C
            ur11 = crv(icmax)
            ui11 = civ(icmax)
            cr21 = crv(ipivot(2, icmax))
            ci21 = civ(ipivot(2, icmax))
            ur12 = crv(ipivot(3, icmax))
            ui12 = civ(ipivot(3, icmax))
            cr22 = crv(ipivot(4, icmax))
            ci22 = civ(ipivot(4, icmax))
            IF (icmax .EQ. 1 .OR. icmax .EQ. 4) THEN
              IF (ur11 .GE. 0.) THEN
                abs10 = ur11
              ELSE
                abs10 = -ur11
              END IF
              IF (ui11 .GE. 0.) THEN
                abs19 = ui11
              ELSE
                abs19 = -ui11
              END IF
C
C              Code when off-diagonals of pivoted C are real
C
              IF (abs10 .GT. abs19) THEN
                temp = ui11/ur11
                ur11r = one/(ur11*(one+temp**2))
                DO nd=1,nbdirs
                  tempd(nd) = -(ui11*ur11d(nd)/ur11**2)
                  ur11rd(nd) = -(one*(ur11d(nd)*(one+temp**2)+ur11*2*
     +              temp*tempd(nd))/(ur11*(one+temp**2))**2)
                  ui11rd(nd) = -(tempd(nd)*ur11r+temp*ur11rd(nd))
                ENDDO
                ui11r = -(temp*ur11r)
              ELSE
                temp = ur11/ui11
                ui11r = -(one/(ui11*(one+temp**2)))
                DO nd=1,nbdirs
                  tempd(nd) = ur11d(nd)/ui11
                  ui11rd(nd) = one*ui11*2*temp*tempd(nd)/(ui11*(one+temp
     +              **2))**2
                  ur11rd(nd) = -(tempd(nd)*ui11r+temp*ui11rd(nd))
                ENDDO
                ur11r = -(temp*ui11r)
              END IF
              lr21 = cr21*ur11r
              li21 = cr21*ui11r
              DO nd=1,nbdirs
                li21d(nd) = cr21d(nd)*ui11r + cr21*ui11rd(nd)
                lr21d(nd) = cr21d(nd)*ur11r + cr21*ur11rd(nd)
                ui22d(nd) = -(ur12d(nd)*li21) - ur12*li21d(nd)
                ur22d(nd) = cr22d(nd) - ur12d(nd)*lr21 - ur12*lr21d(nd)
                ui12sd(nd) = ur12d(nd)*ui11r + ur12*ui11rd(nd)
                ur12sd(nd) = ur12d(nd)*ur11r + ur12*ur11rd(nd)
              ENDDO
              ur12s = ur12*ur11r
              ui12s = ur12*ui11r
              ur22 = cr22 - ur12*lr21
              ui22 = ci22 - ur12*li21
            ELSE
C
C              Code when diagonals of pivoted C are real
C
              ur11r = one/ur11
              lr21 = cr21*ur11r
              li21 = ci21*ur11r
              DO nd=1,nbdirs
                ur11rd(nd) = -(one*ur11d(nd)/ur11**2)
                ui12sd(nd) = ui12*ur11rd(nd)
                ur12sd(nd) = ur12d(nd)*ur11r + ur12*ur11rd(nd)
                li21d(nd) = ci21*ur11rd(nd)
                lr21d(nd) = cr21d(nd)*ur11r + cr21*ur11rd(nd)
                ui22d(nd) = -(ur12d(nd)*li21) - ur12*li21d(nd) - ui12*
     +            lr21d(nd)
                ur22d(nd) = cr22d(nd) - ur12d(nd)*lr21 - ur12*lr21d(nd)
     +            + ui12*li21d(nd)
              ENDDO
              ui11r = zero
              ur12s = ur12*ur11r
              ui12s = ui12*ur11r
              ur22 = cr22 - ur12*lr21 + ui12*li21
              ui22 = -(ur12*li21) - ui12*lr21
              DO nd=1,nbdirs
                ui11rd(nd) = 0.D0
              ENDDO
            END IF
            IF (ur22 .GE. 0.) THEN
              DO nd=1,nbdirs
                abs11d(nd) = ur22d(nd)
              ENDDO
              abs11 = ur22
            ELSE
              DO nd=1,nbdirs
                abs11d(nd) = -ur22d(nd)
              ENDDO
              abs11 = -ur22
            END IF
            IF (ui22 .GE. 0.) THEN
              DO nd=1,nbdirs
                abs20d(nd) = ui22d(nd)
              ENDDO
              abs20 = ui22
            ELSE
              DO nd=1,nbdirs
                abs20d(nd) = -ui22d(nd)
              ENDDO
              abs20 = -ui22
            END IF
            DO nd=1,nbdirs
              u22absd(nd) = abs11d(nd) + abs20d(nd)
            ENDDO
            u22abs = abs11 + abs20
C
C           If smaller pivot < SMINI, use SMINI
C
            IF (u22abs .LT. smini) THEN
              DO nd=1,nbdirs
                ur22d(nd) = sminid(nd)
              ENDDO
              ur22 = smini
              ui22 = zero
              info = 1
              DO nd=1,nbdirs
                ui22d(nd) = 0.D0
              ENDDO
            END IF
            IF (rswap(icmax)) THEN
              DO nd=1,nbdirs
                br2d(nd) = bd(nd, 1, 1)
                bi1d(nd) = bd(nd, 2, 2)
                bi2d(nd) = bd(nd, 1, 2)
                br1d(nd) = bd(nd, 2, 1)
              ENDDO
              br2 = b(1, 1)
              br1 = b(2, 1)
              bi2 = b(1, 2)
              bi1 = b(2, 2)
            ELSE
              DO nd=1,nbdirs
                br1d(nd) = bd(nd, 1, 1)
                bi2d(nd) = bd(nd, 2, 2)
                bi1d(nd) = bd(nd, 1, 2)
                br2d(nd) = bd(nd, 2, 1)
              ENDDO
              br1 = b(1, 1)
              br2 = b(2, 1)
              bi1 = b(1, 2)
              bi2 = b(2, 2)
            END IF
            DO nd=1,nbdirs
              br2d(nd) = br2d(nd) - lr21d(nd)*br1 - lr21*br1d(nd) +
     +          li21d(nd)*bi1 + li21*bi1d(nd)
              bi2d(nd) = bi2d(nd) - li21d(nd)*br1 - li21*br1d(nd) -
     +          lr21d(nd)*bi1 - lr21*bi1d(nd)
            ENDDO
            br2 = br2 - lr21*br1 + li21*bi1
            bi2 = bi2 - li21*br1 - lr21*bi1
            IF (br1 .GE. 0.) THEN
              DO nd=1,nbdirs
                abs21d(nd) = br1d(nd)
              ENDDO
              abs21 = br1
            ELSE
              DO nd=1,nbdirs
                abs21d(nd) = -br1d(nd)
              ENDDO
              abs21 = -br1
            END IF
            IF (bi1 .GE. 0.) THEN
              DO nd=1,nbdirs
                abs27d(nd) = bi1d(nd)
              ENDDO
              abs27 = bi1
            ELSE
              DO nd=1,nbdirs
                abs27d(nd) = -bi1d(nd)
              ENDDO
              abs27 = -bi1
            END IF
            IF (ur11r .GE. 0.) THEN
              DO nd=1,nbdirs
                abs31d(nd) = ur11rd(nd)
              ENDDO
              abs31 = ur11r
            ELSE
              DO nd=1,nbdirs
                abs31d(nd) = -ur11rd(nd)
              ENDDO
              abs31 = -ur11r
            END IF
            IF (ui11r .GE. 0.) THEN
              DO nd=1,nbdirs
                abs32d(nd) = ui11rd(nd)
              ENDDO
              abs32 = ui11r
            ELSE
              DO nd=1,nbdirs
                abs32d(nd) = -ui11rd(nd)
              ENDDO
              abs32 = -ui11r
            END IF
            DO nd=1,nbdirs
              x5d(nd) = ((abs21d(nd)+abs27d(nd))*u22abs+(abs21+abs27)*
     +          u22absd(nd))*(abs31+abs32) + (abs21+abs27)*u22abs*(
     +          abs31d(nd)+abs32d(nd))
            ENDDO
            x5 = (abs21+abs27)*(u22abs*(abs31+abs32))
            IF (br2 .GE. 0.) THEN
              DO nd=1,nbdirs
                abs22d(nd) = br2d(nd)
              ENDDO
              abs22 = br2
            ELSE
              DO nd=1,nbdirs
                abs22d(nd) = -br2d(nd)
              ENDDO
              abs22 = -br2
            END IF
            IF (bi2 .GE. 0.) THEN
              DO nd=1,nbdirs
                abs28d(nd) = bi2d(nd)
              ENDDO
              abs28 = bi2
            ELSE
              DO nd=1,nbdirs
                abs28d(nd) = -bi2d(nd)
              ENDDO
              abs28 = -bi2
            END IF
            DO nd=1,nbdirs
              y5d(nd) = abs22d(nd) + abs28d(nd)
            ENDDO
            y5 = abs22 + abs28
            IF (x5 .LT. y5) THEN
              DO nd=1,nbdirs
                bbndd(nd) = y5d(nd)
              ENDDO
              bbnd = y5
            ELSE
              DO nd=1,nbdirs
                bbndd(nd) = x5d(nd)
              ENDDO
              bbnd = x5
            END IF
            IF (bbnd .GT. one .AND. u22abs .LT. one) THEN
              IF (bbnd .GE. bignum*u22abs) THEN
                scale = one/bbnd
                DO nd=1,nbdirs
                  scaled(nd) = -(one*bbndd(nd)/bbnd**2)
                  bi2d(nd) = scaled(nd)*bi2 + scale*bi2d(nd)
                  br2d(nd) = scaled(nd)*br2 + scale*br2d(nd)
                  bi1d(nd) = scaled(nd)*bi1 + scale*bi1d(nd)
                  br1d(nd) = scaled(nd)*br1 + scale*br1d(nd)
                ENDDO
                br1 = scale*br1
                bi1 = scale*bi1
                br2 = scale*br2
                bi2 = scale*bi2
              ELSE
                DO nd=1,nbdirs
                  scaled(nd) = 0.D0
                ENDDO
              END IF
            ELSE
              DO nd=1,nbdirs
                scaled(nd) = 0.D0
              ENDDO
            END IF
C
            CALL DLADIV_DV(br2, br2d, bi2, bi2d, ur22, ur22d, ui22,
     +                     ui22d, xr2, xr2d, xi2, xi2d, nbdirs)
            DO nd=1,nbdirs
              xr1d(nd) = ur11rd(nd)*br1 + ur11r*br1d(nd) - ui11rd(nd)*
     +          bi1 - ui11r*bi1d(nd) - ur12sd(nd)*xr2 - ur12s*xr2d(nd) +
     +          ui12sd(nd)*xi2 + ui12s*xi2d(nd)
              xi1d(nd) = ui11rd(nd)*br1 + ui11r*br1d(nd) + ur11rd(nd)*
     +          bi1 + ur11r*bi1d(nd) - ui12sd(nd)*xr2 - ui12s*xr2d(nd) -
     +          ur12sd(nd)*xi2 - ur12s*xi2d(nd)
            ENDDO
            xr1 = ur11r*br1 - ui11r*bi1 - ur12s*xr2 + ui12s*xi2
            xi1 = ui11r*br1 + ur11r*bi1 - ui12s*xr2 - ur12s*xi2
            IF (zswap(icmax)) THEN
              DO nd=1,nbdirs
                xd(nd, 1, 1) = xr2d(nd)
                xd(nd, 2, 1) = xr1d(nd)
                xd(nd, 1, 2) = xi2d(nd)
                xd(nd, 2, 2) = xi1d(nd)
              ENDDO
              x(1, 1) = xr2
              x(2, 1) = xr1
              x(1, 2) = xi2
              x(2, 2) = xi1
            ELSE
              DO nd=1,nbdirs
                xd(nd, 1, 1) = xr1d(nd)
                xd(nd, 2, 1) = xr2d(nd)
                xd(nd, 1, 2) = xi1d(nd)
                xd(nd, 2, 2) = xi2d(nd)
              ENDDO
              x(1, 1) = xr1
              x(2, 1) = xr2
              x(1, 2) = xi1
              x(2, 2) = xi2
            END IF
            IF (xr1 .GE. 0.) THEN
              abs23 = xr1
            ELSE
              abs23 = -xr1
            END IF
            IF (xi1 .GE. 0.) THEN
              abs29 = xi1
            ELSE
              abs29 = -xi1
            END IF
            x6 = abs23 + abs29
            IF (xr2 .GE. 0.) THEN
              abs24 = xr2
            ELSE
              abs24 = -xr2
            END IF
            IF (xi2 .GE. 0.) THEN
              abs30 = xi2
            ELSE
              abs30 = -xi2
            END IF
            y6 = abs24 + abs30
            IF (x6 .LT. y6) THEN
              xnorm = y6
            ELSE
              xnorm = x6
            END IF
C
C           Further scaling if  norm(A) norm(X) > overflow
C
            IF (xnorm .GT. one .AND. cmax .GT. one) THEN
              IF (xnorm .GT. bignum/cmax) THEN
                temp = cmax/bignum
                DO nd=1,nbdirs
                  tempd(nd) = cmaxd(nd)/bignum
                  scaled(nd) = tempd(nd)*scale + temp*scaled(nd)
                  xd(nd, 1, 1) = tempd(nd)*x(1, 1) + temp*xd(nd, 1, 1)
                ENDDO
                x(1, 1) = temp*x(1, 1)
                DO nd=1,nbdirs
                  xd(nd, 2, 1) = tempd(nd)*x(2, 1) + temp*xd(nd, 2, 1)
                ENDDO
                x(2, 1) = temp*x(2, 1)
                DO nd=1,nbdirs
                  xd(nd, 1, 2) = tempd(nd)*x(1, 2) + temp*xd(nd, 1, 2)
                ENDDO
                x(1, 2) = temp*x(1, 2)
                DO nd=1,nbdirs
                  xd(nd, 2, 2) = tempd(nd)*x(2, 2) + temp*xd(nd, 2, 2)
                ENDDO
                x(2, 2) = temp*x(2, 2)
                xnorm = temp*xnorm
                scale = temp*scale
              END IF
            END IF
          END IF
        END IF
      END IF
C
      RETURN
      END

!
! Copyright (C) 2006-2014 Houtan Bastani and Luca Guerrieri
!
!
! This free software: you can redistribute it and/or modify
! it under the terms of the GNU General Public License as published by
! the Free Software Foundation, either version 3 of the License, or
! (at your option) any later version.
!
! It is distributed in the hope that it will be useful,
! but WITHOUT ANY WARRANTY; without even the implied warranty of
! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
! GNU General Public License for more details.
!
! You should have received a copy of the GNU General Public License
! along with Dynare.  If not, see <http://www.gnu.org/licenses/>.
!

C        Generated by TAPENADE     (INRIA, Tropics team)
C  Tapenade - Version 2.2 (r1239) - Wed 28 Jun 2006 04:59:55 PM CEST
C
C  Differentiation of dladiv in forward (tangent) mode: (multi-directional mode)
C   variations  of output variables: p q
C   with respect to input variables: d a b c
      SUBROUTINE DLADIV_DV(a, ad, b, bd, c, cd, d, dd, p, pd, q, qd,
     +                     nbdirs)
      USE DIFFSIZES
      IMPLICIT NONE
C
C     End of DLADIV
C
      INTEGER nbdirs
      DOUBLE PRECISION a, ad(nbdirsmax), b, bd(nbdirsmax), c, cd(
     +                 nbdirsmax), d, dd(nbdirsmax), p, pd(nbdirsmax), q
     +                 , qd(nbdirsmax)
      DOUBLE PRECISION abs1, abs2
      DOUBLE PRECISION e, ed(nbdirsmax), f, fd(nbdirsmax)
      INTEGER nd
      INTRINSIC ABS
      IF (d .GE. 0.) THEN
        abs1 = d
      ELSE
        abs1 = -d
      END IF
      IF (c .GE. 0.) THEN
        abs2 = c
      ELSE
        abs2 = -c
      END IF
C
C  -- LAPACK auxiliary routine (version 3.1) --
C     Univ. of Tennessee, Univ. of California Berkeley and NAG Ltd..
C     November 2006
C
C     .. Scalar Arguments ..
C     ..
C
C  Purpose
C  =======
C
C  DLADIV performs complex division in  real arithmetic
C
C                        a + i*b
C             p + i*q = ---------
C                        c + i*d
C
C  The algorithm is due to Robert L. Smith and can be found
C  in D. Knuth, The art of Computer Programming, Vol.2, p.195
C
C  Arguments
C  =========
C
C  A       (input) DOUBLE PRECISION
C  B       (input) DOUBLE PRECISION
C  C       (input) DOUBLE PRECISION
C  D       (input) DOUBLE PRECISION
C          The scalars a, b, c, and d in the above expression.
C
C  P       (output) DOUBLE PRECISION
C  Q       (output) DOUBLE PRECISION
C          The scalars p and q in the above expression.
C
C  =====================================================================
C
C     .. Local Scalars ..
C     ..
C     .. Intrinsic Functions ..
C     ..
C     .. Executable Statements ..
C
      IF (abs1 .LT. abs2) THEN
        e = d/c
        f = c + d*e
        DO nd=1,nbdirs
          ed(nd) = (dd(nd)*c-d*cd(nd))/c**2
          fd(nd) = cd(nd) + dd(nd)*e + d*ed(nd)
          qd(nd) = ((bd(nd)-ad(nd)*e-a*ed(nd))*f-(b-a*e)*fd(nd))/f**2
          pd(nd) = ((ad(nd)+bd(nd)*e+b*ed(nd))*f-(a+b*e)*fd(nd))/f**2
        ENDDO
        p = (a+b*e)/f
        q = (b-a*e)/f
      ELSE
        e = c/d
        f = d + c*e
        DO nd=1,nbdirs
          ed(nd) = (cd(nd)*d-c*dd(nd))/d**2
          fd(nd) = dd(nd) + cd(nd)*e + c*ed(nd)
          qd(nd) = ((bd(nd)*e-ad(nd)+b*ed(nd))*f-(-a+b*e)*fd(nd))/f**2
          pd(nd) = ((bd(nd)+ad(nd)*e+a*ed(nd))*f-(b+a*e)*fd(nd))/f**2
        ENDDO
        p = (b+a*e)/f
        q = (-a+b*e)/f
      END IF
C
      RETURN
      END

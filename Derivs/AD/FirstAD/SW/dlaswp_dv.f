!
! Copyright (C) 2006-2014 Houtan Bastani and Luca Guerrieri
!
!
! This free software: you can redistribute it and/or modify
! it under the terms of the GNU General Public License as published by
! the Free Software Foundation, either version 3 of the License, or
! (at your option) any later version.
!
! It is distributed in the hope that it will be useful,
! but WITHOUT ANY WARRANTY; without even the implied warranty of
! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
! GNU General Public License for more details.
!
! You should have received a copy of the GNU General Public License
! along with Dynare.  If not, see <http://www.gnu.org/licenses/>.
!

C        Generated by TAPENADE     (INRIA, Tropics team)
C  Tapenade - Version 2.2 (r1239) - Wed 28 Jun 2006 04:59:55 PM CEST
C
C  Differentiation of dlaswp in forward (tangent) mode: (multi-directional mode)
C   variations  of output variables: a
C   with respect to input variables: a
      SUBROUTINE DLASWP_DV(n, a, ad, lda, k1, k2, ipiv, incx, nbdirs)
      USE DIFFSIZES
      IMPLICIT NONE
C
C     End of DLASWP
C
      INTEGER incx, ipiv(*), k1, k2, n
      INTEGER lda, nbdirs
      DOUBLE PRECISION a(lda, *), ad(nbdirsmax, lda, *)
      INTEGER i, i1, i2, inc, ip, ix, ix0, j, k, n32, nd
      DOUBLE PRECISION temp, tempd(nbdirsmax)
C
C  -- LAPACK auxiliary routine (version 3.1) --
C     Univ. of Tennessee, Univ. of California Berkeley and NAG Ltd..
C     November 2006
C
C     .. Scalar Arguments ..
C     ..
C     .. Array Arguments ..
C     ..
C
C  Purpose
C  =======
C
C  DLASWP performs a series of row interchanges on the matrix A.
C  One row interchange is initiated for each of rows K1 through K2 of A.
C
C  Arguments
C  =========
C
C  N       (input) INTEGER
C          The number of columns of the matrix A.
C
C  A       (input/output) DOUBLE PRECISION array, dimension (LDA,N)
C          On entry, the matrix of column dimension N to which the row
C          interchanges will be applied.
C          On exit, the permuted matrix.
C
C  LDA     (input) INTEGER
C          The leading dimension of the array A.
C
C  K1      (input) INTEGER
C          The first element of IPIV for which a row interchange will
C          be done.
C
C  K2      (input) INTEGER
C          The last element of IPIV for which a row interchange will
C          be done.
C
C  IPIV    (input) INTEGER array, dimension (K2*abs(INCX))
C          The vector of pivot indices.  Only the elements in positions
C          K1 through K2 of IPIV are accessed.
C          IPIV(K) = L implies rows K and L are to be interchanged.
C
C  INCX    (input) INTEGER
C          The increment between successive values of IPIV.  If IPIV
C          is negative, the pivots are applied in reverse order.
C
C  Further Details
C  ===============
C
C  Modified by
C   R. C. Whaley, Computer Science Dept., Univ. of Tenn., Knoxville, USA
C
C =====================================================================
C
C     .. Local Scalars ..
C     ..
C     .. Executable Statements ..
C
C     Interchange row I with row IPIV(I) for each of rows K1 through K2.
C
      IF (incx .GT. 0) THEN
        ix0 = k1
        i1 = k1
        i2 = k2
        inc = 1
      ELSE IF (incx .LT. 0) THEN
        ix0 = 1 + (1-k2)*incx
        i1 = k2
        i2 = k1
        inc = -1
      ELSE
        RETURN
      END IF
C
      n32 = n/32*32
      IF (n32 .NE. 0) THEN
        DO j=1,n32,32
          ix = ix0
          DO i=i1,i2,inc
            ip = ipiv(ix)
            IF (ip .NE. i) THEN
              DO k=j,j+31
                DO nd=1,nbdirs
                  tempd(nd) = ad(nd, i, k)
                  ad(nd, i, k) = ad(nd, ip, k)
                  ad(nd, ip, k) = tempd(nd)
                ENDDO
                temp = a(i, k)
                a(i, k) = a(ip, k)
                a(ip, k) = temp
              ENDDO
            END IF
            ix = ix + incx
          ENDDO
        ENDDO
      END IF
      IF (n32 .NE. n) THEN
        n32 = n32 + 1
        ix = ix0
        DO i=i1,i2,inc
          ip = ipiv(ix)
          IF (ip .NE. i) THEN
            DO k=n32,n
              DO nd=1,nbdirs
                tempd(nd) = ad(nd, i, k)
                ad(nd, i, k) = ad(nd, ip, k)
                ad(nd, ip, k) = tempd(nd)
              ENDDO
              temp = a(i, k)
              a(i, k) = a(ip, k)
              a(ip, k) = temp
            ENDDO
          END IF
          ix = ix + incx
        ENDDO
      END IF
C
      RETURN
      END

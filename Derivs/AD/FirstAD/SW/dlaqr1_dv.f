!
! Copyright (C) 2006-2014 Houtan Bastani and Luca Guerrieri
!
!
! This free software: you can redistribute it and/or modify
! it under the terms of the GNU General Public License as published by
! the Free Software Foundation, either version 3 of the License, or
! (at your option) any later version.
!
! It is distributed in the hope that it will be useful,
! but WITHOUT ANY WARRANTY; without even the implied warranty of
! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
! GNU General Public License for more details.
!
! You should have received a copy of the GNU General Public License
! along with Dynare.  If not, see <http://www.gnu.org/licenses/>.
!

C        Generated by TAPENADE     (INRIA, Tropics team)
C  Tapenade - Version 2.2 (r1239) - Wed 28 Jun 2006 04:59:55 PM CEST
C
C  Differentiation of dlaqr1 in forward (tangent) mode: (multi-directional mode)
C   variations  of output variables: v
C   with respect to input variables: h v si1 si2 sr1 sr2
      SUBROUTINE DLAQR1_DV(n, h, hd, ldh, sr1, sr1d, si1, si1d, sr2,
     +                     sr2d, si2, si2d, v, vd, nbdirs)
      USE DIFFSIZES
      IMPLICIT NONE
      INTEGER ldh, nbdirs
      INTEGER n
      DOUBLE PRECISION si1, si1d(nbdirsmax), si2, si2d(nbdirsmax), sr1,
     +                 sr1d(nbdirsmax), sr2, sr2d(nbdirsmax)
      DOUBLE PRECISION h(ldh, *), hd(nbdirsmax, ldh, *), v(*), vd(
     +                 nbdirsmax, *)
      DOUBLE PRECISION zero
      PARAMETER (zero=0.0d0)
      DOUBLE PRECISION abs1, abs1d(nbdirsmax), abs2, abs2d(nbdirsmax),
     +                 abs5, abs5d(nbdirsmax), abs6, abs6d(nbdirsmax),
     +                 abs7, abs7d(nbdirsmax)
      DOUBLE PRECISION abs3, abs3d(nbdirsmax), abs4, abs4d(nbdirsmax)
      DOUBLE PRECISION h21s, h21sd(nbdirsmax), h31s, h31sd(nbdirsmax), s
     +                 , sd(nbdirsmax)
      INTEGER nd
      INTRINSIC ABS
C
C  -- LAPACK auxiliary routine (version 3.1) --
C     Univ. of Tennessee, Univ. of California Berkeley and NAG Ltd..
C     November 2006
C
C     .. Scalar Arguments ..
C     ..
C     .. Array Arguments ..
C     ..
C
C       Given a 2-by-2 or 3-by-3 matrix H, DLAQR1 sets v to a
C       scalar multiple of the first column of the product
C
C       (*)  K = (H - (sr1 + i*si1)*I)*(H - (sr2 + i*si2)*I)
C
C       scaling to avoid overflows and most underflows. It
C       is assumed that either
C
C               1) sr1 = sr2 and si1 = -si2
C           or
C               2) si1 = si2 = 0.
C
C       This is useful for starting double implicit shift bulges
C       in the QR algorithm.
C
C
C       N      (input) integer
C              Order of the matrix H. N must be either 2 or 3.
C
C       H      (input) DOUBLE PRECISION array of dimension (LDH,N)
C              The 2-by-2 or 3-by-3 matrix H in (*).
C
C       LDH    (input) integer
C              The leading dimension of H as declared in
C              the calling procedure.  LDH.GE.N
C
C       SR1    (input) DOUBLE PRECISION
C       SI1    The shifts in (*).
C       SR2
C       SI2
C
C       V      (output) DOUBLE PRECISION array of dimension N
C              A scalar multiple of the first column of the
C              matrix K in (*).
C
C     ================================================================
C     Based on contributions by
C        Karen Braman and Ralph Byers, Department of Mathematics,
C        University of Kansas, USA
C
C     ================================================================
C
C     .. Parameters ..
C     ..
C     .. Local Scalars ..
C     ..
C     .. Intrinsic Functions ..
C     ..
C     .. Executable Statements ..
      IF (n .EQ. 2) THEN
        IF (h(1, 1) - sr2 .GE. 0.) THEN
          DO nd=1,nbdirs
            abs1d(nd) = hd(nd, 1, 1) - sr2d(nd)
          ENDDO
          abs1 = h(1, 1) - sr2
        ELSE
          DO nd=1,nbdirs
            abs1d(nd) = -(hd(nd, 1, 1)-sr2d(nd))
          ENDDO
          abs1 = -(h(1, 1)-sr2)
        END IF
        IF (si2 .GE. 0.) THEN
          DO nd=1,nbdirs
            abs3d(nd) = si2d(nd)
          ENDDO
          abs3 = si2
        ELSE
          DO nd=1,nbdirs
            abs3d(nd) = -si2d(nd)
          ENDDO
          abs3 = -si2
        END IF
        IF (h(2, 1) .GE. 0.) THEN
          DO nd=1,nbdirs
            abs5d(nd) = hd(nd, 2, 1)
          ENDDO
          abs5 = h(2, 1)
        ELSE
          DO nd=1,nbdirs
            abs5d(nd) = -hd(nd, 2, 1)
          ENDDO
          abs5 = -h(2, 1)
        END IF
        DO nd=1,nbdirs
          sd(nd) = abs1d(nd) + abs3d(nd) + abs5d(nd)
        ENDDO
        s = abs1 + abs3 + abs5
        IF (s .EQ. zero) THEN
          DO nd=1,nbdirs
            vd(nd, 1) = 0.D0
            vd(nd, 2) = 0.D0
          ENDDO
          v(1) = zero
          v(2) = zero
        ELSE
          h21s = h(2, 1)/s
          DO nd=1,nbdirs
            h21sd(nd) = (hd(nd, 2, 1)*s-h(2, 1)*sd(nd))/s**2
            vd(nd, 1) = h21sd(nd)*h(1, 2) + h21s*hd(nd, 1, 2) + (hd(nd,
     +        1, 1)-sr1d(nd))*(h(1, 1)-sr2)/s + (h(1, 1)-sr1)*((hd(nd, 1
     +        , 1)-sr2d(nd))*s-(h(1, 1)-sr2)*sd(nd))/s**2 - si1d(nd)*si2
     +        /s - si1*(si2d(nd)*s-si2*sd(nd))/s**2
            vd(nd, 2) = h21sd(nd)*(h(1, 1)+h(2, 2)-sr1-sr2) + h21s*(hd(
     +        nd, 1, 1)+hd(nd, 2, 2)-sr1d(nd)-sr2d(nd))
          ENDDO
          v(1) = h21s*h(1, 2) + (h(1, 1)-sr1)*((h(1, 1)-sr2)/s) - si1*(
     +      si2/s)
          v(2) = h21s*(h(1, 1)+h(2, 2)-sr1-sr2)
        END IF
      ELSE
        IF (h(1, 1) - sr2 .GE. 0.) THEN
          DO nd=1,nbdirs
            abs2d(nd) = hd(nd, 1, 1) - sr2d(nd)
          ENDDO
          abs2 = h(1, 1) - sr2
        ELSE
          DO nd=1,nbdirs
            abs2d(nd) = -(hd(nd, 1, 1)-sr2d(nd))
          ENDDO
          abs2 = -(h(1, 1)-sr2)
        END IF
        IF (si2 .GE. 0.) THEN
          DO nd=1,nbdirs
            abs4d(nd) = si2d(nd)
          ENDDO
          abs4 = si2
        ELSE
          DO nd=1,nbdirs
            abs4d(nd) = -si2d(nd)
          ENDDO
          abs4 = -si2
        END IF
        IF (h(2, 1) .GE. 0.) THEN
          DO nd=1,nbdirs
            abs6d(nd) = hd(nd, 2, 1)
          ENDDO
          abs6 = h(2, 1)
        ELSE
          DO nd=1,nbdirs
            abs6d(nd) = -hd(nd, 2, 1)
          ENDDO
          abs6 = -h(2, 1)
        END IF
        IF (h(3, 1) .GE. 0.) THEN
          DO nd=1,nbdirs
            abs7d(nd) = hd(nd, 3, 1)
          ENDDO
          abs7 = h(3, 1)
        ELSE
          DO nd=1,nbdirs
            abs7d(nd) = -hd(nd, 3, 1)
          ENDDO
          abs7 = -h(3, 1)
        END IF
        DO nd=1,nbdirs
          sd(nd) = abs2d(nd) + abs4d(nd) + abs6d(nd) + abs7d(nd)
        ENDDO
        s = abs2 + abs4 + abs6 + abs7
        IF (s .EQ. zero) THEN
          DO nd=1,nbdirs
            vd(nd, 1) = 0.D0
            vd(nd, 2) = 0.D0
            vd(nd, 3) = 0.D0
          ENDDO
          v(1) = zero
          v(2) = zero
          v(3) = zero
        ELSE
          h21s = h(2, 1)/s
          h31s = h(3, 1)/s
          DO nd=1,nbdirs
            h31sd(nd) = (hd(nd, 3, 1)*s-h(3, 1)*sd(nd))/s**2
            h21sd(nd) = (hd(nd, 2, 1)*s-h(2, 1)*sd(nd))/s**2
            vd(nd, 1) = (hd(nd, 1, 1)-sr1d(nd))*(h(1, 1)-sr2)/s + (h(1,
     +        1)-sr1)*((hd(nd, 1, 1)-sr2d(nd))*s-(h(1, 1)-sr2)*sd(nd))/s
     +        **2 - si1d(nd)*si2/s - si1*(si2d(nd)*s-si2*sd(nd))/s**2 +
     +        hd(nd, 1, 2)*h21s + h(1, 2)*h21sd(nd) + hd(nd, 1, 3)*h31s
     +        + h(1, 3)*h31sd(nd)
            vd(nd, 2) = h21sd(nd)*(h(1, 1)+h(2, 2)-sr1-sr2) + h21s*(hd(
     +        nd, 1, 1)+hd(nd, 2, 2)-sr1d(nd)-sr2d(nd)) + hd(nd, 2, 3)*
     +        h31s + h(2, 3)*h31sd(nd)
            vd(nd, 3) = h31sd(nd)*(h(1, 1)+h(3, 3)-sr1-sr2) + h31s*(hd(
     +        nd, 1, 1)+hd(nd, 3, 3)-sr1d(nd)-sr2d(nd)) + h21sd(nd)*h(3
     +        , 2) + h21s*hd(nd, 3, 2)
          ENDDO
          v(1) = (h(1, 1)-sr1)*((h(1, 1)-sr2)/s) - si1*(si2/s) + h(1, 2)
     +      *h21s + h(1, 3)*h31s
          v(2) = h21s*(h(1, 1)+h(2, 2)-sr1-sr2) + h(2, 3)*h31s
          v(3) = h31s*(h(1, 1)+h(3, 3)-sr1-sr2) + h21s*h(3, 2)
        END IF
      END IF
      END

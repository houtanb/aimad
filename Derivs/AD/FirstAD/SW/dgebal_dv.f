!
! Copyright (C) 2006-2014 Houtan Bastani and Luca Guerrieri
!
!
! This free software: you can redistribute it and/or modify
! it under the terms of the GNU General Public License as published by
! the Free Software Foundation, either version 3 of the License, or
! (at your option) any later version.
!
! It is distributed in the hope that it will be useful,
! but WITHOUT ANY WARRANTY; without even the implied warranty of
! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
! GNU General Public License for more details.
!
! You should have received a copy of the GNU General Public License
! along with Dynare.  If not, see <http://www.gnu.org/licenses/>.
!

C        Generated by TAPENADE     (INRIA, Tropics team)
C  Tapenade - Version 2.2 (r1239) - Wed 28 Jun 2006 04:59:55 PM CEST
C
C  Differentiation of dgebal in forward (tangent) mode: (multi-directional mode)
C   variations  of output variables: scale a
C   with respect to input variables: scale a
      SUBROUTINE DGEBAL_DV(job, n, a, ad, lda, ilo, ihi, scale, scaled,
     +                     info, nbdirs)

      USE DIFFSIZES
      IMPLICIT NONE
C
C     End of DGEBAL
C
      INTEGER ihi, ii1, ii2, ilo, info, n
      CHARACTER job
      INTEGER lda, nbdirs
      DOUBLE PRECISION a(lda, n), ad(nbdirsmax, lda, n),
     +                 scale(n), scaled(nbdirsmax,
     +                 n)
      DOUBLE PRECISION factor
      PARAMETER (factor=0.95d+0)
      DOUBLE PRECISION one, zero
      PARAMETER (one=1.0d+0, zero=0.0d+0)
      DOUBLE PRECISION sclfac
      PARAMETER (sclfac=2.0d+0)
      DOUBLE PRECISION abs1, abs2
      DOUBLE PRECISION c, ca, f, fd(nbdirsmax), g, gd(nbdirsmax), max2,
     +                 max3, min1, r, ra, s, sfmax1, sfmax2, sfmin1,
     +                 sfmin2
      INTEGER arg1, i, ica, IDAMAX, iexc, ira, j, k, l, m, max1, nd
      DOUBLE PRECISION DLAMCH, result10, result20
      LOGICAL LSAME, noconv, result1, result2, result3, result4
      EXTERNAL LSAME, DLAMCH
      INTRINSIC MAX, ABS, MIN
C
C  -- LAPACK routine (version 3.1) --
C     Univ. of Tennessee, Univ. of California Berkeley and NAG Ltd..
C     November 2006
C
C     .. Scalar Arguments ..
C     ..
C     .. Array Arguments ..
C     ..
C
C  Purpose
C  =======
C
C  DGEBAL balances a general real matrix A.  This involves, first,
C  permuting A by a similarity transformation to isolate eigenvalues
C  in the first 1 to ILO-1 and last IHI+1 to N elements on the
C  diagonal; and second, applying a diagonal similarity transformation
C  to rows and columns ILO to IHI to make the rows and columns as
C  close in norm as possible.  Both steps are optional.
C
C  Balancing may reduce the 1-norm of the matrix, and improve the
C  accuracy of the computed eigenvalues and/or eigenvectors.
C
C  Arguments
C  =========
C
C  JOB     (input) CHARACTER*1
C          Specifies the operations to be performed on A:
C          = 'N':  none:  simply set ILO = 1, IHI = N, SCALE(I) = 1.0
C                  for i = 1,...,N;
C          = 'P':  permute only;
C          = 'S':  scale only;
C          = 'B':  both permute and scale.
C
C  N       (input) INTEGER
C          The order of the matrix A.  N >= 0.
C
C  A       (input/output) DOUBLE PRECISION array, dimension (LDA,N)
C          On entry, the input matrix A.
C          On exit,  A is overwritten by the balanced matrix.
C          If JOB = 'N', A is not referenced.
C          See Further Details.
C
C  LDA     (input) INTEGER
C          The leading dimension of the array A.  LDA >= max(1,N).
C
C  ILO     (output) INTEGER
C  IHI     (output) INTEGER
C          ILO and IHI are set to integers such that on exit
C          A(i,j) = 0 if i > j and j = 1,...,ILO-1 or I = IHI+1,...,N.
C          If JOB = 'N' or 'S', ILO = 1 and IHI = N.
C
C  SCALE   (output) DOUBLE PRECISION array, dimension (N)
C          Details of the permutations and scaling factors applied to
C          A.  If P(j) is the index of the row and column interchanged
C          with row and column j and D(j) is the scaling factor
C          applied to row and column j, then
C          SCALE(j) = P(j)    for j = 1,...,ILO-1
C                   = D(j)    for j = ILO,...,IHI
C                   = P(j)    for j = IHI+1,...,N.
C          The order in which the interchanges are made is N to IHI+1,
C          then 1 to ILO-1.
C
C  INFO    (output) INTEGER
C          = 0:  successful exit.
C          < 0:  if INFO = -i, the i-th argument had an illegal value.
C
C  Further Details
C  ===============
C
C  The permutations consist of row and column interchanges which put
C  the matrix in the form
C
C             ( T1   X   Y  )
C     P A P = (  0   B   Z  )
C             (  0   0   T2 )
C
C  where T1 and T2 are upper triangular matrices whose eigenvalues lie
C  along the diagonal.  The column indices ILO and IHI mark the starting
C  and ending columns of the submatrix B. Balancing consists of applying
C  a diagonal similarity transformation inv(D) * B * D to make the
C  1-norms of each row of B and its corresponding column nearly equal.
C  The output matrix is
C
C     ( T1     X*D          Y    )
C     (  0  inv(D)*B*D  inv(D)*Z ).
C     (  0      0           T2   )
C
C  Information about the permutations P and the diagonal matrix D is
C  returned in the vector SCALE.
C
C  This subroutine is based on the EISPACK routine BALANC.
C
C  Modified by Tzu-Yi Chen, Computer Science Division, University of
C    California at Berkeley, USA
C
C  =====================================================================
C
C     .. Parameters ..
C     ..
C     .. Local Scalars ..
C     ..
C     .. External Functions ..
C     ..
C     .. External Subroutines ..
C     ..
C     .. Intrinsic Functions ..
C     ..
C     .. Executable Statements ..
C
C     Test the input parameters
C
      info = 0
      result1 = LSAME(job, 'N')
      result2 = LSAME(job, 'P')
      result3 = LSAME(job, 'S')
      result4 = LSAME(job, 'B')
      IF (.NOT.result1 .AND. (.NOT.result2) .AND. (.NOT.result3) .AND. (
     +    .NOT.result4)) THEN
        info = -1
      ELSE IF (n .LT. 0) THEN
        info = -2
      ELSE
        IF (1 .LT. n) THEN
          max1 = n
        ELSE
          max1 = 1
        END IF
        IF (lda .LT. max1) info = -4
      END IF
      IF (info .NE. 0) THEN
        arg1 = -info
        CALL XERBLA('DGEBAL', arg1)
        DO ii1=1,n
          DO nd=1,nbdirs
            scaled(nd, ii1) = 0.D0
          ENDDO
        ENDDO
        DO ii1=1,n
          DO ii2=1,lda
            DO nd=1,nbdirs
              ad(nd, ii2, ii1) = 0.D0
            ENDDO
          ENDDO
        ENDDO
        RETURN
      ELSE
C
        k = 1
        l = n
C
        IF (.NOT.n .EQ. 0) THEN
C
          result1 = LSAME(job, 'N')
          IF (result1) THEN
            DO i=1,n
              DO nd=1,nbdirs
                scaled(nd, i) = 0.D0
              ENDDO
              scale(i) = one
            ENDDO
          ELSE
C
            result1 = LSAME(job, 'S')
            IF (.NOT.result1) THEN
 50           CONTINUE
C
              DO j=l,1,-1
C
                DO i=1,l
                  IF (.NOT.i .EQ. j) THEN
                    IF (a(j, i) .NE. zero) GOTO 70
                  END IF
                ENDDO
                GOTO 130
 70             CONTINUE
              ENDDO
              GOTO 90
C
 130          m = l
              iexc = 1
 20           DO nd=1,nbdirs
                scaled(nd, m) = 0.D0
              ENDDO
              scale(m) = j
C
C     Permutation to isolate eigenvalues if possible
C
C
C     Row and column exchange.
C
              IF (.NOT.j .EQ. m) THEN
C
                CALL DSWAP_DV(l, a(1, j), ad(1, 1, j), 1, a(1, m), ad(1
     +                        , 1, m), 1, nbdirs)
                arg1 = n - k + 1
                CALL DSWAP_DV(arg1, a(j, k), ad(1, j, k), lda, a(m, k),
     +                        ad(1, m, k), lda, nbdirs)
              END IF
C
              GOTO (40, 80) iexc
              GOTO 40
C
C
C     Search for columns isolating an eigenvalue and push them left.
C
 80           k = k + 1
 90           CONTINUE
C
              DO j=k,l
C
                DO i=k,l
                  IF (.NOT.i .EQ. j) THEN
                    IF (a(i, j) .NE. zero) GOTO 110
                  END IF
                ENDDO
                GOTO 220
 110            CONTINUE
              ENDDO
              GOTO 120
C
 220          m = k
              iexc = 2
              GOTO 20
C
C     Search for rows isolating an eigenvalue and push them down.
C
 40           IF (l .EQ. 1) THEN
                GOTO 210
              ELSE
                l = l - 1
                GOTO 50
              END IF
            END IF
 120        CONTINUE
C
            DO i=k,l
              DO nd=1,nbdirs
                scaled(nd, i) = 0.D0
              ENDDO
              scale(i) = one
            ENDDO
C
            result1 = LSAME(job, 'P')
            IF (.NOT.result1) THEN
C
C     Balance the submatrix in rows K to L.
C
C     Iterative loop for norm reduction
C
              result10 = DLAMCH('S')
              result20 = DLAMCH('P')
              sfmin1 = result10/result20
              sfmax1 = one/sfmin1
              sfmin2 = sfmin1*sclfac
              sfmax2 = one/sfmin2
 140          noconv = .false.
C
              DO i=k,l
                c = zero
                r = zero
C
                DO j=k,l
                  IF (.NOT.j .EQ. i) THEN
                    IF (a(j, i) .GE. 0.) THEN
                      abs1 = a(j, i)
                    ELSE
                      abs1 = -a(j, i)
                    END IF
                    c = c + abs1
                    IF (a(i, j) .GE. 0.) THEN
                      abs2 = a(i, j)
                    ELSE
                      abs2 = -a(i, j)
                    END IF
                    r = r + abs2
                  END IF
                ENDDO
                ica = IDAMAX(l, a(1, i), 1)
                IF (a(ica, i) .GE. 0.) THEN
                  ca = a(ica, i)
                ELSE
                  ca = -a(ica, i)
                END IF
                arg1 = n - k + 1
                ira = IDAMAX(arg1, a(i, k), lda)
                IF (a(i, ira+k-1) .GE. 0.) THEN
                  ra = a(i, ira+k-1)
                ELSE
                  ra = -a(i, ira+k-1)
                END IF
C
C        Guard against zero C or R due to underflow.
C
                IF (.NOT.(c .EQ. zero .OR. r .EQ. zero)) THEN
                  g = r/sclfac
                  f = one
                  s = c + r
 230              IF (f .LT. c) THEN
                    IF (c .LT. ca) THEN
                      max2 = ca
                    ELSE
                      max2 = c
                    END IF
                  ELSE IF (f .LT. ca) THEN
                    max2 = ca
                  ELSE
                    max2 = f
                  END IF
                  IF (r .GT. g) THEN
                    IF (g .GT. ra) THEN
                      min1 = ra
                    ELSE
                      min1 = g
                    END IF
                  ELSE IF (r .GT. ra) THEN
                    min1 = ra
                  ELSE
                    min1 = r
                  END IF
                  IF (.NOT.(c .GE. g .OR. max2 .GE. sfmax2 .OR. min1
     +                .LE. sfmin2)) THEN
                    f = f*sclfac
                    c = c*sclfac
                    ca = ca*sclfac
                    r = r/sclfac
                    g = g/sclfac
                    ra = ra/sclfac
                    GOTO 230
                  END IF
C
                  g = c/sclfac
 240              IF (r .LT. ra) THEN
                    max3 = ra
                  ELSE
                    max3 = r
                  END IF
                  IF (.NOT.(g .LT. r .OR. max3 .GE. sfmax2 .OR. MIN(f, c
     +                , g, ca) .LE. sfmin2)) THEN
                    f = f/sclfac
                    c = c/sclfac
                    g = g/sclfac
                    ca = ca/sclfac
                    r = r*sclfac
                    ra = ra*sclfac
                    GOTO 240
                  END IF
C
C        Now balance.
C
                  IF (.NOT.c + r .GE. factor*s) THEN
                    IF (f .LT. one .AND. scale(i) .LT. one) THEN
                      IF (f*scale(i) .LE. sfmin1) GOTO 200
                    END IF
                    IF (f .GT. one .AND. scale(i) .GT. one) THEN
                      IF (scale(i) .GE. sfmax1/f) GOTO 200
                    END IF
                    g = one/f
                    DO nd=1,nbdirs
                      scaled(nd, i) = f*scaled(nd, i)
                      fd(nd) = 0.D0
                      gd(nd) = 0.D0
                    ENDDO
                    scale(i) = scale(i)*f
                    noconv = .true.
C
                    arg1 = n - k + 1
                    CALL DSCAL_DV(arg1, g, gd, a(i, k), ad(1, i, k), lda
     +                            , nbdirs)
                    CALL DSCAL_DV(l, f, fd, a(1, i), ad(1, 1, i), 1,
     +                            nbdirs)
                  END IF
                END IF
 200            CONTINUE
              ENDDO
C
C
              IF (noconv) GOTO 140
            END IF
          END IF
        END IF
C
 210    ilo = k
        ihi = l
C
        RETURN
      END IF
      END

!
! Copyright (C) 2006-2014 Houtan Bastani and Luca Guerrieri
!
!
! This free software: you can redistribute it and/or modify
! it under the terms of the GNU General Public License as published by
! the Free Software Foundation, either version 3 of the License, or
! (at your option) any later version.
!
! It is distributed in the hope that it will be useful,
! but WITHOUT ANY WARRANTY; without even the implied warranty of
! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
! GNU General Public License for more details.
!
! You should have received a copy of the GNU General Public License
! along with Dynare.  If not, see <http://www.gnu.org/licenses/>.
!

C        Generated by TAPENADE     (INRIA, Tropics team)
C  Tapenade - Version 2.2 (r1239) - Wed 28 Jun 2006 04:59:55 PM CEST
C
C  Differentiation of dlarf in forward (tangent) mode: (multi-directional mode)
C   variations  of output variables: work c
C   with respect to input variables: tau v work c
      SUBROUTINE DLARF_DV(side, m, n, v, vd, incv, tau, taud, c, cd, ldc
     +                    , work, workd, nbdirs)
      USE DIFFSIZES
      IMPLICIT NONE
C
C     End of DLARF
C
      INTEGER incv, m, n
      INTEGER ldc, nbdirs
      DOUBLE PRECISION c(ldc, *), cd(nbdirsmax, ldc, *), v(*), vd(
     +                 nbdirsmax, *), work(*), workd(nbdirsmax, *)
      CHARACTER side
      DOUBLE PRECISION tau, taud(nbdirsmax)
      DOUBLE PRECISION one, zero
      PARAMETER (one=1.0d+0, zero=0.0d+0)
      DOUBLE PRECISION arg1, arg1d(nbdirsmax)
      DOUBLE PRECISION initvald(nbdirsmax), initvald0(nbdirsmax)
      INTEGER nd
      LOGICAL LSAME, result1
      EXTERNAL LSAME
C
C  -- LAPACK auxiliary routine (version 3.1) --
C     Univ. of Tennessee, Univ. of California Berkeley and NAG Ltd..
C     November 2006
C
C     .. Scalar Arguments ..
C     ..
C     .. Array Arguments ..
C     ..
C
C  Purpose
C  =======
C
C  DLARF applies a real elementary reflector H to a real m by n matrix
C  C, from either the left or the right. H is represented in the form
C
C        H = I - tau * v * v'
C
C  where tau is a real scalar and v is a real vector.
C
C  If tau = 0, then H is taken to be the unit matrix.
C
C  Arguments
C  =========
C
C  SIDE    (input) CHARACTER*1
C          = 'L': form  H * C
C          = 'R': form  C * H
C
C  M       (input) INTEGER
C          The number of rows of the matrix C.
C
C  N       (input) INTEGER
C          The number of columns of the matrix C.
C
C  V       (input) DOUBLE PRECISION array, dimension
C                     (1 + (M-1)*abs(INCV)) if SIDE = 'L'
C                  or (1 + (N-1)*abs(INCV)) if SIDE = 'R'
C          The vector v in the representation of H. V is not used if
C          TAU = 0.
C
C  INCV    (input) INTEGER
C          The increment between elements of v. INCV <> 0.
C
C  TAU     (input) DOUBLE PRECISION
C          The value tau in the representation of H.
C
C  C       (input/output) DOUBLE PRECISION array, dimension (LDC,N)
C          On entry, the m by n matrix C.
C          On exit, C is overwritten by the matrix H * C if SIDE = 'L',
C          or C * H if SIDE = 'R'.
C
C  LDC     (input) INTEGER
C          The leading dimension of the array C. LDC >= max(1,M).
C
C  WORK    (workspace) DOUBLE PRECISION array, dimension
C                         (N) if SIDE = 'L'
C                      or (M) if SIDE = 'R'
C
C  =====================================================================
C
C     .. Parameters ..
C     ..
C     .. External Subroutines ..
C     ..
C     .. External Functions ..
C     ..
C     .. Executable Statements ..
C
      result1 = LSAME(side, 'L')
      IF (result1) THEN
C
C        Form  H * C
C
        IF (tau .NE. zero) THEN
          DO nd=1,nbdirs
            initvald(nd) = 0.D0
            arg1d(nd) = -taud(nd)
          ENDDO
C
C           w := C' * v
C
          CALL DGEMV_DV('Transpose', m, n, one, initvald, c, cd, ldc, v
     +                  , vd, incv, zero, work, workd, 1, nbdirs)
C
C           C := C - v * w'
C
          arg1 = -tau
          CALL DGER_DV(m, n, arg1, arg1d, v, vd, incv, work, workd, 1, c
     +                 , cd, ldc, nbdirs)
        END IF
      ELSE IF (tau .NE. zero) THEN
C
C        Form  C * H
C
        DO nd=1,nbdirs
          initvald0(nd) = 0.D0
          arg1d(nd) = -taud(nd)
        ENDDO
C
C           w := C * v
C
        CALL DGEMV_DV('No transpose', m, n, one, initvald0, c, cd, ldc,
     +                v, vd, incv, zero, work, workd, 1, nbdirs)
C
C           C := C - w * v'
C
        arg1 = -tau
        CALL DGER_DV(m, n, arg1, arg1d, work, workd, 1, v, vd, incv, c,
     +               cd, ldc, nbdirs)
      END IF
      RETURN
      END

!
! Copyright (C) 2006-2014 Houtan Bastani and Luca Guerrieri
!
!
! This free software: you can redistribute it and/or modify
! it under the terms of the GNU General Public License as published by
! the Free Software Foundation, either version 3 of the License, or
! (at your option) any later version.
!
! It is distributed in the hope that it will be useful,
! but WITHOUT ANY WARRANTY; without even the implied warranty of
! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
! GNU General Public License for more details.
!
! You should have received a copy of the GNU General Public License
! along with Dynare.  If not, see <http://www.gnu.org/licenses/>.
!

C        Generated by TAPENADE     (INRIA, Tropics team)
C  Tapenade - Version 2.2 (r1239) - Wed 28 Jun 2006 04:59:55 PM CEST
C
C  Differentiation of dgetrf in forward (tangent) mode: (multi-directional mode)
C   variations  of output variables: a
C   with respect to input variables: a
      SUBROUTINE DGETRF_DV(m, n, a, ad, lda, ipiv, info, nbdirs)
      USE DIFFSIZES
      IMPLICIT NONE
C
C     End of DGETRF
C
      INTEGER info, ipiv(*), m, n
      INTEGER lda, nbdirs
      DOUBLE PRECISION a(lda, *), ad(nbdirsmax, lda, *)
      DOUBLE PRECISION one
      PARAMETER (one=1.0d+0)
      DOUBLE PRECISION arg3
      INTEGER arg1, arg2, i, iinfo, ILAENV, j, jb, max1, min1, min2,
     +        min3, min4, nb, x1
      EXTERNAL ILAENV, XERBLA
      INTRINSIC MAX, MIN
C
C  -- LAPACK routine (version 3.1) --
C     Univ. of Tennessee, Univ. of California Berkeley and NAG Ltd..
C     November 2006
C
C     .. Scalar Arguments ..
C     ..
C     .. Array Arguments ..
C     ..
C
C  Purpose
C  =======
C
C  DGETRF computes an LU factorization of a general M-by-N matrix A
C  using partial pivoting with row interchanges.
C
C  The factorization has the form
C     A = P * L * U
C  where P is a permutation matrix, L is lower triangular with unit
C  diagonal elements (lower trapezoidal if m > n), and U is upper
C  triangular (upper trapezoidal if m < n).
C
C  This is the right-looking Level 3 BLAS version of the algorithm.
C
C  Arguments
C  =========
C
C  M       (input) INTEGER
C          The number of rows of the matrix A.  M >= 0.
C
C  N       (input) INTEGER
C          The number of columns of the matrix A.  N >= 0.
C
C  A       (input/output) DOUBLE PRECISION array, dimension (LDA,N)
C          On entry, the M-by-N matrix to be factored.
C          On exit, the factors L and U from the factorization
C          A = P*L*U; the unit diagonal elements of L are not stored.
C
C  LDA     (input) INTEGER
C          The leading dimension of the array A.  LDA >= max(1,M).
C
C  IPIV    (output) INTEGER array, dimension (min(M,N))
C          The pivot indices; for 1 <= i <= min(M,N), row i of the
C          matrix was interchanged with row IPIV(i).
C
C  INFO    (output) INTEGER
C          = 0:  successful exit
C          < 0:  if INFO = -i, the i-th argument had an illegal value
C          > 0:  if INFO = i, U(i,i) is exactly zero. The factorization
C                has been completed, but the factor U is exactly
C                singular, and division by zero will occur if it is used
C                to solve a system of equations.
C
C  =====================================================================
C
C     .. Parameters ..
C     ..
C     .. Local Scalars ..
C     ..
C     .. External Subroutines ..
C     ..
C     .. External Functions ..
C     ..
C     .. Intrinsic Functions ..
C     ..
C     .. Executable Statements ..
C
C     Test the input parameters.
C
      info = 0
      IF (m .LT. 0) THEN
        info = -1
      ELSE IF (n .LT. 0) THEN
        info = -2
      ELSE
        IF (1 .LT. m) THEN
          max1 = m
        ELSE
          max1 = 1
        END IF
        IF (lda .LT. max1) info = -4
      END IF
      IF (info .NE. 0) THEN
        arg1 = -info
        CALL XERBLA('DGETRF', arg1)
        RETURN
      ELSE IF (m .EQ. 0 .OR. n .EQ. 0) THEN
C
C     Quick return if possible
C
        RETURN
      ELSE
C
C     Determine the block size for this environment.
C
        arg1 = -1
        arg2 = -1
        nb = ILAENV(1, 'DGETRF', ' ', m, n, arg1, arg2)
        IF (m .GT. n) THEN
          min1 = n
        ELSE
          min1 = m
        END IF
        IF (nb .LE. 1 .OR. nb .GE. min1) THEN
C
C        Use unblocked code.
C
          CALL DGETF2_DV(m, n, a, ad, lda, ipiv, info, nbdirs)
        ELSE
          IF (m .GT. n) THEN
            min2 = n
          ELSE
            min2 = m
          END IF
C
C        Use blocked code.
C
          DO j=1,min2,nb
            IF (m .GT. n) THEN
              min4 = n
            ELSE
              min4 = m
            END IF
            x1 = min4 - j + 1
            IF (x1 .GT. nb) THEN
              jb = nb
            ELSE
              jb = x1
            END IF
C
C           Factor diagonal and subdiagonal blocks and test for exact
C           singularity.
C
            arg1 = m - j + 1
            CALL DGETF2_DV(arg1, jb, a(j, j), ad(1, j, j), lda, ipiv(j)
     +                     , iinfo, nbdirs)
C
C           Adjust INFO and the pivot indices.
C
            IF (info .EQ. 0 .AND. iinfo .GT. 0) info = iinfo + j - 1
            IF (m .GT. j + jb - 1) THEN
              min3 = j + jb - 1
            ELSE
              min3 = m
            END IF
            DO i=j,min3
              ipiv(i) = j - 1 + ipiv(i)
            ENDDO
C
C           Apply interchanges to columns 1:J-1.
C
            arg1 = j - 1
            arg2 = j + jb - 1
            CALL DLASWP_DV(arg1, a, ad, lda, j, arg2, ipiv, 1, nbdirs)
C
            IF (j + jb .LE. n) THEN
C
C              Apply interchanges to columns J+JB:N.
C
              arg1 = n - j - jb + 1
              arg2 = j + jb - 1
              CALL DLASWP_DV(arg1, a(1, j+jb), ad(1, 1, j+jb), lda, j,
     +                       arg2, ipiv, 1, nbdirs)
C
C              Compute block row of U.
C
              arg1 = n - j - jb + 1
              CALL DTRSM_DV('Left', 'Lower', 'No transpose', 'Unit', jb
     +                      , arg1, one, a(j, j), ad(1, j, j), lda, a(j
     +                      , j+jb), ad(1, j, j+jb), lda, nbdirs)
              IF (j + jb .LE. m) THEN
C
C                 Update trailing submatrix.
C
                arg1 = m - j - jb + 1
                arg2 = n - j - jb + 1
                arg3 = -one
                CALL DGEMM_DV('No transpose', 'No transpose', arg1, arg2
     +                        , jb, arg3, a(j+jb, j), ad(1, j+jb, j),
     +                        lda, a(j, j+jb), ad(1, j, j+jb), lda, one
     +                        , a(j+jb, j+jb), ad(1, j+jb, j+jb), lda,
     +                        nbdirs)
              END IF
            END IF
          ENDDO
        END IF
        RETURN
      END IF
      END

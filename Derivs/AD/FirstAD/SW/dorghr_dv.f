!
! Copyright (C) 2006-2014 Houtan Bastani and Luca Guerrieri
!
!
! This free software: you can redistribute it and/or modify
! it under the terms of the GNU General Public License as published by
! the Free Software Foundation, either version 3 of the License, or
! (at your option) any later version.
!
! It is distributed in the hope that it will be useful,
! but WITHOUT ANY WARRANTY; without even the implied warranty of
! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
! GNU General Public License for more details.
!
! You should have received a copy of the GNU General Public License
! along with Dynare.  If not, see <http://www.gnu.org/licenses/>.
!

C        Generated by TAPENADE     (INRIA, Tropics team)
C  Tapenade - Version 2.2 (r1239) - Wed 28 Jun 2006 04:59:55 PM CEST
C
C  Differentiation of dorghr in forward (tangent) mode: (multi-directional mode)
C   variations  of output variables: work a
C   with respect to input variables: tau work a
      SUBROUTINE DORGHR_DV(n, ilo, ihi, a, ad, lda, tau, taud, work,
     +                     workd, lwork, info, nbdirs)
      USE DIFFSIZES
      IMPLICIT NONE
C
C     End of DORGHR
C
      INTEGER ihi, ilo, info, lwork, n
      INTEGER lda, nbdirs
      DOUBLE PRECISION a(lda, *), ad(nbdirsmax, lda, *), tau(*), taud(
     +                 nbdirsmax, *), work(*), workd(nbdirsmax, *)
      DOUBLE PRECISION one, zero
      PARAMETER (one=1.0d+0, zero=0.0d+0)
      LOGICAL lquery
      INTEGER arg1, i, iinfo, ILAENV, j, lwkopt, max1, max2, max3, max4
     +        , min1, nb, nd, nh
      EXTERNAL ILAENV, XERBLA
      INTRINSIC MAX, MIN
C
C  -- LAPACK routine (version 3.1) --
C     Univ. of Tennessee, Univ. of California Berkeley and NAG Ltd..
C     November 2006
C
C     .. Scalar Arguments ..
C     ..
C     .. Array Arguments ..
C     ..
C
C  Purpose
C  =======
C
C  DORGHR generates a real orthogonal matrix Q which is defined as the
C  product of IHI-ILO elementary reflectors of order N, as returned by
C  DGEHRD:
C
C  Q = H(ilo) H(ilo+1) . . . H(ihi-1).
C
C  Arguments
C  =========
C
C  N       (input) INTEGER
C          The order of the matrix Q. N >= 0.
C
C  ILO     (input) INTEGER
C  IHI     (input) INTEGER
C          ILO and IHI must have the same values as in the previous call
C          of DGEHRD. Q is equal to the unit matrix except in the
C          submatrix Q(ilo+1:ihi,ilo+1:ihi).
C          1 <= ILO <= IHI <= N, if N > 0; ILO=1 and IHI=0, if N=0.
C
C  A       (input/output) DOUBLE PRECISION array, dimension (LDA,N)
C          On entry, the vectors which define the elementary reflectors,
C          as returned by DGEHRD.
C          On exit, the N-by-N orthogonal matrix Q.
C
C  LDA     (input) INTEGER
C          The leading dimension of the array A. LDA >= max(1,N).
C
C  TAU     (input) DOUBLE PRECISION array, dimension (N-1)
C          TAU(i) must contain the scalar factor of the elementary
C          reflector H(i), as returned by DGEHRD.
C
C  WORK    (workspace/output) DOUBLE PRECISION array, dimension (MAX(1,LWORK))
C          On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
C
C  LWORK   (input) INTEGER
C          The dimension of the array WORK. LWORK >= IHI-ILO.
C          For optimum performance LWORK >= (IHI-ILO)*NB, where NB is
C          the optimal blocksize.
C
C          If LWORK = -1, then a workspace query is assumed; the routine
C          only calculates the optimal size of the WORK array, returns
C          this value as the first entry of the WORK array, and no error
C          message related to LWORK is issued by XERBLA.
C
C  INFO    (output) INTEGER
C          = 0:  successful exit
C          < 0:  if INFO = -i, the i-th argument had an illegal value
C
C  =====================================================================
C
C     .. Parameters ..
C     ..
C     .. Local Scalars ..
C     ..
C     .. External Subroutines ..
C     ..
C     .. External Functions ..
C     ..
C     .. Intrinsic Functions ..
C     ..
C     .. Executable Statements ..
C
C     Test the input arguments
C
      info = 0
      nh = ihi - ilo
      lquery = lwork .EQ. -1
      IF (n .LT. 0) THEN
        info = -1
      ELSE
        IF (1 .LT. n) THEN
          max1 = n
        ELSE
          max1 = 1
        END IF
        IF (ilo .LT. 1 .OR. ilo .GT. max1) THEN
          info = -2
        ELSE
          IF (ilo .GT. n) THEN
            min1 = n
          ELSE
            min1 = ilo
          END IF
          IF (ihi .LT. min1 .OR. ihi .GT. n) THEN
            info = -3
          ELSE
            IF (1 .LT. n) THEN
              max2 = n
            ELSE
              max2 = 1
            END IF
            IF (lda .LT. max2) THEN
              info = -5
            ELSE
              IF (1 .LT. nh) THEN
                max3 = nh
              ELSE
                max3 = 1
              END IF
              IF (lwork .LT. max3 .AND. (.NOT.lquery)) info = -8
            END IF
          END IF
        END IF
      END IF
C
      IF (info .EQ. 0) THEN
        arg1 = -1
        nb = ILAENV(1, 'DORGQR', ' ', nh, nh, nh, arg1)
        IF (1 .LT. nh) THEN
          max4 = nh
        ELSE
          max4 = 1
        END IF
        lwkopt = max4*nb
        DO nd=1,nbdirs
          workd(nd, 1) = 0.D0
        ENDDO
        work(1) = lwkopt
      END IF
C
      IF (info .NE. 0) THEN
        arg1 = -info
        CALL XERBLA('DORGHR', arg1)
        RETURN
      ELSE IF (lquery) THEN
        RETURN
      ELSE IF (n .EQ. 0) THEN
C
C     Quick return if possible
C
        DO nd=1,nbdirs
          workd(nd, 1) = 0.D0
        ENDDO
        work(1) = 1
        RETURN
      ELSE
C
C     Shift the vectors which define the elementary reflectors one
C     column to the right, and set the first ilo and the last n-ihi
C     rows and columns to those of the unit matrix
C
        DO j=ihi,ilo+1,-1
          DO i=1,j-1
            DO nd=1,nbdirs
              ad(nd, i, j) = 0.D0
            ENDDO
            a(i, j) = zero
          ENDDO
          DO i=j+1,ihi
            DO nd=1,nbdirs
              ad(nd, i, j) = ad(nd, i, j-1)
            ENDDO
            a(i, j) = a(i, j-1)
          ENDDO
          DO i=ihi+1,n
            DO nd=1,nbdirs
              ad(nd, i, j) = 0.D0
            ENDDO
            a(i, j) = zero
          ENDDO
        ENDDO
        DO j=1,ilo
          DO i=1,n
            DO nd=1,nbdirs
              ad(nd, i, j) = 0.D0
            ENDDO
            a(i, j) = zero
          ENDDO
          DO nd=1,nbdirs
            ad(nd, j, j) = 0.D0
          ENDDO
          a(j, j) = one
        ENDDO
        DO j=ihi+1,n
          DO i=1,n
            DO nd=1,nbdirs
              ad(nd, i, j) = 0.D0
            ENDDO
            a(i, j) = zero
          ENDDO
          DO nd=1,nbdirs
            ad(nd, j, j) = 0.D0
          ENDDO
          a(j, j) = one
        ENDDO
C
        IF (nh .GT. 0) CALL DORGQR_DV(nh, nh, nh, a(ilo+1, ilo+1), ad(1
     +                                , ilo+1, ilo+1), lda, tau(ilo),
     +                                taud(1, ilo), work, workd, lwork,
     +                                iinfo, nbdirs)
C
C        Generate Q(ilo+1:ihi,ilo+1:ihi)
C
        DO nd=1,nbdirs
          workd(nd, 1) = 0.D0
        ENDDO
        work(1) = lwkopt
        RETURN
      END IF
      END

!
! Copyright (C) 2006-2014 Houtan Bastani and Luca Guerrieri
!
!
! This free software: you can redistribute it and/or modify
! it under the terms of the GNU General Public License as published by
! the Free Software Foundation, either version 3 of the License, or
! (at your option) any later version.
!
! It is distributed in the hope that it will be useful,
! but WITHOUT ANY WARRANTY; without even the implied warranty of
! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
! GNU General Public License for more details.
!
! You should have received a copy of the GNU General Public License
! along with Dynare.  If not, see <http://www.gnu.org/licenses/>.
!

C        Generated by TAPENADE     (INRIA, Tropics team)
C  Tapenade - Version 2.2 (r1239) - Wed 28 Jun 2006 04:59:55 PM CEST
C
C  Differentiation of dlassq in forward (tangent) mode: (multi-directional mode)
C   variations  of output variables: sumsq scale
C   with respect to input variables: x sumsq scale
      SUBROUTINE DLASSQ_DV(n, x, xd, incx, scale, scaled, sumsq, sumsqd
     +                     , nbdirs)
      USE DIFFSIZES
      IMPLICIT NONE
C
C     End of DLASSQ
C
      INTEGER incx, n
      INTEGER nbdirs
      DOUBLE PRECISION scale, scaled(nbdirsmax), sumsq, sumsqd(nbdirsmax
     +                 )
      DOUBLE PRECISION x(*), xd(nbdirsmax, *)
      DOUBLE PRECISION zero
      PARAMETER (zero=0.0d+0)
      DOUBLE PRECISION absxi, absxid(nbdirsmax)
      INTEGER ix, nd
      INTRINSIC ABS
C
C  -- LAPACK auxiliary routine (version 3.1) --
C     Univ. of Tennessee, Univ. of California Berkeley and NAG Ltd..
C     November 2006
C
C     .. Scalar Arguments ..
C     ..
C     .. Array Arguments ..
C     ..
C
C  Purpose
C  =======
C
C  DLASSQ  returns the values  scl  and  smsq  such that
C
C     ( scl**2 )*smsq = x( 1 )**2 +...+ x( n )**2 + ( scale**2 )*sumsq,
C
C  where  x( i ) = X( 1 + ( i - 1 )*INCX ). The value of  sumsq  is
C  assumed to be non-negative and  scl  returns the value
C
C     scl = max( scale, abs( x( i ) ) ).
C
C  scale and sumsq must be supplied in SCALE and SUMSQ and
C  scl and smsq are overwritten on SCALE and SUMSQ respectively.
C
C  The routine makes only one pass through the vector x.
C
C  Arguments
C  =========
C
C  N       (input) INTEGER
C          The number of elements to be used from the vector X.
C
C  X       (input) DOUBLE PRECISION array, dimension (N)
C          The vector for which a scaled sum of squares is computed.
C             x( i )  = X( 1 + ( i - 1 )*INCX ), 1 <= i <= n.
C
C  INCX    (input) INTEGER
C          The increment between successive values of the vector X.
C          INCX > 0.
C
C  SCALE   (input/output) DOUBLE PRECISION
C          On entry, the value  scale  in the equation above.
C          On exit, SCALE is overwritten with  scl , the scaling factor
C          for the sum of squares.
C
C  SUMSQ   (input/output) DOUBLE PRECISION
C          On entry, the value  sumsq  in the equation above.
C          On exit, SUMSQ is overwritten with  smsq , the basic sum of
C          squares from which  scl  has been factored out.
C
C =====================================================================
C
C     .. Parameters ..
C     ..
C     .. Local Scalars ..
C     ..
C     .. Intrinsic Functions ..
C     ..
C     .. Executable Statements ..
C
      IF (n .GT. 0) THEN
        DO ix=1,1+(n-1)*incx,incx
          IF (x(ix) .NE. zero) THEN
            IF (x(ix) .GE. 0.) THEN
              DO nd=1,nbdirs
                absxid(nd) = xd(nd, ix)
              ENDDO
              absxi = x(ix)
            ELSE
              DO nd=1,nbdirs
                absxid(nd) = -xd(nd, ix)
              ENDDO
              absxi = -x(ix)
            END IF
            IF (scale .LT. absxi) THEN
              DO nd=1,nbdirs
                sumsqd(nd) = sumsqd(nd)*scale**2/absxi**2 + sumsq*2*
     +            scale*(scaled(nd)*absxi-scale*absxid(nd))/absxi**3
                scaled(nd) = absxid(nd)
              ENDDO
              sumsq = 1 + sumsq*(scale/absxi)**2
              scale = absxi
            ELSE
              DO nd=1,nbdirs
                sumsqd(nd) = sumsqd(nd) + 2*absxi*(absxid(nd)*scale-
     +            absxi*scaled(nd))/scale**3
              ENDDO
              sumsq = sumsq + (absxi/scale)**2
            END IF
          END IF
        ENDDO
      END IF
      RETURN
      END

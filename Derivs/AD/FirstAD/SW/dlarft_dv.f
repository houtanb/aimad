!
! Copyright (C) 2006-2014 Houtan Bastani and Luca Guerrieri
!
!
! This free software: you can redistribute it and/or modify
! it under the terms of the GNU General Public License as published by
! the Free Software Foundation, either version 3 of the License, or
! (at your option) any later version.
!
! It is distributed in the hope that it will be useful,
! but WITHOUT ANY WARRANTY; without even the implied warranty of
! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
! GNU General Public License for more details.
!
! You should have received a copy of the GNU General Public License
! along with Dynare.  If not, see <http://www.gnu.org/licenses/>.
!

C        Generated by TAPENADE     (INRIA, Tropics team)
C  Tapenade - Version 2.2 (r1239) - Wed 28 Jun 2006 04:59:55 PM CEST
C
C  Differentiation of dlarft in forward (tangent) mode: (multi-directional mode)
C   variations  of output variables: t v
C   with respect to input variables: tau t v
      SUBROUTINE DLARFT_DV(direct, storev, n, k, v, vd, ldv, tau, taud,
     +                     t, td, ldt, nbdirs)
      USE DIFFSIZES
      IMPLICIT NONE
C
C     End of DLARFT
C
      CHARACTER direct, storev
      INTEGER k, n
      INTEGER ldt, ldv, nbdirs
      DOUBLE PRECISION t(ldt, *), tau(*), taud(nbdirsmax, *), td(
     +                 nbdirsmax, ldt, *), v(ldv, *), vd(nbdirsmax, ldv
     +                 , *)
      DOUBLE PRECISION one, zero
      PARAMETER (one=1.0d+0, zero=0.0d+0)
      INTEGER arg1, arg2, i, j, nd
      DOUBLE PRECISION arg3, arg3d(nbdirsmax)
      LOGICAL LSAME, result1
      DOUBLE PRECISION vii, viid(nbdirsmax)
      EXTERNAL LSAME
C
C  -- LAPACK auxiliary routine (version 3.1) --
C     Univ. of Tennessee, Univ. of California Berkeley and NAG Ltd..
C     November 2006
C
C     .. Scalar Arguments ..
C     ..
C     .. Array Arguments ..
C     ..
C
C  Purpose
C  =======
C
C  DLARFT forms the triangular factor T of a real block reflector H
C  of order n, which is defined as a product of k elementary reflectors.
C
C  If DIRECT = 'F', H = H(1) H(2) . . . H(k) and T is upper triangular;
C
C  If DIRECT = 'B', H = H(k) . . . H(2) H(1) and T is lower triangular.
C
C  If STOREV = 'C', the vector which defines the elementary reflector
C  H(i) is stored in the i-th column of the array V, and
C
C     H  =  I - V * T * V'
C
C  If STOREV = 'R', the vector which defines the elementary reflector
C  H(i) is stored in the i-th row of the array V, and
C
C     H  =  I - V' * T * V
C
C  Arguments
C  =========
C
C  DIRECT  (input) CHARACTER*1
C          Specifies the order in which the elementary reflectors are
C          multiplied to form the block reflector:
C          = 'F': H = H(1) H(2) . . . H(k) (Forward)
C          = 'B': H = H(k) . . . H(2) H(1) (Backward)
C
C  STOREV  (input) CHARACTER*1
C          Specifies how the vectors which define the elementary
C          reflectors are stored (see also Further Details):
C          = 'C': columnwise
C          = 'R': rowwise
C
C  N       (input) INTEGER
C          The order of the block reflector H. N >= 0.
C
C  K       (input) INTEGER
C          The order of the triangular factor T (= the number of
C          elementary reflectors). K >= 1.
C
C  V       (input/output) DOUBLE PRECISION array, dimension
C                               (LDV,K) if STOREV = 'C'
C                               (LDV,N) if STOREV = 'R'
C          The matrix V. See further details.
C
C  LDV     (input) INTEGER
C          The leading dimension of the array V.
C          If STOREV = 'C', LDV >= max(1,N); if STOREV = 'R', LDV >= K.
C
C  TAU     (input) DOUBLE PRECISION array, dimension (K)
C          TAU(i) must contain the scalar factor of the elementary
C          reflector H(i).
C
C  T       (output) DOUBLE PRECISION array, dimension (LDT,K)
C          The k by k triangular factor T of the block reflector.
C          If DIRECT = 'F', T is upper triangular; if DIRECT = 'B', T is
C          lower triangular. The rest of the array is not used.
C
C  LDT     (input) INTEGER
C          The leading dimension of the array T. LDT >= K.
C
C  Further Details
C  ===============
C
C  The shape of the matrix V and the storage of the vectors which define
C  the H(i) is best illustrated by the following example with n = 5 and
C  k = 3. The elements equal to 1 are not stored; the corresponding
C  array elements are modified but restored on exit. The rest of the
C  array is not used.
C
C  DIRECT = 'F' and STOREV = 'C':         DIRECT = 'F' and STOREV = 'R':
C
C               V = (  1       )                 V = (  1 v1 v1 v1 v1 )
C                   ( v1  1    )                     (     1 v2 v2 v2 )
C                   ( v1 v2  1 )                     (        1 v3 v3 )
C                   ( v1 v2 v3 )
C                   ( v1 v2 v3 )
C
C  DIRECT = 'B' and STOREV = 'C':         DIRECT = 'B' and STOREV = 'R':
C
C               V = ( v1 v2 v3 )                 V = ( v1 v1  1       )
C                   ( v1 v2 v3 )                     ( v2 v2 v2  1    )
C                   (  1 v2 v3 )                     ( v3 v3 v3 v3  1 )
C                   (     1 v3 )
C                   (        1 )
C
C  =====================================================================
C
C     .. Parameters ..
C     ..
C     .. Local Scalars ..
C     ..
C     .. External Subroutines ..
C     ..
C     .. External Functions ..
C     ..
C     .. Executable Statements ..
C
C     Quick return if possible
C
      IF (n .EQ. 0) THEN
        RETURN
      ELSE
C
        result1 = LSAME(direct, 'F')
        IF (result1) THEN
          DO i=1,k
            IF (tau(i) .EQ. zero) THEN
C
C              H(i)  =  I
C
              DO j=1,i
                DO nd=1,nbdirs
                  td(nd, j, i) = 0.D0
                ENDDO
                t(j, i) = zero
              ENDDO
            ELSE
              DO nd=1,nbdirs
                viid(nd) = vd(nd, i, i)
                vd(nd, i, i) = 0.D0
              ENDDO
C
C              general case
C
              vii = v(i, i)
              v(i, i) = one
              result1 = LSAME(storev, 'C')
              IF (result1) THEN
C
C                 T(1:i-1,i) := - tau(i) * V(i:n,1:i-1)' * V(i:n,i)
C
                arg1 = n - i + 1
                arg2 = i - 1
                DO nd=1,nbdirs
                  arg3d(nd) = -taud(nd, i)
                ENDDO
                arg3 = -tau(i)
                CALL DGEMV_DV('Transpose', arg1, arg2, arg3, arg3d, v(i
     +                        , 1), vd(1, i, 1), ldv, v(i, i), vd(1, i,
     +                        i), 1, zero, t(1, i), td(1, 1, i), 1,
     +                        nbdirs)
              ELSE
C
C                 T(1:i-1,i) := - tau(i) * V(1:i-1,i:n) * V(i,i:n)'
C
                arg1 = i - 1
                arg2 = n - i + 1
                DO nd=1,nbdirs
                  arg3d(nd) = -taud(nd, i)
                ENDDO
                arg3 = -tau(i)
                CALL DGEMV_DV('No transpose', arg1, arg2, arg3, arg3d, v
     +                        (1, i), vd(1, 1, i), ldv, v(i, i), vd(1, i
     +                        , i), ldv, zero, t(1, i), td(1, 1, i), 1,
     +                        nbdirs)
              END IF
C
C              T(1:i-1,i) := T(1:i-1,1:i-1) * T(1:i-1,i)
C
              arg1 = i - 1
              CALL DTRMV_DV('Upper', 'No transpose', 'Non-unit', arg1, t
     +                      , td, ldt, t(1, i), td(1, 1, i), 1, nbdirs)
              DO nd=1,nbdirs
                vd(nd, i, i) = viid(nd)
                td(nd, i, i) = taud(nd, i)
              ENDDO
              v(i, i) = vii
              t(i, i) = tau(i)
            END IF
          ENDDO
        ELSE
          DO i=k,1,-1
            IF (tau(i) .EQ. zero) THEN
C
C              H(i)  =  I
C
              DO j=i,k
                DO nd=1,nbdirs
                  td(nd, j, i) = 0.D0
                ENDDO
                t(j, i) = zero
              ENDDO
            ELSE
C
C              general case
C
              IF (i .LT. k) THEN
                result1 = LSAME(storev, 'C')
                IF (result1) THEN
                  DO nd=1,nbdirs
                    viid(nd) = vd(nd, n-k+i, i)
                    arg3d(nd) = -taud(nd, i)
                    vd(nd, n-k+i, i) = 0.D0
                  ENDDO
                  vii = v(n-k+i, i)
                  v(n-k+i, i) = one
C
C                    T(i+1:k,i) :=
C                            - tau(i) * V(1:n-k+i,i+1:k)' * V(1:n-k+i,i)
C
                  arg1 = n - k + i
                  arg2 = k - i
                  arg3 = -tau(i)
                  CALL DGEMV_DV('Transpose', arg1, arg2, arg3, arg3d, v(
     +                          1, i+1), vd(1, 1, i+1), ldv, v(1, i), vd
     +                          (1, 1, i), 1, zero, t(i+1, i), td(1, i+1
     +                          , i), 1, nbdirs)
                  DO nd=1,nbdirs
                    vd(nd, n-k+i, i) = viid(nd)
                  ENDDO
                  v(n-k+i, i) = vii
                ELSE
                  DO nd=1,nbdirs
                    viid(nd) = vd(nd, i, n-k+i)
                    arg3d(nd) = -taud(nd, i)
                    vd(nd, i, n-k+i) = 0.D0
                  ENDDO
                  vii = v(i, n-k+i)
                  v(i, n-k+i) = one
C
C                    T(i+1:k,i) :=
C                            - tau(i) * V(i+1:k,1:n-k+i) * V(i,1:n-k+i)'
C
                  arg1 = k - i
                  arg2 = n - k + i
                  arg3 = -tau(i)
                  CALL DGEMV_DV('No transpose', arg1, arg2, arg3, arg3d
     +                          , v(i+1, 1), vd(1, i+1, 1), ldv, v(i, 1)
     +                          , vd(1, i, 1), ldv, zero, t(i+1, i), td(
     +                          1, i+1, i), 1, nbdirs)
                  DO nd=1,nbdirs
                    vd(nd, i, n-k+i) = viid(nd)
                  ENDDO
                  v(i, n-k+i) = vii
                END IF
C
C                 T(i+1:k,i) := T(i+1:k,i+1:k) * T(i+1:k,i)
C
                arg1 = k - i
                CALL DTRMV_DV('Lower', 'No transpose', 'Non-unit', arg1
     +                        , t(i+1, i+1), td(1, i+1, i+1), ldt, t(i+1
     +                        , i), td(1, i+1, i), 1, nbdirs)
              END IF
              DO nd=1,nbdirs
                td(nd, i, i) = taud(nd, i)
              ENDDO
              t(i, i) = tau(i)
            END IF
          ENDDO
        END IF
        RETURN
      END IF
      END

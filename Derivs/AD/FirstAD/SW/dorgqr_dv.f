!
! Copyright (C) 2006-2014 Houtan Bastani and Luca Guerrieri
!
!
! This free software: you can redistribute it and/or modify
! it under the terms of the GNU General Public License as published by
! the Free Software Foundation, either version 3 of the License, or
! (at your option) any later version.
!
! It is distributed in the hope that it will be useful,
! but WITHOUT ANY WARRANTY; without even the implied warranty of
! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
! GNU General Public License for more details.
!
! You should have received a copy of the GNU General Public License
! along with Dynare.  If not, see <http://www.gnu.org/licenses/>.
!

C        Generated by TAPENADE     (INRIA, Tropics team)
C  Tapenade - Version 2.2 (r1239) - Wed 28 Jun 2006 04:59:55 PM CEST
C
C  Differentiation of dorgqr in forward (tangent) mode: (multi-directional mode)
C   variations  of output variables: work a
C   with respect to input variables: tau work a
      SUBROUTINE DORGQR_DV(m, n, k, a, ad, lda, tau, taud, work, workd,
     +                     lwork, info, nbdirs)
      USE DIFFSIZES
      IMPLICIT NONE
C
C     End of DORGQR
C
      INTEGER info, k, lwork, m, n
      INTEGER lda, nbdirs
      DOUBLE PRECISION a(lda, *), ad(nbdirsmax, lda, *), tau(*), taud(
     +                 nbdirsmax, *), work(*), workd(nbdirsmax, *)
      DOUBLE PRECISION zero
      PARAMETER (zero=0.0d+0)
      INTEGER arg1, arg2, arg3, i, ib, iinfo, ILAENV, iws, j, ki, kk, l
     +        , ldwork, lwkopt, max1, max2, max3, nb, nbmin, nd, nx, y1
     +        , y2
      LOGICAL lquery
      EXTERNAL ILAENV, XERBLA
      INTRINSIC MAX, MIN
C
C  -- LAPACK routine (version 3.1) --
C     Univ. of Tennessee, Univ. of California Berkeley and NAG Ltd..
C     November 2006
C
C     .. Scalar Arguments ..
C     ..
C     .. Array Arguments ..
C     ..
C
C  Purpose
C  =======
C
C  DORGQR generates an M-by-N real matrix Q with orthonormal columns,
C  which is defined as the first N columns of a product of K elementary
C  reflectors of order M
C
C        Q  =  H(1) H(2) . . . H(k)
C
C  as returned by DGEQRF.
C
C  Arguments
C  =========
C
C  M       (input) INTEGER
C          The number of rows of the matrix Q. M >= 0.
C
C  N       (input) INTEGER
C          The number of columns of the matrix Q. M >= N >= 0.
C
C  K       (input) INTEGER
C          The number of elementary reflectors whose product defines the
C          matrix Q. N >= K >= 0.
C
C  A       (input/output) DOUBLE PRECISION array, dimension (LDA,N)
C          On entry, the i-th column must contain the vector which
C          defines the elementary reflector H(i), for i = 1,2,...,k, as
C          returned by DGEQRF in the first k columns of its array
C          argument A.
C          On exit, the M-by-N matrix Q.
C
C  LDA     (input) INTEGER
C          The first dimension of the array A. LDA >= max(1,M).
C
C  TAU     (input) DOUBLE PRECISION array, dimension (K)
C          TAU(i) must contain the scalar factor of the elementary
C          reflector H(i), as returned by DGEQRF.
C
C  WORK    (workspace/output) DOUBLE PRECISION array, dimension (MAX(1,LWORK))
C          On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
C
C  LWORK   (input) INTEGER
C          The dimension of the array WORK. LWORK >= max(1,N).
C          For optimum performance LWORK >= N*NB, where NB is the
C          optimal blocksize.
C
C          If LWORK = -1, then a workspace query is assumed; the routine
C          only calculates the optimal size of the WORK array, returns
C          this value as the first entry of the WORK array, and no error
C          message related to LWORK is issued by XERBLA.
C
C  INFO    (output) INTEGER
C          = 0:  successful exit
C          < 0:  if INFO = -i, the i-th argument has an illegal value
C
C  =====================================================================
C
C     .. Parameters ..
C     ..
C     .. Local Scalars ..
C     ..
C     .. External Subroutines ..
C     ..
C     .. Intrinsic Functions ..
C     ..
C     .. External Functions ..
C     ..
C     .. Executable Statements ..
C
C     Test the input arguments
C
      info = 0
      arg1 = -1
      nb = ILAENV(1, 'DORGQR', ' ', m, n, k, arg1)
      IF (1 .LT. n) THEN
        max1 = n
      ELSE
        max1 = 1
      END IF
      lwkopt = max1*nb
      DO nd=1,nbdirs
        workd(nd, 1) = 0.D0
      ENDDO
      work(1) = lwkopt
      lquery = lwork .EQ. -1
      IF (m .LT. 0) THEN
        info = -1
      ELSE IF (n .LT. 0 .OR. n .GT. m) THEN
        info = -2
      ELSE IF (k .LT. 0 .OR. k .GT. n) THEN
        info = -3
      ELSE
        IF (1 .LT. m) THEN
          max2 = m
        ELSE
          max2 = 1
        END IF
        IF (lda .LT. max2) THEN
          info = -5
        ELSE
          IF (1 .LT. n) THEN
            max3 = n
          ELSE
            max3 = 1
          END IF
          IF (lwork .LT. max3 .AND. (.NOT.lquery)) info = -8
        END IF
      END IF
      IF (info .NE. 0) THEN
        arg1 = -info
        CALL XERBLA('DORGQR', arg1)
        RETURN
      ELSE IF (lquery) THEN
        RETURN
      ELSE IF (n .LE. 0) THEN
C
C     Quick return if possible
C
        DO nd=1,nbdirs
          workd(nd, 1) = 0.D0
        ENDDO
        work(1) = 1
        RETURN
      ELSE
C
        nbmin = 2
        nx = 0
        iws = n
        IF (nb .GT. 1 .AND. nb .LT. k) THEN
          arg1 = -1
          y1 = ILAENV(3, 'DORGQR', ' ', m, n, k, arg1)
          IF (0 .LT. y1) THEN
            nx = y1
          ELSE
            nx = 0
          END IF
          IF (nx .LT. k) THEN
C
C           Determine if workspace is large enough for blocked code.
C
            ldwork = n
            iws = ldwork*nb
            IF (lwork .LT. iws) THEN
C
C              Not enough workspace to use optimal NB:  reduce NB and
C              determine the minimum value of NB.
C
              nb = lwork/ldwork
              arg1 = -1
              y2 = ILAENV(2, 'DORGQR', ' ', m, n, k, arg1)
              IF (2 .LT. y2) THEN
                nbmin = y2
              ELSE
                nbmin = 2
              END IF
            END IF
          END IF
        END IF
C
        IF (nb .GE. nbmin .AND. nb .LT. k .AND. nx .LT. k) THEN
C
C        Use blocked code after the last block.
C        The first kk columns are handled by the block method.
C
          ki = (k-nx-1)/nb*nb
          IF (k .GT. ki + nb) THEN
            kk = ki + nb
          ELSE
            kk = k
          END IF
C
C        Set A(1:kk,kk+1:n) to zero.
C
          DO j=kk+1,n
            DO i=1,kk
              DO nd=1,nbdirs
                ad(nd, i, j) = 0.D0
              ENDDO
              a(i, j) = zero
            ENDDO
          ENDDO
        ELSE
          kk = 0
        END IF
C
C     Use unblocked code for the last or only block.
C
        IF (kk .LT. n) THEN
          arg1 = m - kk
          arg2 = n - kk
          arg3 = k - kk
          CALL DORG2R_DV(arg1, arg2, arg3, a(kk+1, kk+1), ad(1, kk+1, kk
     +                   +1), lda, tau(kk+1), taud(1, kk+1), work, workd
     +                   , iinfo, nbdirs)
        END IF
C
        IF (kk .GT. 0) THEN
C
C        Use blocked code
C
          DO i=ki+1,1,-nb
            IF (nb .GT. k - i + 1) THEN
              ib = k - i + 1
            ELSE
              ib = nb
            END IF
            IF (i + ib .LE. n) THEN
C
C              Form the triangular factor of the block reflector
C              H = H(i) H(i+1) . . . H(i+ib-1)
C
              arg1 = m - i + 1
              CALL DLARFT_DV('Forward', 'Columnwise', arg1, ib, a(i, i)
     +                       , ad(1, i, i), lda, tau(i), taud(1, i),
     +                       work, workd, ldwork, nbdirs)
C
C              Apply H to A(i:m,i+ib:n) from the left
C
              arg1 = m - i + 1
              arg2 = n - i - ib + 1
              CALL DLARFB_DV('Left', 'No transpose', 'Forward',
     +                       'Columnwise', arg1, arg2, ib, a(i, i), ad(1
     +                       , i, i), lda, work, workd, ldwork, a(i, i+
     +                       ib), ad(1, i, i+ib), lda, work(ib+1), workd
     +                       (1, ib+1), ldwork, nbdirs)
            END IF
C
C           Apply H to rows i:m of current block
C
            arg1 = m - i + 1
            CALL DORG2R_DV(arg1, ib, ib, a(i, i), ad(1, i, i), lda, tau(
     +                     i), taud(1, i), work, workd, iinfo, nbdirs)
C
C           Set rows 1:i-1 of current block to zero
C
            DO j=i,i+ib-1
              DO l=1,i-1
                DO nd=1,nbdirs
                  ad(nd, l, j) = 0.D0
                ENDDO
                a(l, j) = zero
              ENDDO
            ENDDO
          ENDDO
        END IF
        DO nd=1,nbdirs
          workd(nd, 1) = 0.D0
        ENDDO
C
        work(1) = iws
        RETURN
      END IF
      END

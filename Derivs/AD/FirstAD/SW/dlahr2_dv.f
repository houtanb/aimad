!
! Copyright (C) 2006-2014 Houtan Bastani and Luca Guerrieri
!
!
! This free software: you can redistribute it and/or modify
! it under the terms of the GNU General Public License as published by
! the Free Software Foundation, either version 3 of the License, or
! (at your option) any later version.
!
! It is distributed in the hope that it will be useful,
! but WITHOUT ANY WARRANTY; without even the implied warranty of
! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
! GNU General Public License for more details.
!
! You should have received a copy of the GNU General Public License
! along with Dynare.  If not, see <http://www.gnu.org/licenses/>.
!

C        Generated by TAPENADE     (INRIA, Tropics team)
C  Tapenade - Version 2.2 (r1239) - Wed 28 Jun 2006 04:59:55 PM CEST
C
C  Differentiation of dlahr2 in forward (tangent) mode: (multi-directional mode)
C   variations  of output variables: tau t y a
C   with respect to input variables: tau t y a
      SUBROUTINE DLAHR2_DV(n, k, nb, a, ad, lda, tau, taud, t, td, ldt,
     +                     y, yd, ldy, nbdirs)
      USE DIFFSIZES
      IMPLICIT NONE
C
C     End of DLAHR2
C
      INTEGER lda, ldt, ldy, nb, nbdirs
      DOUBLE PRECISION a(lda, *), ad(nbdirsmax, lda, *), t(ldt, nb), tau
     +                 (nb), taud(nbdirsmax, nb), td(nbdirsmax, ldt, nb)
     +                 , y(ldy, nb), yd(nbdirsmax, ldy, nb)
      INTEGER k, n
      DOUBLE PRECISION one, zero
      PARAMETER (one=1.0d+0, zero=0.0d+0)
      DOUBLE PRECISION arg20, arg20d(nbdirsmax), arg3, arg3d(nbdirsmax)
      DOUBLE PRECISION ei, eid(nbdirsmax)
      DOUBLE PRECISION initvald(nbdirsmax), initvald0(nbdirsmax),
     +                 initvald1(nbdirsmax)
      INTEGER arg1, arg2, i, min1, nd
      INTRINSIC MIN
C
C  -- LAPACK auxiliary routine (version 3.1) --
C     Univ. of Tennessee, Univ. of California Berkeley and NAG Ltd..
C     November 2006
C
C     .. Scalar Arguments ..
C     ..
C     .. Array Arguments ..
C     ..
C
C  Purpose
C  =======
C
C  DLAHR2 reduces the first NB columns of A real general n-BY-(n-k+1)
C  matrix A so that elements below the k-th subdiagonal are zero. The
C  reduction is performed by an orthogonal similarity transformation
C  Q' * A * Q. The routine returns the matrices V and T which determine
C  Q as a block reflector I - V*T*V', and also the matrix Y = A * V * T.
C
C  This is an auxiliary routine called by DGEHRD.
C
C  Arguments
C  =========
C
C  N       (input) INTEGER
C          The order of the matrix A.
C
C  K       (input) INTEGER
C          The offset for the reduction. Elements below the k-th
C          subdiagonal in the first NB columns are reduced to zero.
C          K < N.
C
C  NB      (input) INTEGER
C          The number of columns to be reduced.
C
C  A       (input/output) DOUBLE PRECISION array, dimension (LDA,N-K+1)
C          On entry, the n-by-(n-k+1) general matrix A.
C          On exit, the elements on and above the k-th subdiagonal in
C          the first NB columns are overwritten with the corresponding
C          elements of the reduced matrix; the elements below the k-th
C          subdiagonal, with the array TAU, represent the matrix Q as a
C          product of elementary reflectors. The other columns of A are
C          unchanged. See Further Details.
C
C  LDA     (input) INTEGER
C          The leading dimension of the array A.  LDA >= max(1,N).
C
C  TAU     (output) DOUBLE PRECISION array, dimension (NB)
C          The scalar factors of the elementary reflectors. See Further
C          Details.
C
C  T       (output) DOUBLE PRECISION array, dimension (LDT,NB)
C          The upper triangular matrix T.
C
C  LDT     (input) INTEGER
C          The leading dimension of the array T.  LDT >= NB.
C
C  Y       (output) DOUBLE PRECISION array, dimension (LDY,NB)
C          The n-by-nb matrix Y.
C
C  LDY     (input) INTEGER
C          The leading dimension of the array Y. LDY >= N.
C
C  Further Details
C  ===============
C
C  The matrix Q is represented as a product of nb elementary reflectors
C
C     Q = H(1) H(2) . . . H(nb).
C
C  Each H(i) has the form
C
C     H(i) = I - tau * v * v'
C
C  where tau is a real scalar, and v is a real vector with
C  v(1:i+k-1) = 0, v(i+k) = 1; v(i+k+1:n) is stored on exit in
C  A(i+k+1:n,i), and tau in TAU(i).
C
C  The elements of the vectors v together form the (n-k+1)-by-nb matrix
C  V which is needed, with T and Y, to apply the transformation to the
C  unreduced part of the matrix, using an update of the form:
C  A := (I - V*T*V') * (A - Y*V').
C
C  The contents of A on exit are illustrated by the following example
C  with n = 7, k = 3 and nb = 2:
C
C     ( a   a   a   a   a )
C     ( a   a   a   a   a )
C     ( a   a   a   a   a )
C     ( h   h   a   a   a )
C     ( v1  h   a   a   a )
C     ( v1  v2  a   a   a )
C     ( v1  v2  a   a   a )
C
C  where a denotes an element of the original matrix A, h denotes a
C  modified element of the upper Hessenberg matrix H, and vi denotes an
C  element of the vector defining H(i).
C
C  This file is a slight modification of LAPACK-3.0's DLAHRD
C  incorporating improvements proposed by Quintana-Orti and Van de
C  Gejin. Note that the entries of A(1:K,2:NB) differ from those
C  returned by the original LAPACK routine. This function is
C  not backward compatible with LAPACK3.0.
C
C  =====================================================================
C
C     .. Parameters ..
C     ..
C     .. Local Scalars ..
C     ..
C     .. External Subroutines ..
C     ..
C     .. Intrinsic Functions ..
C     ..
C     .. Executable Statements ..
C
C     Quick return if possible
C
      IF (n .LE. 1) THEN
        RETURN
      ELSE
        DO nd=1,nbdirs
          eid(nd) = 0.D0
        ENDDO
C
        DO i=1,nb
          IF (i .GT. 1) THEN
C
C           Update A(K+1:N,I)
C
C           Update I-th column of A - Y * V'
C
            arg1 = n - k
            arg2 = i - 1
            arg3 = -one
            CALL DGEMV_DV('NO TRANSPOSE', arg1, arg2, arg3, arg3d, y(k+1
     +                    , 1), yd(1, k+1, 1), ldy, a(k+i-1, 1), ad(1, k
     +                    +i-1, 1), lda, one, a(k+1, i), ad(1, k+1, i),
     +                    1, nbdirs)
C
C           Apply I - V * T' * V' to this column (call it b) from the
C           left, using the last column of T as workspace
C
C           Let  V = ( V1 )   and   b = ( b1 )   (first I-1 rows)
C                    ( V2 )             ( b2 )
C
C           where V1 is unit lower triangular
C
C           w := V1' * b1
C
            arg1 = i - 1
            CALL DCOPY_DV(arg1, a(k+1, i), ad(1, k+1, i), 1, t(1, nb),
     +                    td(1, 1, nb), 1, nbdirs)
            arg1 = i - 1
            CALL DTRMV_DV('Lower', 'Transpose', 'UNIT', arg1, a(k+1, 1)
     +                    , ad(1, k+1, 1), lda, t(1, nb), td(1, 1, nb),
     +                    1, nbdirs)
C
C           w := w + V2'*b2
C
            arg1 = n - k - i + 1
            arg2 = i - 1
            DO nd=1,nbdirs
              initvald(nd) = 0.D0
            ENDDO
            CALL DGEMV_DV('Transpose', arg1, arg2, one, initvald, a(k+i
     +                    , 1), ad(1, k+i, 1), lda, a(k+i, i), ad(1, k+i
     +                    , i), 1, one, t(1, nb), td(1, 1, nb), 1,
     +                    nbdirs)
C
C           w := T'*w
C
            arg1 = i - 1
            CALL DTRMV_DV('Upper', 'Transpose', 'NON-UNIT', arg1, t, td
     +                    , ldt, t(1, nb), td(1, 1, nb), 1, nbdirs)
C
C           b2 := b2 - V2*w
C
            arg1 = n - k - i + 1
            arg2 = i - 1
            arg3 = -one
            CALL DGEMV_DV('NO TRANSPOSE', arg1, arg2, arg3, arg3d, a(k+i
     +                    , 1), ad(1, k+i, 1), lda, t(1, nb), td(1, 1,
     +                    nb), 1, one, a(k+i, i), ad(1, k+i, i), 1,
     +                    nbdirs)
C
C           b1 := b1 - V1*w
C
            arg1 = i - 1
            CALL DTRMV_DV('Lower', 'NO TRANSPOSE', 'UNIT', arg1, a(k+1,
     +                    1), ad(1, k+1, 1), lda, t(1, nb), td(1, 1, nb)
     +                    , 1, nbdirs)
            arg1 = i - 1
            arg20 = -one
            CALL DAXPY_DV(arg1, arg20, t(1, nb), td(1, 1, nb), 1, a(k+1
     +                    , i), ad(1, k+1, i), 1, nbdirs)
            DO nd=1,nbdirs
              arg3d(nd) = 0.D0
              ad(nd, k+i-1, i-1) = eid(nd)
              arg3d(nd) = 0.D0
            ENDDO
C
            a(k+i-1, i-1) = ei
          END IF
          IF (k + i + 1 .GT. n) THEN
            min1 = n
          ELSE
            min1 = k + i + 1
          END IF
C
C        Generate the elementary reflector H(I) to annihilate
C        A(K+I+1:N,I)
C
          arg1 = n - k - i + 1
          CALL DLARFG_DV(arg1, a(k+i, i), ad(1, k+i, i), a(min1, i), ad(
     +                   1, min1, i), 1, tau(i), taud(1, i), nbdirs)
          DO nd=1,nbdirs
            eid(nd) = ad(nd, k+i, i)
            arg20d(nd) = -taud(nd, i)
            arg3d(nd) = 0.D0
            initvald1(nd) = 0.D0
            initvald0(nd) = 0.D0
            ad(nd, k+i, i) = 0.D0
          ENDDO
          ei = a(k+i, i)
          a(k+i, i) = one
C
C        Compute  Y(K+1:N,I)
C
          arg1 = n - k
          arg2 = n - k - i + 1
          CALL DGEMV_DV('NO TRANSPOSE', arg1, arg2, one, initvald0, a(k+
     +                  1, i+1), ad(1, k+1, i+1), lda, a(k+i, i), ad(1,
     +                  k+i, i), 1, zero, y(k+1, i), yd(1, k+1, i), 1,
     +                  nbdirs)
          arg1 = n - k - i + 1
          arg2 = i - 1
          CALL DGEMV_DV('Transpose', arg1, arg2, one, initvald1, a(k+i,
     +                  1), ad(1, k+i, 1), lda, a(k+i, i), ad(1, k+i, i)
     +                  , 1, zero, t(1, i), td(1, 1, i), 1, nbdirs)
          arg1 = n - k
          arg2 = i - 1
          arg3 = -one
          CALL DGEMV_DV('NO TRANSPOSE', arg1, arg2, arg3, arg3d, y(k+1,
     +                  1), yd(1, k+1, 1), ldy, t(1, i), td(1, 1, i), 1
     +                  , one, y(k+1, i), yd(1, k+1, i), 1, nbdirs)
          arg1 = n - k
          CALL DSCAL_DV(arg1, tau(i), taud(1, i), y(k+1, i), yd(1, k+1,
     +                  i), 1, nbdirs)
C
C        Compute T(1:I,I)
C
          arg1 = i - 1
          arg20 = -tau(i)
          CALL DSCAL_DV(arg1, arg20, arg20d, t(1, i), td(1, 1, i), 1,
     +                  nbdirs)
          arg1 = i - 1
          CALL DTRMV_DV('Upper', 'No Transpose', 'NON-UNIT', arg1, t, td
     +                  , ldt, t(1, i), td(1, 1, i), 1, nbdirs)
          DO nd=1,nbdirs
            td(nd, i, i) = taud(nd, i)
          ENDDO
          t(i, i) = tau(i)
        ENDDO
        DO nd=1,nbdirs
          ad(nd, k+nb, nb) = eid(nd)
        ENDDO
C
        a(k+nb, nb) = ei
C
C     Compute Y(1:K,1:NB)
C
        CALL DLACPY_DV('ALL', k, nb, a(1, 2), ad(1, 1, 2), lda, y, yd,
     +                 ldy, nbdirs)
        CALL DTRMM_DV('RIGHT', 'Lower', 'NO TRANSPOSE', 'UNIT', k, nb,
     +                one, a(k+1, 1), ad(1, k+1, 1), lda, y, yd, ldy,
     +                nbdirs)
        IF (n .GT. k + nb) THEN
          arg1 = n - k - nb
          CALL DGEMM_DV('NO TRANSPOSE', 'NO TRANSPOSE', k, nb, arg1, one
     +                  , a(1, 2+nb), ad(1, 1, 2+nb), lda, a(k+1+nb, 1)
     +                  , ad(1, k+1+nb, 1), lda, one, y, yd, ldy, nbdirs
     +                 )
        END IF
        CALL DTRMM_DV('RIGHT', 'Upper', 'NO TRANSPOSE', 'NON-UNIT', k,
     +                nb, one, t, td, ldt, y, yd, ldy, nbdirs)
C
        RETURN
      END IF
      END

!
! Copyright (C) 2006-2014 Houtan Bastani and Luca Guerrieri
!
!
! This free software: you can redistribute it and/or modify
! it under the terms of the GNU General Public License as published by
! the Free Software Foundation, either version 3 of the License, or
! (at your option) any later version.
!
! It is distributed in the hope that it will be useful,
! but WITHOUT ANY WARRANTY; without even the implied warranty of
! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
! GNU General Public License for more details.
!
! You should have received a copy of the GNU General Public License
! along with Dynare.  If not, see <http://www.gnu.org/licenses/>.
!

C        Generated by TAPENADE     (INRIA, Tropics team)
C  Tapenade - Version 2.2 (r1239) - Wed 28 Jun 2006 04:59:55 PM CEST
C
C  Differentiation of dtrsen in forward (tangent) mode: (multi-directional mode)
C   variations  of output variables: q work
C   with respect to input variables: q t work
      SUBROUTINE DTRSEN_DV(job, compq, select, n, t, td, ldt, q, qd, ldq
     +                     , wr, wi, m, s, sep, work, workd, lwork,
     +                     iwork, liwork, info, nbdirs)
      USE DIFFSIZES
      IMPLICIT NONE
C
C     End of DTRSEN
C
      CHARACTER compq, job
      INTEGER info, iwork(*), liwork, lwork, m, n
      INTEGER ldq, ldt, nbdirs
      LOGICAL select(*)
      DOUBLE PRECISION s, sep
      DOUBLE PRECISION q(ldq, *), qd(nbdirsmax, ldq, *), t(ldt, *), td(
     +                 nbdirsmax, ldt, *), wi(*), work(*), workd(
     +                 nbdirsmax, *), wr(*)
      DOUBLE PRECISION one, zero
      PARAMETER (one=1.0d+0, zero=0.0d+0)
      DOUBLE PRECISION abs1, abs2
      DOUBLE PRECISION DLANGE
      INTEGER arg1, ierr, isave(3), k, kase, kk, ks, liwmin, lwmin, max1
     +        , n1, n2, nd, nn
      LOGICAL lquery, LSAME, pair, result1, swap, wantbh, wantq, wants,
     +        wantsp
      DOUBLE PRECISION arg10, est, result10, result2, rnorm, rnormd(
     +                 nbdirsmax), scale
      DOUBLE PRECISION sepd(nbdirsmax)
      INTRINSIC MAX, ABS, SQRT
      EXTERNAL XERBLA, LSAME
C
C  -- LAPACK routine (version 3.1) --
C     Univ. of Tennessee, Univ. of California Berkeley and NAG Ltd..
C     November 2006
C
C     .. Scalar Arguments ..
C     ..
C     .. Array Arguments ..
C     ..
C
C  Purpose
C  =======
C
C  DTRSEN reorders the real Schur factorization of a real matrix
C  A = Q*T*Q**T, so that a selected cluster of eigenvalues appears in
C  the leading diagonal blocks of the upper quasi-triangular matrix T,
C  and the leading columns of Q form an orthonormal basis of the
C  corresponding right invariant subspace.
C
C  Optionally the routine computes the reciprocal condition numbers of
C  the cluster of eigenvalues and/or the invariant subspace.
C
C  T must be in Schur canonical form (as returned by DHSEQR), that is,
C  block upper triangular with 1-by-1 and 2-by-2 diagonal blocks; each
C  2-by-2 diagonal block has its diagonal elemnts equal and its
C  off-diagonal elements of opposite sign.
C
C  Arguments
C  =========
C
C  JOB     (input) CHARACTER*1
C          Specifies whether condition numbers are required for the
C          cluster of eigenvalues (S) or the invariant subspace (SEP):
C          = 'N': none;
C          = 'E': for eigenvalues only (S);
C          = 'V': for invariant subspace only (SEP);
C          = 'B': for both eigenvalues and invariant subspace (S and
C                 SEP).
C
C  COMPQ   (input) CHARACTER*1
C          = 'V': update the matrix Q of Schur vectors;
C          = 'N': do not update Q.
C
C  SELECT  (input) LOGICAL array, dimension (N)
C          SELECT specifies the eigenvalues in the selected cluster. To
C          select a real eigenvalue w(j), SELECT(j) must be set to
C          .TRUE.. To select a complex conjugate pair of eigenvalues
C          w(j) and w(j+1), corresponding to a 2-by-2 diagonal block,
C          either SELECT(j) or SELECT(j+1) or both must be set to
C          .TRUE.; a complex conjugate pair of eigenvalues must be
C          either both included in the cluster or both excluded.
C
C  N       (input) INTEGER
C          The order of the matrix T. N >= 0.
C
C  T       (input/output) DOUBLE PRECISION array, dimension (LDT,N)
C          On entry, the upper quasi-triangular matrix T, in Schur
C          canonical form.
C          On exit, T is overwritten by the reordered matrix T, again in
C          Schur canonical form, with the selected eigenvalues in the
C          leading diagonal blocks.
C
C  LDT     (input) INTEGER
C          The leading dimension of the array T. LDT >= max(1,N).
C
C  Q       (input/output) DOUBLE PRECISION array, dimension (LDQ,N)
C          On entry, if COMPQ = 'V', the matrix Q of Schur vectors.
C          On exit, if COMPQ = 'V', Q has been postmultiplied by the
C          orthogonal transformation matrix which reorders T; the
C          leading M columns of Q form an orthonormal basis for the
C          specified invariant subspace.
C          If COMPQ = 'N', Q is not referenced.
C
C  LDQ     (input) INTEGER
C          The leading dimension of the array Q.
C          LDQ >= 1; and if COMPQ = 'V', LDQ >= N.
C
C  WR      (output) DOUBLE PRECISION array, dimension (N)
C  WI      (output) DOUBLE PRECISION array, dimension (N)
C          The real and imaginary parts, respectively, of the reordered
C          eigenvalues of T. The eigenvalues are stored in the same
C          order as on the diagonal of T, with WR(i) = T(i,i) and, if
C          T(i:i+1,i:i+1) is a 2-by-2 diagonal block, WI(i) > 0 and
C          WI(i+1) = -WI(i). Note that if a complex eigenvalue is
C          sufficiently ill-conditioned, then its value may differ
C          significantly from its value before reordering.
C
C  M       (output) INTEGER
C          The dimension of the specified invariant subspace.
C          0 < = M <= N.
C
C  S       (output) DOUBLE PRECISION
C          If JOB = 'E' or 'B', S is a lower bound on the reciprocal
C          condition number for the selected cluster of eigenvalues.
C          S cannot underestimate the true reciprocal condition number
C          by more than a factor of sqrt(N). If M = 0 or N, S = 1.
C          If JOB = 'N' or 'V', S is not referenced.
C
C  SEP     (output) DOUBLE PRECISION
C          If JOB = 'V' or 'B', SEP is the estimated reciprocal
C          condition number of the specified invariant subspace. If
C          M = 0 or N, SEP = norm(T).
C          If JOB = 'N' or 'E', SEP is not referenced.
C
C  WORK    (workspace/output) DOUBLE PRECISION array, dimension (MAX(1,LWORK))
C          On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
C
C  LWORK   (input) INTEGER
C          The dimension of the array WORK.
C          If JOB = 'N', LWORK >= max(1,N);
C          if JOB = 'E', LWORK >= max(1,M*(N-M));
C          if JOB = 'V' or 'B', LWORK >= max(1,2*M*(N-M)).
C
C          If LWORK = -1, then a workspace query is assumed; the routine
C          only calculates the optimal size of the WORK array, returns
C          this value as the first entry of the WORK array, and no error
C          message related to LWORK is issued by XERBLA.
C
C  IWORK   (workspace) INTEGER array, dimension (MAX(1,LIWORK))
C          On exit, if INFO = 0, IWORK(1) returns the optimal LIWORK.
C
C  LIWORK  (input) INTEGER
C          The dimension of the array IWORK.
C          If JOB = 'N' or 'E', LIWORK >= 1;
C          if JOB = 'V' or 'B', LIWORK >= max(1,M*(N-M)).
C
C          If LIWORK = -1, then a workspace query is assumed; the
C          routine only calculates the optimal size of the IWORK array,
C          returns this value as the first entry of the IWORK array, and
C          no error message related to LIWORK is issued by XERBLA.
C
C  INFO    (output) INTEGER
C          = 0: successful exit
C          < 0: if INFO = -i, the i-th argument had an illegal value
C          = 1: reordering of T failed because some eigenvalues are too
C               close to separate (the problem is very ill-conditioned);
C               T may have been partially reordered, and WR and WI
C               contain the eigenvalues in the same order as in T; S and
C               SEP (if requested) are set to zero.
C
C  Further Details
C  ===============
C
C  DTRSEN first collects the selected eigenvalues by computing an
C  orthogonal transformation Z to move them to the top left corner of T.
C  In other words, the selected eigenvalues are the eigenvalues of T11
C  in:
C
C                Z'*T*Z = ( T11 T12 ) n1
C                         (  0  T22 ) n2
C                            n1  n2
C
C  where N = n1+n2 and Z' means the transpose of Z. The first n1 columns
C  of Z span the specified invariant subspace of T.
C
C  If T has been obtained from the real Schur factorization of a matrix
C  A = Q*T*Q', then the reordered real Schur factorization of A is given
C  by A = (Q*Z)*(Z'*T*Z)*(Q*Z)', and the first n1 columns of Q*Z span
C  the corresponding invariant subspace of A.
C
C  The reciprocal condition number of the average of the eigenvalues of
C  T11 may be returned in S. S lies between 0 (very badly conditioned)
C  and 1 (very well conditioned). It is computed as follows. First we
C  compute R so that
C
C                         P = ( I  R ) n1
C                             ( 0  0 ) n2
C                               n1 n2
C
C  is the projector on the invariant subspace associated with T11.
C  R is the solution of the Sylvester equation:
C
C                        T11*R - R*T22 = T12.
C
C  Let F-norm(M) denote the Frobenius-norm of M and 2-norm(M) denote
C  the two-norm of M. Then S is computed as the lower bound
C
C                      (1 + F-norm(R)**2)**(-1/2)
C
C  on the reciprocal of 2-norm(P), the true reciprocal condition number.
C  S cannot underestimate 1 / 2-norm(P) by more than a factor of
C  sqrt(N).
C
C  An approximate error bound for the computed average of the
C  eigenvalues of T11 is
C
C                         EPS * norm(T) / S
C
C  where EPS is the machine precision.
C
C  The reciprocal condition number of the right invariant subspace
C  spanned by the first n1 columns of Z (or of Q*Z) is returned in SEP.
C  SEP is defined as the separation of T11 and T22:
C
C                     sep( T11, T22 ) = sigma-min( C )
C
C  where sigma-min(C) is the smallest singular value of the
C  n1*n2-by-n1*n2 matrix
C
C     C  = kprod( I(n2), T11 ) - kprod( transpose(T22), I(n1) )
C
C  I(m) is an m by m identity matrix, and kprod denotes the Kronecker
C  product. We estimate sigma-min(C) by the reciprocal of an estimate of
C  the 1-norm of inverse(C). The true reciprocal 1-norm of inverse(C)
C  cannot differ from sigma-min(C) by more than a factor of sqrt(n1*n2).
C
C  When SEP is small, small changes in T can cause large changes in
C  the invariant subspace. An approximate bound on the maximum angular
C  error in the computed right invariant subspace is
C
C                      EPS * norm(T) / SEP
C
C  =====================================================================
C
C     .. Parameters ..
C     ..
C     .. Local Scalars ..
C     ..
C     .. Local Arrays ..
C     ..
C     .. External Functions ..
C     ..
C     .. External Subroutines ..
C     ..
C     .. Intrinsic Functions ..
C     ..
C     .. Executable Statements ..
C
C     Decode and test the input parameters
C
      wantbh = LSAME(job, 'B')
      result1 = LSAME(job, 'E')
      wants = result1 .OR. wantbh
      result1 = LSAME(job, 'V')
      wantsp = result1 .OR. wantbh
      wantq = LSAME(compq, 'V')
C
      info = 0
      lquery = lwork .EQ. -1
      result1 = LSAME(job, 'N')
      IF (.NOT.result1 .AND. (.NOT.wants) .AND. (.NOT.wantsp)) THEN
        info = -1
      ELSE
        result1 = LSAME(compq, 'N')
        IF (.NOT.result1 .AND. (.NOT.wantq)) THEN
          info = -2
        ELSE IF (n .LT. 0) THEN
          info = -4
        ELSE
          IF (1 .LT. n) THEN
            max1 = n
          ELSE
            max1 = 1
          END IF
          IF (ldt .LT. max1) THEN
            info = -6
          ELSE IF (ldq .LT. 1 .OR. wantq .AND. ldq .LT. n) THEN
            info = -8
          ELSE
C
C        Set M to the dimension of the specified invariant subspace,
C        and test LWORK and LIWORK.
C
            m = 0
            pair = .false.
            DO k=1,n
              IF (pair) THEN
                pair = .false.
              ELSE IF (k .LT. n) THEN
                IF (t(k+1, k) .EQ. zero) THEN
                  IF (select(k)) m = m + 1
                ELSE
                  pair = .true.
                  IF (select(k) .OR. select(k+1)) m = m + 2
                END IF
              ELSE IF (select(n)) THEN
                m = m + 1
              END IF
            ENDDO
C
            n1 = m
            n2 = n - m
            nn = n1*n2
C
            IF (wantsp) THEN
              IF (1 .LT. 2*nn) THEN
                lwmin = 2*nn
              ELSE
                lwmin = 1
              END IF
              IF (1 .LT. nn) THEN
                liwmin = nn
              ELSE
                liwmin = 1
              END IF
            ELSE
              result1 = LSAME(job, 'N')
              IF (result1) THEN
                IF (1 .LT. n) THEN
                  lwmin = n
                ELSE
                  lwmin = 1
                END IF
                liwmin = 1
              ELSE
                result1 = LSAME(job, 'E')
                IF (result1) THEN
                  IF (1 .LT. nn) THEN
                    lwmin = nn
                  ELSE
                    lwmin = 1
                  END IF
                  liwmin = 1
                END IF
              END IF
            END IF
C
            IF (lwork .LT. lwmin .AND. (.NOT.lquery)) THEN
              info = -15
            ELSE IF (liwork .LT. liwmin .AND. (.NOT.lquery)) THEN
              info = -17
            END IF
          END IF
        END IF
      END IF
C
      IF (info .EQ. 0) THEN
        DO nd=1,nbdirs
          workd(nd, 1) = 0.D0
        ENDDO
        work(1) = lwmin
        iwork(1) = liwmin
      END IF
C
      IF (info .NE. 0) THEN
        arg1 = -info
        CALL XERBLA('DTRSEN', arg1)
        RETURN
      ELSE IF (lquery) THEN
        RETURN
      ELSE
C
C     Quick return if possible.
C
        IF (m .EQ. n .OR. m .EQ. 0) THEN
          IF (wants) s = one
          IF (wantsp) CALL DLANGE_DV('1', n, n, t, td, ldt, work, workd
     +                               , sep, sepd, nbdirs)
        ELSE
C
C     Collect the selected blocks at the top-left corner of T.
C
          ks = 0
          pair = .false.
          DO k=1,n
            IF (pair) THEN
              pair = .false.
            ELSE
              swap = select(k)
              IF (k .LT. n) THEN
                IF (t(k+1, k) .NE. zero) THEN
                  pair = .true.
                  swap = swap .OR. select(k+1)
                END IF
              END IF
              IF (swap) THEN
                ks = ks + 1
C
C              Swap the K-th block to position KS.
C
                ierr = 0
                kk = k
                IF (k .NE. ks) CALL DTREXC_DV(compq, n, t, td, ldt, q,
     +                                        qd, ldq, kk, ks, work,
     +                                        workd, ierr, nbdirs)
                IF (ierr .EQ. 1 .OR. ierr .EQ. 2) THEN
                  GOTO 100
                ELSE IF (pair) THEN
                  ks = ks + 1
                END IF
              END IF
            END IF
          ENDDO
          GOTO 110
C
C                 Blocks too close to swap: exit.
C
 100      info = 1
          IF (wants) s = zero
          IF (wantsp) sep = zero
          GOTO 40
C
 110      IF (wants) THEN
C
C        Solve Sylvester equation for R:
C
C           T11*R - R*T22 = scale*T12
C
            CALL DLACPY_DV('F', n1, n2, t(1, n1+1), td(1, 1, n1+1), ldt
     +                     , work, workd, n1, nbdirs)
            arg1 = -1
            CALL DTRSYL_DV('N', 'N', arg1, n1, n2, t, td, ldt, t(n1+1,
     +                     n1+1), td(1, n1+1, n1+1), ldt, work, workd,
     +                     n1, scale, ierr, nbdirs)
C
C        Estimate the reciprocal of the condition number of the cluster
C        of eigenvalues.
C
            CALL DLANGE_DV('F', n1, n2, work, workd, n1, work, workd,
     +                     rnorm, rnormd, nbdirs)
            IF (rnorm .EQ. zero) THEN
              s = one
            ELSE
              arg10 = scale*scale/rnorm + rnorm
              result10 = SQRT(arg10)
              result2 = SQRT(rnorm)
              s = scale/(result10*result2)
            END IF
          END IF
C
          IF (wantsp) THEN
C
C        Estimate sep(T11,T22).
C
            est = zero
            kase = 0
 30         CALL DLACN2_DV(nn, work(nn+1), workd(1, nn+1), work, workd,
     +                     iwork, est, kase, isave, nbdirs)
            IF (kase .NE. 0) THEN
              IF (kase .EQ. 1) THEN
C
C              Solve  T11*R - R*T22 = scale*X.
C
                arg1 = -1
                CALL DTRSYL_DV('N', 'N', arg1, n1, n2, t, td, ldt, t(n1+
     +                         1, n1+1), td(1, n1+1, n1+1), ldt, work,
     +                         workd, n1, scale, ierr, nbdirs)
              ELSE
C
C              Solve  T11'*R - R*T22' = scale*X.
C
                arg1 = -1
                CALL DTRSYL_DV('T', 'T', arg1, n1, n2, t, td, ldt, t(n1+
     +                         1, n1+1), td(1, n1+1, n1+1), ldt, work,
     +                         workd, n1, scale, ierr, nbdirs)
              END IF
              GOTO 30
            END IF
C
            sep = scale/est
          END IF
        END IF
 40     CONTINUE
C
C
C     Store the output eigenvalues in WR and WI.
C
        DO k=1,n
          wr(k) = t(k, k)
          wi(k) = zero
        ENDDO
        DO k=1,n-1
          IF (t(k+1, k) .NE. zero) THEN
            IF (t(k, k+1) .GE. 0.) THEN
              abs1 = t(k, k+1)
            ELSE
              abs1 = -t(k, k+1)
            END IF
            IF (t(k+1, k) .GE. 0.) THEN
              abs2 = t(k+1, k)
            ELSE
              abs2 = -t(k+1, k)
            END IF
            result10 = SQRT(abs1)
            result2 = SQRT(abs2)
            wi(k) = result10*result2
            wi(k+1) = -wi(k)
          END IF
        ENDDO
        DO nd=1,nbdirs
          workd(nd, 1) = 0.D0
        ENDDO
C
        work(1) = lwmin
        iwork(1) = liwmin
C
        RETURN
      END IF
      END

!
! Copyright (C) 2006-2014 Houtan Bastani and Luca Guerrieri
!
!
! This free software: you can redistribute it and/or modify
! it under the terms of the GNU General Public License as published by
! the Free Software Foundation, either version 3 of the License, or
! (at your option) any later version.
!
! It is distributed in the hope that it will be useful,
! but WITHOUT ANY WARRANTY; without even the implied warranty of
! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
! GNU General Public License for more details.
!
! You should have received a copy of the GNU General Public License
! along with Dynare.  If not, see <http://www.gnu.org/licenses/>.
!

C        Generated by TAPENADE     (INRIA, Tropics team)
C  Tapenade - Version 2.2 (r1239) - Wed 28 Jun 2006 04:59:55 PM CEST
C
C  Differentiation of dlaqr3 in forward (tangent) mode: (multi-directional mode)
C   variations  of output variables: h wv t v z work si sr
C   with respect to input variables: h wv t v z work si sr
      SUBROUTINE DLAQR3_DV(wantt, wantz, n, ktop, kbot, nw, h, hd, ldh,
     +                     iloz, ihiz, z, zd, ldz, ns, nd, sr, srd, si,
     +                     sid, v, vd, ldv, nh, t, td, ldt, nv, wv, wvd
     +                     , ldwv, work, workd, lwork, nbdirs)
      USE DIFFSIZES
      IMPLICIT NONE
C
C     ==== End of DLAQR3 ====
C
      INTEGER ihiz, iloz, kbot, ktop, lwork, n, nd, nh, ns, nv, nw
      INTEGER ldh, ldt, ldv, ldwv, ldz, nbdirs
      DOUBLE PRECISION h(ldh, *), hd(nbdirsmax, ldh, *), si(*), sid(
     +                 nbdirsmax, *), sr(*), srd(nbdirsmax, *), t(ldt, *
     +                 ), td(nbdirsmax, ldt, *), v(ldv, *), vd(nbdirsmax
     +                 , ldv, *), work(*), workd(nbdirsmax, *), wv(ldwv
     +                 , *), wvd(nbdirsmax, ldwv, *), z(ldz, *), zd(
     +                 nbdirsmax, ldz, *)
      LOGICAL wantt, wantz
      DOUBLE PRECISION one, zero
      PARAMETER (one=1.0d0, zero=0.0d0)
      LOGICAL bulge, sorted
      DOUBLE PRECISION DLAMCH
      INTEGER arg1, arg2, arg3, i, ifst, ILAENV, ilst, info, infqr, j,
     +        jw, k, kcol, kend, kln, krow, kwtop, ltop, lwk1, lwk2,
     +        lwk3, lwkopt, max2, nd0, nmin, x1
      DOUBLE PRECISION abs10, abs11, abs12, abs3, abs4, abs5, abs6, abs7
     +                 , abs8, abs9, result1, result2
      DOUBLE PRECISION aa, aad(nbdirsmax), abs1, abs2, bb, bbd(nbdirsmax
     +                 ), beta, betad(nbdirsmax), cc, ccd(nbdirsmax), cs
     +                 , csd(nbdirsmax), dd, ddd(nbdirsmax), evi, evk,
     +                 foo, max1, max3, max4, max5, s, safmax, safmin,
     +                 sd(nbdirsmax), smlnum, sn, snd(nbdirsmax), tau,
     +                 taud(nbdirsmax), ulp, x2, y1, y2
      EXTERNAL DLABAD, ILAENV, DLAMCH
      INTRINSIC MAX, ABS, INT, DBLE, MIN, SQRT
      IF (nw .GT. kbot - ktop + 1) THEN
        jw = kbot - ktop + 1
      ELSE
        jw = nw
      END IF
      IF (jw .LE. 2) THEN
        lwkopt = 1
      ELSE
C
C        ==== Workspace query call to DGEHRD ====
C
        arg1 = jw - 1
        arg2 = -1
        CALL DGEHRD_DV(jw, 1, arg1, t, td, ldt, work, workd, work, workd
     +                 , arg2, info, nbdirs)
        lwk1 = INT(work(1))
C
C        ==== Workspace query call to DORGHR ====
C
        arg1 = jw - 1
        arg2 = -1
        CALL DORGHR_DV(jw, 1, arg1, t, td, ldt, work, workd, work, workd
     +                 , arg2, info, nbdirs)
        lwk2 = INT(work(1))
C
C        ==== Workspace query call to DLAQR4 ====
C
        arg1 = -1
        CALL DLAQR4_DV(.true., .true., jw, 1, jw, t, td, ldt, sr, srd,
     +                 si, sid, 1, jw, v, vd, ldv, work, workd, arg1,
     +                 infqr, nbdirs)
        lwk3 = INT(work(1))
        IF (lwk1 .LT. lwk2) THEN
          max2 = lwk2
        ELSE
          max2 = lwk1
        END IF
        x1 = jw + max2
        IF (x1 .LT. lwk3) THEN
          lwkopt = lwk3
        ELSE
          lwkopt = x1
        END IF
      END IF
C
C     ==== Quick return in case of workspace query. ====
C
      IF (lwork .EQ. -1) THEN
        DO nd0=1,nbdirs
          workd(nd0, 1) = 0.D0
        ENDDO
        work(1) = DBLE(lwkopt)
        RETURN
      ELSE
C
C     ==== Nothing to do ...
C     ... for an empty active block ... ====
        ns = 0
        nd = 0
        IF (ktop .GT. kbot) THEN
          RETURN
        ELSE IF (nw .LT. 1) THEN
C     ... nor for an empty deflation window. ====
          RETURN
        ELSE
C
C     ==== Machine constants ====
C
          safmin = DLAMCH('SAFE MINIMUM')
          safmax = one/safmin
          CALL DLABAD(safmin, safmax)
          ulp = DLAMCH('PRECISION')
          smlnum = safmin*(DBLE(n)/ulp)
          IF (nw .GT. kbot - ktop + 1) THEN
            jw = kbot - ktop + 1
          ELSE
            jw = nw
          END IF
          kwtop = kbot - jw + 1
          IF (kwtop .EQ. ktop) THEN
            s = zero
            DO nd0=1,nbdirs
              sd(nd0) = 0.D0
            ENDDO
          ELSE
            DO nd0=1,nbdirs
              sd(nd0) = hd(nd0, kwtop, kwtop-1)
            ENDDO
            s = h(kwtop, kwtop-1)
          END IF
C
          IF (kbot .EQ. kwtop) THEN
            DO nd0=1,nbdirs
              srd(nd0, kwtop) = hd(nd0, kwtop, kwtop)
              sid(nd0, kwtop) = 0.D0
            ENDDO
C
C        ==== 1-by-1 deflation window: not much to do ====
C
            sr(kwtop) = h(kwtop, kwtop)
            si(kwtop) = zero
            ns = 1
            nd = 0
            IF (s .GE. 0.) THEN
              abs1 = s
            ELSE
              abs1 = -s
            END IF
            IF (h(kwtop, kwtop) .GE. 0.) THEN
              abs9 = h(kwtop, kwtop)
            ELSE
              abs9 = -h(kwtop, kwtop)
            END IF
            y2 = ulp*abs9
            IF (smlnum .LT. y2) THEN
              max3 = y2
            ELSE
              max3 = smlnum
            END IF
            IF (abs1 .LE. max3) THEN
              ns = 0
              nd = 1
              IF (kwtop .GT. ktop) THEN
                DO nd0=1,nbdirs
                  hd(nd0, kwtop, kwtop-1) = 0.D0
                ENDDO
                h(kwtop, kwtop-1) = zero
              END IF
            END IF
            RETURN
          ELSE
C
C     ==== Convert to spike-triangular form.  (In case of a
C     .    rare QR failure, this routine continues to do
C     .    aggressive early deflation using that part of
C     .    the deflation window that converged using INFQR
C     .    here and there to keep track.) ====
C
            CALL DLACPY_DV('U', jw, jw, h(kwtop, kwtop), hd(1, kwtop,
     +                     kwtop), ldh, t, td, ldt, nbdirs)
            arg1 = jw - 1
            arg2 = ldh + 1
            arg3 = ldt + 1
            CALL DCOPY_DV(arg1, h(kwtop+1, kwtop), hd(1, kwtop+1, kwtop)
     +                    , arg2, t(2, 1), td(1, 2, 1), arg3, nbdirs)
C
            CALL DLASET_DV('A', jw, jw, zero, one, v, vd, ldv, nbdirs)
            nmin = ILAENV(12, 'DLAQR3', 'SV', jw, 1, jw, lwork)
            IF (jw .GT. nmin) THEN
              CALL DLAQR4_DV(.true., .true., jw, 1, jw, t, td, ldt, sr(
     +                       kwtop), srd(1, kwtop), si(kwtop), sid(1,
     +                       kwtop), 1, jw, v, vd, ldv, work, workd,
     +                       lwork, infqr, nbdirs)
            ELSE
              CALL DLAHQR_DV(.true., .true., jw, 1, jw, t, td, ldt, sr(
     +                       kwtop), srd(1, kwtop), si(kwtop), sid(1,
     +                       kwtop), 1, jw, v, vd, ldv, infqr, nbdirs)
            END IF
C
C     ==== DTREXC needs a clean margin near the diagonal ====
C
            DO j=1,jw-3
              DO nd0=1,nbdirs
                td(nd0, j+2, j) = 0.D0
                td(nd0, j+3, j) = 0.D0
              ENDDO
              t(j+2, j) = zero
              t(j+3, j) = zero
            ENDDO
            IF (jw .GT. 2) THEN
              DO nd0=1,nbdirs
                td(nd0, jw, jw-2) = 0.D0
              ENDDO
              t(jw, jw-2) = zero
            END IF
C
C     ==== Deflation detection loop ====
C
            ns = jw
            ilst = infqr + 1
 20         IF (ilst .LE. ns) THEN
              IF (ns .EQ. 1) THEN
                bulge = .false.
              ELSE
                bulge = t(ns, ns-1) .NE. zero
              END IF
C
C        ==== Small spike tip test for deflation ====
C
              IF (.NOT.bulge) THEN
                IF (t(ns, ns) .GE. 0.) THEN
                  foo = t(ns, ns)
                ELSE
                  foo = -t(ns, ns)
                END IF
                IF (foo .EQ. zero) THEN
                  IF (s .GE. 0.) THEN
                    foo = s
                  ELSE
                    foo = -s
                  END IF
                END IF
                IF (s*v(1, ns) .GE. 0.) THEN
                  abs2 = s*v(1, ns)
                ELSE
                  abs2 = -(s*v(1, ns))
                END IF
                IF (smlnum .LT. ulp*foo) THEN
                  max4 = ulp*foo
                ELSE
                  max4 = smlnum
                END IF
                IF (abs2 .LE. max4) THEN
C
C              ==== Deflatable ====
C
                  ns = ns - 1
                ELSE
C
C              ==== Undeflatable.   Move it up out of the way.
C              .    (DTREXC can not fail in this case.) ====
C
                  ifst = ns
                  CALL DTREXC_DV('V', jw, t, td, ldt, v, vd, ldv, ifst,
     +                           ilst, work, workd, info, nbdirs)
                  ilst = ilst + 1
                END IF
              ELSE
                IF (t(ns, ns) .GE. 0.) THEN
                  abs3 = t(ns, ns)
                ELSE
                  abs3 = -t(ns, ns)
                END IF
                IF (t(ns, ns-1) .GE. 0.) THEN
                  abs6 = t(ns, ns-1)
                ELSE
                  abs6 = -t(ns, ns-1)
                END IF
                IF (t(ns-1, ns) .GE. 0.) THEN
                  abs10 = t(ns-1, ns)
                ELSE
                  abs10 = -t(ns-1, ns)
                END IF
C
C           ==== Complex conjugate pair ====
C
                result1 = SQRT(abs6)
                result2 = SQRT(abs10)
                foo = abs3 + result1*result2
                IF (foo .EQ. zero) THEN
                  IF (s .GE. 0.) THEN
                    foo = s
                  ELSE
                    foo = -s
                  END IF
                END IF
                IF (s*v(1, ns) .GE. 0.) THEN
                  x2 = s*v(1, ns)
                ELSE
                  x2 = -(s*v(1, ns))
                END IF
                IF (s*v(1, ns-1) .GE. 0.) THEN
                  y1 = s*v(1, ns-1)
                ELSE
                  y1 = -(s*v(1, ns-1))
                END IF
                IF (x2 .LT. y1) THEN
                  max1 = y1
                ELSE
                  max1 = x2
                END IF
                IF (smlnum .LT. ulp*foo) THEN
                  max5 = ulp*foo
                ELSE
                  max5 = smlnum
                END IF
                IF (max1 .LE. max5) THEN
C
C              ==== Deflatable ====
C
                  ns = ns - 2
                ELSE
C
C              ==== Undflatable. Move them up out of the way.
C              .    Fortunately, DTREXC does the right thing with
C              .    ILST in case of a rare exchange failure. ====
C
                  ifst = ns
                  CALL DTREXC_DV('V', jw, t, td, ldt, v, vd, ldv, ifst,
     +                           ilst, work, workd, info, nbdirs)
                  ilst = ilst + 2
                END IF
              END IF
              GOTO 20
            END IF
C
C        ==== End deflation detection loop ====
C
C
C        ==== Return to Hessenberg form ====
C
            IF (ns .EQ. 0) THEN
              s = zero
              DO nd0=1,nbdirs
                sd(nd0) = 0.D0
              ENDDO
            END IF
C
            IF (ns .LT. jw) THEN
C
C        ==== sorting diagonal blocks of T improves accuracy for
C        .    graded matrices.  Bubble sort deals well with
C        .    exchange failures. ====
C
              sorted = .false.
              i = ns + 1
 30           IF (.NOT.sorted) THEN
                sorted = .true.
C
                kend = i - 1
                i = infqr + 1
                IF (i .EQ. ns) THEN
                  k = i + 1
                ELSE IF (t(i+1, i) .EQ. zero) THEN
                  k = i + 1
                ELSE
                  k = i + 2
                END IF
 40             IF (k .LE. kend) THEN
                  IF (k .EQ. i + 1) THEN
                    IF (t(i, i) .GE. 0.) THEN
                      evi = t(i, i)
                    ELSE
                      evi = -t(i, i)
                    END IF
                  ELSE
                    IF (t(i, i) .GE. 0.) THEN
                      abs4 = t(i, i)
                    ELSE
                      abs4 = -t(i, i)
                    END IF
                    IF (t(i+1, i) .GE. 0.) THEN
                      abs7 = t(i+1, i)
                    ELSE
                      abs7 = -t(i+1, i)
                    END IF
                    IF (t(i, i+1) .GE. 0.) THEN
                      abs11 = t(i, i+1)
                    ELSE
                      abs11 = -t(i, i+1)
                    END IF
                    result1 = SQRT(abs7)
                    result2 = SQRT(abs11)
                    evi = abs4 + result1*result2
                  END IF
C
                  IF (k .EQ. kend) THEN
                    IF (t(k, k) .GE. 0.) THEN
                      evk = t(k, k)
                    ELSE
                      evk = -t(k, k)
                    END IF
                  ELSE IF (t(k+1, k) .EQ. zero) THEN
                    IF (t(k, k) .GE. 0.) THEN
                      evk = t(k, k)
                    ELSE
                      evk = -t(k, k)
                    END IF
                  ELSE
                    IF (t(k, k) .GE. 0.) THEN
                      abs5 = t(k, k)
                    ELSE
                      abs5 = -t(k, k)
                    END IF
                    IF (t(k+1, k) .GE. 0.) THEN
                      abs8 = t(k+1, k)
                    ELSE
                      abs8 = -t(k+1, k)
                    END IF
                    IF (t(k, k+1) .GE. 0.) THEN
                      abs12 = t(k, k+1)
                    ELSE
                      abs12 = -t(k, k+1)
                    END IF
                    result1 = SQRT(abs8)
                    result2 = SQRT(abs12)
                    evk = abs5 + result1*result2
                  END IF
C
                  IF (evi .GE. evk) THEN
                    i = k
                  ELSE
                    sorted = .false.
                    ifst = i
                    ilst = k
                    CALL DTREXC_DV('V', jw, t, td, ldt, v, vd, ldv, ifst
     +                             , ilst, work, workd, info, nbdirs)
                    IF (info .EQ. 0) THEN
                      i = ilst
                    ELSE
                      i = k
                    END IF
                  END IF
                  IF (i .EQ. kend) THEN
                    k = i + 1
                  ELSE IF (t(i+1, i) .EQ. zero) THEN
                    k = i + 1
                  ELSE
                    k = i + 2
                  END IF
                  GOTO 40
                ELSE
                  GOTO 30
                END IF
              END IF
            END IF
C
C     ==== Restore shift/eigenvalue array from T ====
C
            i = jw
 60         IF (i .GE. infqr + 1) THEN
              IF (i .EQ. infqr + 1) THEN
                DO nd0=1,nbdirs
                  srd(nd0, kwtop+i-1) = td(nd0, i, i)
                  sid(nd0, kwtop+i-1) = 0.D0
                ENDDO
                sr(kwtop+i-1) = t(i, i)
                si(kwtop+i-1) = zero
                i = i - 1
              ELSE IF (t(i, i-1) .EQ. zero) THEN
                DO nd0=1,nbdirs
                  srd(nd0, kwtop+i-1) = td(nd0, i, i)
                  sid(nd0, kwtop+i-1) = 0.D0
                ENDDO
                sr(kwtop+i-1) = t(i, i)
                si(kwtop+i-1) = zero
                i = i - 1
              ELSE
                DO nd0=1,nbdirs
                  aad(nd0) = td(nd0, i-1, i-1)
                  ddd(nd0) = td(nd0, i, i)
                  bbd(nd0) = td(nd0, i-1, i)
                  ccd(nd0) = td(nd0, i, i-1)
                ENDDO
                aa = t(i-1, i-1)
                cc = t(i, i-1)
                bb = t(i-1, i)
                dd = t(i, i)
                CALL DLANV2_DV(aa, aad, bb, bbd, cc, ccd, dd, ddd, sr(
     +                         kwtop+i-2), srd(1, kwtop+i-2), si(kwtop+i
     +                         -2), sid(1, kwtop+i-2), sr(kwtop+i-1),
     +                         srd(1, kwtop+i-1), si(kwtop+i-1), sid(1,
     +                         kwtop+i-1), cs, csd, sn, snd, nbdirs)
                i = i - 2
              END IF
              GOTO 60
            END IF
C
            IF (ns .LT. jw .OR. s .EQ. zero) THEN
              IF (ns .GT. 1 .AND. s .NE. zero) THEN
C
C           ==== Reflect spike back into lower triangle ====
C
                CALL DCOPY_DV(ns, v, vd, ldv, work, workd, 1, nbdirs)
                DO nd0=1,nbdirs
                  betad(nd0) = workd(nd0, 1)
                ENDDO
                beta = work(1)
                CALL DLARFG_DV(ns, beta, betad, work(2), workd(1, 2), 1
     +                         , tau, taud, nbdirs)
                DO nd0=1,nbdirs
                  workd(nd0, 1) = 0.D0
                ENDDO
                work(1) = one
C
                arg1 = jw - 2
                arg2 = jw - 2
                CALL DLASET_DV('L', arg1, arg2, zero, zero, t(3, 1), td(
     +                         1, 3, 1), ldt, nbdirs)
C
                CALL DLARF_DV('L', ns, jw, work, workd, 1, tau, taud, t
     +                        , td, ldt, work(jw+1), workd(1, jw+1),
     +                        nbdirs)
                CALL DLARF_DV('R', ns, ns, work, workd, 1, tau, taud, t
     +                        , td, ldt, work(jw+1), workd(1, jw+1),
     +                        nbdirs)
                CALL DLARF_DV('R', jw, ns, work, workd, 1, tau, taud, v
     +                        , vd, ldv, work(jw+1), workd(1, jw+1),
     +                        nbdirs)
C
                arg1 = lwork - jw
                CALL DGEHRD_DV(jw, 1, ns, t, td, ldt, work, workd, work(
     +                         jw+1), workd(1, jw+1), arg1, info, nbdirs
     +                        )
              END IF
C
C        ==== Copy updated reduced window into place ====
C
              IF (kwtop .GT. 1) THEN
                DO nd0=1,nbdirs
                  hd(nd0, kwtop, kwtop-1) = sd(nd0)*v(1, 1) + s*vd(nd0,
     +              1, 1)
                ENDDO
                h(kwtop, kwtop-1) = s*v(1, 1)
              END IF
              CALL DLACPY_DV('U', jw, jw, t, td, ldt, h(kwtop, kwtop),
     +                       hd(1, kwtop, kwtop), ldh, nbdirs)
              arg1 = jw - 1
              arg2 = ldt + 1
              arg3 = ldh + 1
              CALL DCOPY_DV(arg1, t(2, 1), td(1, 2, 1), arg2, h(kwtop+1
     +                      , kwtop), hd(1, kwtop+1, kwtop), arg3,
     +                      nbdirs)
C
C        ==== Accumulate orthogonal matrix in order update
C        .    H and Z, if requested.  (A modified version
C        .    of  DORGHR that accumulates block Householder
C        .    transformations into V directly might be
C        .    marginally more efficient than the following.) ====
C
              IF (ns .GT. 1 .AND. s .NE. zero) THEN
                arg1 = lwork - jw
                CALL DORGHR_DV(jw, 1, ns, t, td, ldt, work, workd, work(
     +                         jw+1), workd(1, jw+1), arg1, info, nbdirs
     +                        )
                CALL DGEMM_DV('N', 'N', jw, ns, ns, one, v, vd, ldv, t,
     +                        td, ldt, zero, wv, wvd, ldwv, nbdirs)
                CALL DLACPY_DV('A', jw, ns, wv, wvd, ldwv, v, vd, ldv,
     +                         nbdirs)
              END IF
C
C        ==== Update vertical slab in H ====
C
              IF (wantt) THEN
                ltop = 1
              ELSE
                ltop = ktop
              END IF
              DO krow=ltop,kwtop-1,nv
                IF (nv .GT. kwtop - krow) THEN
                  kln = kwtop - krow
                ELSE
                  kln = nv
                END IF
                CALL DGEMM_DV('N', 'N', kln, jw, jw, one, h(krow, kwtop)
     +                        , hd(1, krow, kwtop), ldh, v, vd, ldv,
     +                        zero, wv, wvd, ldwv, nbdirs)
                CALL DLACPY_DV('A', kln, jw, wv, wvd, ldwv, h(krow,
     +                         kwtop), hd(1, krow, kwtop), ldh, nbdirs)
              ENDDO
C
C        ==== Update horizontal slab in H ====
C
              IF (wantt) THEN
                DO kcol=kbot+1,n,nh
                  IF (nh .GT. n - kcol + 1) THEN
                    kln = n - kcol + 1
                  ELSE
                    kln = nh
                  END IF
                  CALL DGEMM_DV('C', 'N', jw, kln, jw, one, v, vd, ldv,
     +                          h(kwtop, kcol), hd(1, kwtop, kcol), ldh
     +                          , zero, t, td, ldt, nbdirs)
                  CALL DLACPY_DV('A', jw, kln, t, td, ldt, h(kwtop, kcol
     +                           ), hd(1, kwtop, kcol), ldh, nbdirs)
                ENDDO
              END IF
C
C        ==== Update vertical slab in Z ====
C
              IF (wantz) THEN
                DO krow=iloz,ihiz,nv
                  IF (nv .GT. ihiz - krow + 1) THEN
                    kln = ihiz - krow + 1
                  ELSE
                    kln = nv
                  END IF
                  CALL DGEMM_DV('N', 'N', kln, jw, jw, one, z(krow,
     +                          kwtop), zd(1, krow, kwtop), ldz, v, vd,
     +                          ldv, zero, wv, wvd, ldwv, nbdirs)
                  CALL DLACPY_DV('A', kln, jw, wv, wvd, ldwv, z(krow,
     +                           kwtop), zd(1, krow, kwtop), ldz, nbdirs
     +                          )
                ENDDO
              END IF
            END IF
C
C     ==== Return the number of deflations ... ====
C
            nd = jw - ns
C
C     ==== ... and the number of shifts. (Subtracting
C     .    INFQR from the spike length takes care
C     .    of the case of a rare QR failure while
C     .    calculating eigenvalues of the deflation
C     .    window.)  ====
C
            ns = ns - infqr
            DO nd0=1,nbdirs
              workd(nd0, 1) = 0.D0
            ENDDO
C
C      ==== Return optimal workspace. ====
C
            work(1) = DBLE(lwkopt)
          END IF
        END IF
      END IF
      END

!
! Copyright (C) 2006-2014 Houtan Bastani and Luca Guerrieri
!
!
! This free software: you can redistribute it and/or modify
! it under the terms of the GNU General Public License as published by
! the Free Software Foundation, either version 3 of the License, or
! (at your option) any later version.
!
! It is distributed in the hope that it will be useful,
! but WITHOUT ANY WARRANTY; without even the implied warranty of
! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
! GNU General Public License for more details.
!
! You should have received a copy of the GNU General Public License
! along with Dynare.  If not, see <http://www.gnu.org/licenses/>.
!

C        Generated by TAPENADE     (INRIA, Tropics team)
C  Tapenade - Version 2.2 (r1239) - Wed 28 Jun 2006 04:59:55 PM CEST
C
C  Differentiation of dorg2r in forward (tangent) mode: (multi-directional mode)
C   variations  of output variables: work a
C   with respect to input variables: tau work a
      SUBROUTINE DORG2R_DV(m, n, k, a, ad, lda, tau, taud, work, workd,
     +                     info, nbdirs)
      USE DIFFSIZES
      IMPLICIT NONE
C
C     End of DORG2R
C
      INTEGER info, k, m, n
      INTEGER lda, nbdirs
      DOUBLE PRECISION a(lda, *), ad(nbdirsmax, lda, *), tau(*), taud(
     +                 nbdirsmax, *), work(*), workd(nbdirsmax, *)
      DOUBLE PRECISION one, zero
      PARAMETER (one=1.0d+0, zero=0.0d+0)
      INTEGER arg1, arg2, i, j, l, max1, nd
      DOUBLE PRECISION arg20, arg20d(nbdirsmax)
      INTRINSIC MAX
      EXTERNAL XERBLA
C
C  -- LAPACK routine (version 3.1) --
C     Univ. of Tennessee, Univ. of California Berkeley and NAG Ltd..
C     November 2006
C
C     .. Scalar Arguments ..
C     ..
C     .. Array Arguments ..
C     ..
C
C  Purpose
C  =======
C
C  DORG2R generates an m by n real matrix Q with orthonormal columns,
C  which is defined as the first n columns of a product of k elementary
C  reflectors of order m
C
C        Q  =  H(1) H(2) . . . H(k)
C
C  as returned by DGEQRF.
C
C  Arguments
C  =========
C
C  M       (input) INTEGER
C          The number of rows of the matrix Q. M >= 0.
C
C  N       (input) INTEGER
C          The number of columns of the matrix Q. M >= N >= 0.
C
C  K       (input) INTEGER
C          The number of elementary reflectors whose product defines the
C          matrix Q. N >= K >= 0.
C
C  A       (input/output) DOUBLE PRECISION array, dimension (LDA,N)
C          On entry, the i-th column must contain the vector which
C          defines the elementary reflector H(i), for i = 1,2,...,k, as
C          returned by DGEQRF in the first k columns of its array
C          argument A.
C          On exit, the m-by-n matrix Q.
C
C  LDA     (input) INTEGER
C          The first dimension of the array A. LDA >= max(1,M).
C
C  TAU     (input) DOUBLE PRECISION array, dimension (K)
C          TAU(i) must contain the scalar factor of the elementary
C          reflector H(i), as returned by DGEQRF.
C
C  WORK    (workspace) DOUBLE PRECISION array, dimension (N)
C
C  INFO    (output) INTEGER
C          = 0: successful exit
C          < 0: if INFO = -i, the i-th argument has an illegal value
C
C  =====================================================================
C
C     .. Parameters ..
C     ..
C     .. Local Scalars ..
C     ..
C     .. External Subroutines ..
C     ..
C     .. Intrinsic Functions ..
C     ..
C     .. Executable Statements ..
C
C     Test the input arguments
C
      info = 0
      IF (m .LT. 0) THEN
        info = -1
      ELSE IF (n .LT. 0 .OR. n .GT. m) THEN
        info = -2
      ELSE IF (k .LT. 0 .OR. k .GT. n) THEN
        info = -3
      ELSE
        IF (1 .LT. m) THEN
          max1 = m
        ELSE
          max1 = 1
        END IF
        IF (lda .LT. max1) info = -5
      END IF
      IF (info .NE. 0) THEN
        arg1 = -info
        CALL XERBLA('DORG2R', arg1)
        RETURN
      ELSE IF (n .LE. 0) THEN
C
C     Quick return if possible
C
        RETURN
      ELSE
C
C     Initialise columns k+1:n to columns of the unit matrix
C
        DO j=k+1,n
          DO l=1,m
            DO nd=1,nbdirs
              ad(nd, l, j) = 0.D0
            ENDDO
            a(l, j) = zero
          ENDDO
          DO nd=1,nbdirs
            ad(nd, j, j) = 0.D0
          ENDDO
          a(j, j) = one
        ENDDO
C
        DO i=k,1,-1
C
C        Apply H(i) to A(i:m,i:n) from the left
C
          IF (i .LT. n) THEN
            DO nd=1,nbdirs
              ad(nd, i, i) = 0.D0
            ENDDO
            a(i, i) = one
            arg1 = m - i + 1
            arg2 = n - i
            CALL DLARF_DV('Left', arg1, arg2, a(i, i), ad(1, i, i), 1,
     +                    tau(i), taud(1, i), a(i, i+1), ad(1, i, i+1),
     +                    lda, work, workd, nbdirs)
          END IF
          IF (i .LT. m) THEN
            arg1 = m - i
            DO nd=1,nbdirs
              arg20d(nd) = -taud(nd, i)
            ENDDO
            arg20 = -tau(i)
            CALL DSCAL_DV(arg1, arg20, arg20d, a(i+1, i), ad(1, i+1, i)
     +                    , 1, nbdirs)
          END IF
          DO nd=1,nbdirs
            ad(nd, i, i) = -taud(nd, i)
          ENDDO
          a(i, i) = one - tau(i)
C
C        Set A(1:i-1,i) to zero
C
          DO l=1,i-1
            DO nd=1,nbdirs
              ad(nd, l, i) = 0.D0
            ENDDO
            a(l, i) = zero
          ENDDO
        ENDDO
        RETURN
      END IF
      END

!
! Copyright (C) 2006-2014 Houtan Bastani and Luca Guerrieri
!
!
! This free software: you can redistribute it and/or modify
! it under the terms of the GNU General Public License as published by
! the Free Software Foundation, either version 3 of the License, or
! (at your option) any later version.
!
! It is distributed in the hope that it will be useful,
! but WITHOUT ANY WARRANTY; without even the implied warranty of
! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
! GNU General Public License for more details.
!
! You should have received a copy of the GNU General Public License
! along with Dynare.  If not, see <http://www.gnu.org/licenses/>.
!

C        Generated by TAPENADE     (INRIA, Tropics team)
C  Tapenade - Version 2.2 (r1239) - Wed 28 Jun 2006 04:59:55 PM CEST
C
C  Differentiation of dlacn2 in forward (tangent) mode: (multi-directional mode)
C   variations  of output variables: v x
C   with respect to input variables: v x
      SUBROUTINE DLACN2_DV(n, v, vd, x, xd, isgn, est, kase, isave,
     +                     nbdirs)
      USE DIFFSIZES
      IMPLICIT NONE
C
C     End of DLACN2
C
      DOUBLE PRECISION est
      INTEGER isave(3), isgn(*), kase, n
      INTEGER nbdirs
      DOUBLE PRECISION v(*), vd(nbdirsmax, *), x(*), xd(nbdirsmax, *)
      INTEGER itmax
      PARAMETER (itmax=5)
      DOUBLE PRECISION one, two, zero
      PARAMETER (one=1.0d+0, two=2.0d+0, zero=0.0d+0)
      DOUBLE PRECISION abs1
      DOUBLE PRECISION altsgn, estold, temp
      DOUBLE PRECISION arg1
      DOUBLE PRECISION DASUM, result1
      INTEGER arg10, arg2, i, IDAMAX, jlast, nd
      INTRINSIC SIGN, ABS, NINT, DBLE
C
C  -- LAPACK auxiliary routine (version 3.1) --
C     Univ. of Tennessee, Univ. of California Berkeley and NAG Ltd..
C     November 2006
C
C     .. Scalar Arguments ..
C     ..
C     .. Array Arguments ..
C     ..
C
C  Purpose
C  =======
C
C  DLACN2 estimates the 1-norm of a square, real matrix A.
C  Reverse communication is used for evaluating matrix-vector products.
C
C  Arguments
C  =========
C
C  N      (input) INTEGER
C         The order of the matrix.  N >= 1.
C
C  V      (workspace) DOUBLE PRECISION array, dimension (N)
C         On the final return, V = A*W,  where  EST = norm(V)/norm(W)
C         (W is not returned).
C
C  X      (input/output) DOUBLE PRECISION array, dimension (N)
C         On an intermediate return, X should be overwritten by
C               A * X,   if KASE=1,
C               A' * X,  if KASE=2,
C         and DLACN2 must be re-called with all the other parameters
C         unchanged.
C
C  ISGN   (workspace) INTEGER array, dimension (N)
C
C  EST    (input/output) DOUBLE PRECISION
C         On entry with KASE = 1 or 2 and ISAVE(1) = 3, EST should be
C         unchanged from the previous call to DLACN2.
C         On exit, EST is an estimate (a lower bound) for norm(A).
C
C  KASE   (input/output) INTEGER
C         On the initial call to DLACN2, KASE should be 0.
C         On an intermediate return, KASE will be 1 or 2, indicating
C         whether X should be overwritten by A * X  or A' * X.
C         On the final return from DLACN2, KASE will again be 0.
C
C  ISAVE  (input/output) INTEGER array, dimension (3)
C         ISAVE is used to save variables between calls to DLACN2
C
C  Further Details
C  ======= =======
C
C  Contributed by Nick Higham, University of Manchester.
C  Originally named SONEST, dated March 16, 1988.
C
C  Reference: N.J. Higham, "FORTRAN codes for estimating the one-norm of
C  a real or complex matrix, with applications to condition estimation",
C  ACM Trans. Math. Soft., vol. 14, no. 4, pp. 381-396, December 1988.
C
C  This is a thread safe version of DLACON, which uses the array ISAVE
C  in place of a SAVE statement, as follows:
C
C     DLACON     DLACN2
C      JUMP     ISAVE(1)
C      J        ISAVE(2)
C      ITER     ISAVE(3)
C
C  =====================================================================
C
C     .. Parameters ..
C     ..
C     .. Local Scalars ..
C     ..
C     .. External Functions ..
C     ..
C     .. External Subroutines ..
C     ..
C     .. Intrinsic Functions ..
C     ..
C     .. Executable Statements ..
C
      IF (kase .EQ. 0) THEN
        DO i=1,n
          DO nd=1,nbdirs
            xd(nd, i) = 0.D0
          ENDDO
          x(i) = one/DBLE(n)
        ENDDO
        kase = 1
        isave(1) = 1
        RETURN
      ELSE
C
        GOTO (20, 40, 70, 110, 140) isave(1)
        GOTO 20
C
C     ................ ENTRY   (ISAVE( 1 ) = 1)
C     FIRST ITERATION.  X HAS BEEN OVERWRITTEN BY A*X.
C
 20     IF (n .EQ. 1) THEN
          DO nd=1,nbdirs
            vd(nd, 1) = xd(nd, 1)
          ENDDO
          v(1) = x(1)
          IF (v(1) .GE. 0.) THEN
            est = v(1)
          ELSE
            est = -v(1)
          END IF
          GOTO 150
        ELSE
C        ... QUIT
          est = DASUM(n, x, 1)
C
          DO i=1,n
            DO nd=1,nbdirs
              xd(nd, i) = 0.D0
            ENDDO
            x(i) = SIGN(one, x(i))
            isgn(i) = NINT(x(i))
          ENDDO
          kase = 2
          isave(1) = 2
          RETURN
        END IF
C
C     ................ ENTRY   (ISAVE( 1 ) = 2)
C     FIRST ITERATION.  X HAS BEEN OVERWRITTEN BY TRANSPOSE(A)*X.
C
 40     isave(2) = IDAMAX(n, x, 1)
        isave(3) = 2
        GOTO 50
C
C     ................ ENTRY   (ISAVE( 1 ) = 3)
C     X HAS BEEN OVERWRITTEN BY A*X.
C
 70     CALL DCOPY_DV(n, x, xd, 1, v, vd, 1, nbdirs)
        estold = est
        est = DASUM(n, v, 1)
        DO i=1,n
          arg1 = SIGN(one, x(i))
          IF (NINT(arg1) .NE. isgn(i)) GOTO 90
        ENDDO
        GOTO 120
C     REPEATED SIGN VECTOR DETECTED, HENCE ALGORITHM HAS CONVERGED.
C
C     TEST FOR CYCLING.
 90     IF (est .LE. estold) THEN
          GOTO 120
        ELSE
C
          DO i=1,n
            DO nd=1,nbdirs
              xd(nd, i) = 0.D0
            ENDDO
            x(i) = SIGN(one, x(i))
            isgn(i) = NINT(x(i))
          ENDDO
          kase = 2
          isave(1) = 4
          RETURN
        END IF
C
C     ................ ENTRY   (ISAVE( 1 ) = 4)
C     X HAS BEEN OVERWRITTEN BY TRANSPOSE(A)*X.
C
 110    jlast = isave(2)
        isave(2) = IDAMAX(n, x, 1)
        IF (x(isave(2)) .GE. 0.) THEN
          abs1 = x(isave(2))
        ELSE
          abs1 = -x(isave(2))
        END IF
        IF (x(jlast) .NE. abs1 .AND. isave(3) .LT. itmax) THEN
          isave(3) = isave(3) + 1
          GOTO 50
        END IF
C
C     ITERATION COMPLETE.  FINAL STAGE.
C
 120    altsgn = one
        DO i=1,n
          arg10 = i - 1
          arg2 = n - 1
          DO nd=1,nbdirs
            xd(nd, i) = 0.D0
          ENDDO
          x(i) = altsgn*(one+DBLE(arg10)/DBLE(arg2))
          altsgn = -altsgn
        ENDDO
        kase = 1
        isave(1) = 5
        RETURN
 50     CONTINUE
C
C     MAIN LOOP - ITERATIONS 2,3,...,ITMAX.
C
        DO i=1,n
          DO nd=1,nbdirs
            xd(nd, i) = 0.D0
          ENDDO
          x(i) = zero
        ENDDO
        DO nd=1,nbdirs
          xd(nd, isave(2)) = 0.D0
        ENDDO
        x(isave(2)) = one
        kase = 1
        isave(1) = 3
        RETURN
C
C     ................ ENTRY   (ISAVE( 1 ) = 5)
C     X HAS BEEN OVERWRITTEN BY A*X.
C
 140    result1 = DASUM(n, x, 1)
        arg10 = 3*n
        temp = two*(result1/DBLE(arg10))
        IF (temp .GT. est) THEN
          CALL DCOPY_DV(n, x, xd, 1, v, vd, 1, nbdirs)
          est = temp
        END IF
C
 150    kase = 0
        RETURN
      END IF
      END

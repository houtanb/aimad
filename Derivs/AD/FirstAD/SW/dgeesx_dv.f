!
! Copyright (C) 2006-2014 Houtan Bastani and Luca Guerrieri
!
!
! This free software: you can redistribute it and/or modify
! it under the terms of the GNU General Public License as published by
! the Free Software Foundation, either version 3 of the License, or
! (at your option) any later version.
!
! It is distributed in the hope that it will be useful,
! but WITHOUT ANY WARRANTY; without even the implied warranty of
! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
! GNU General Public License for more details.
!
! You should have received a copy of the GNU General Public License
! along with Dynare.  If not, see <http://www.gnu.org/licenses/>.
!

C        Generated by TAPENADE     (INRIA, Tropics team)
C  Tapenade - Version 2.2 (r1239) - Wed 28 Jun 2006 04:59:55 PM CEST
C
C  Differentiation of dgeesx in forward (tangent) mode: (multi-directional mode)
C   variations  of output variables: vs
C   with respect to input variables: a
      SUBROUTINE DGEESX_DV(jobvs, sort, SELECT, sense, n, a, ad, lda,
     +                     sdim, wr, wi, vs, vsd, ldvs, rconde, rcondv,
     +                     work, lwork, iwork, liwork, bwork, info,
     +                     nbdirs)
      USE DIFFSIZES
      IMPLICIT NONE
C
C     End of DGEESX
C
      LOGICAL bwork(*), SELECT
      INTEGER lda, ldvs, nbdirs, liwork, lwork, n, sdim
      DOUBLE PRECISION a(lda, *), ad(nbdirsmax, lda, *), vs(ldvs,
     +                 n), vsd(nbdirsmax, ldvs, n), wi(
     +                 n), work(MAX(1,lwork)), wr(n)
      INTEGER info, iwork(*)
      DOUBLE PRECISION rconde, rcondv
      CHARACTER jobvs, sense, sort
      EXTERNAL SELECT
      DOUBLE PRECISION one, zero
      PARAMETER (one=1.0d0, zero=0.0d0)
      DOUBLE PRECISION anrm, anrmd(nbdirsmax), bignum, cscale, cscaled(
     +                 nbdirsmax), eps, result11, smlnum
      DOUBLE PRECISION DLAMCH
      DOUBLE PRECISION DLANGE
      DOUBLE PRECISION dum(1), dumd(nbdirsmax, 1)
      INTEGER arg1, hswork, i, i1, i2, ibal, icond, ierr, ieval, ihi,
     +        ii1, ii2, ii3, ILAENV, ilo, inxt, ip, itau, iwrk, liwrk,
     +        lwrk, max1, max2, maxwrk, minwrk, nd, result10, y1
      LOGICAL cursl, lastsl, lquery, LSAME, lst2sl, result1, scalea,
     +        wantsb, wantse, wantsn, wantst, wantsv, wantvs
      DOUBLE PRECISION wid(nbdirsmax, n), workd(
     +                 nbdirsmax, MAX(1,lwork)), wrd(nbdirsmax,
     +                 n)
      EXTERNAL DLABAD, ILAENV, XERBLA, LSAME, DLAMCH
      INTRINSIC MAX, SQRT
C
C  -- LAPACK driver routine (version 3.1) --
C     Univ. of Tennessee, Univ. of California Berkeley and NAG Ltd..
C     November 2006
C
C     .. Scalar Arguments ..
C     ..
C     .. Array Arguments ..
C     ..
C     .. Function Arguments ..
C     ..
C
C  Purpose
C  =======
C
C  DGEESX computes for an N-by-N real nonsymmetric matrix A, the
C  eigenvalues, the real Schur form T, and, optionally, the matrix of
C  Schur vectors Z.  This gives the Schur factorization A = Z*T*(Z**T).
C
C  Optionally, it also orders the eigenvalues on the diagonal of the
C  real Schur form so that selected eigenvalues are at the top left;
C  computes a reciprocal condition number for the average of the
C  selected eigenvalues (RCONDE); and computes a reciprocal condition
C  number for the right invariant subspace corresponding to the
C  selected eigenvalues (RCONDV).  The leading columns of Z form an
C  orthonormal basis for this invariant subspace.
C
C  For further explanation of the reciprocal condition numbers RCONDE
C  and RCONDV, see Section 4.10 of the LAPACK Users' Guide (where
C  these quantities are called s and sep respectively).
C
C  A real matrix is in real Schur form if it is upper quasi-triangular
C  with 1-by-1 and 2-by-2 blocks. 2-by-2 blocks will be standardized in
C  the form
C            [  a  b  ]
C            [  c  a  ]
C
C  where b*c < 0. The eigenvalues of such a block are a +- sqrt(bc).
C
C  Arguments
C  =========
C
C  JOBVS   (input) CHARACTER*1
C          = 'N': Schur vectors are not computed;
C          = 'V': Schur vectors are computed.
C
C  SORT    (input) CHARACTER*1
C          Specifies whether or not to order the eigenvalues on the
C          diagonal of the Schur form.
C          = 'N': Eigenvalues are not ordered;
C          = 'S': Eigenvalues are ordered (see SELECT).
C
C  SELECT  (external procedure) LOGICAL FUNCTION of two DOUBLE PRECISION arguments
C          SELECT must be declared EXTERNAL in the calling subroutine.
C          If SORT = 'S', SELECT is used to select eigenvalues to sort
C          to the top left of the Schur form.
C          If SORT = 'N', SELECT is not referenced.
C          An eigenvalue WR(j)+sqrt(-1)*WI(j) is selected if
C          SELECT(WR(j),WI(j)) is true; i.e., if either one of a
C          complex conjugate pair of eigenvalues is selected, then both
C          are.  Note that a selected complex eigenvalue may no longer
C          satisfy SELECT(WR(j),WI(j)) = .TRUE. after ordering, since
C          ordering may change the value of complex eigenvalues
C          (especially if the eigenvalue is ill-conditioned); in this
C          case INFO may be set to N+3 (see INFO below).
C
C  SENSE   (input) CHARACTER*1
C          Determines which reciprocal condition numbers are computed.
C          = 'N': None are computed;
C          = 'E': Computed for average of selected eigenvalues only;
C          = 'V': Computed for selected right invariant subspace only;
C          = 'B': Computed for both.
C          If SENSE = 'E', 'V' or 'B', SORT must equal 'S'.
C
C  N       (input) INTEGER
C          The order of the matrix A. N >= 0.
C
C  A       (input/output) DOUBLE PRECISION array, dimension (LDA, N)
C          On entry, the N-by-N matrix A.
C          On exit, A is overwritten by its real Schur form T.
C
C  LDA     (input) INTEGER
C          The leading dimension of the array A.  LDA >= max(1,N).
C
C  SDIM    (output) INTEGER
C          If SORT = 'N', SDIM = 0.
C          If SORT = 'S', SDIM = number of eigenvalues (after sorting)
C                         for which SELECT is true. (Complex conjugate
C                         pairs for which SELECT is true for either
C                         eigenvalue count as 2.)
C
C  WR      (output) DOUBLE PRECISION array, dimension (N)
C  WI      (output) DOUBLE PRECISION array, dimension (N)
C          WR and WI contain the real and imaginary parts, respectively,
C          of the computed eigenvalues, in the same order that they
C          appear on the diagonal of the output Schur form T.  Complex
C          conjugate pairs of eigenvalues appear consecutively with the
C          eigenvalue having the positive imaginary part first.
C
C  VS      (output) DOUBLE PRECISION array, dimension (LDVS,N)
C          If JOBVS = 'V', VS contains the orthogonal matrix Z of Schur
C          vectors.
C          If JOBVS = 'N', VS is not referenced.
C
C  LDVS    (input) INTEGER
C          The leading dimension of the array VS.  LDVS >= 1, and if
C          JOBVS = 'V', LDVS >= N.
C
C  RCONDE  (output) DOUBLE PRECISION
C          If SENSE = 'E' or 'B', RCONDE contains the reciprocal
C          condition number for the average of the selected eigenvalues.
C          Not referenced if SENSE = 'N' or 'V'.
C
C  RCONDV  (output) DOUBLE PRECISION
C          If SENSE = 'V' or 'B', RCONDV contains the reciprocal
C          condition number for the selected right invariant subspace.
C          Not referenced if SENSE = 'N' or 'E'.
C
C  WORK    (workspace/output) DOUBLE PRECISION array, dimension (MAX(1,LWORK))
C          On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
C
C  LWORK   (input) INTEGER
C          The dimension of the array WORK.  LWORK >= max(1,3*N).
C          Also, if SENSE = 'E' or 'V' or 'B',
C          LWORK >= N+2*SDIM*(N-SDIM), where SDIM is the number of
C          selected eigenvalues computed by this routine.  Note that
C          N+2*SDIM*(N-SDIM) <= N+N*N/2. Note also that an error is only
C          returned if LWORK < max(1,3*N), but if SENSE = 'E' or 'V' or
C          'B' this may not be large enough.
C          For good performance, LWORK must generally be larger.
C
C          If LWORK = -1, then a workspace query is assumed; the routine
C          only calculates upper bounds on the optimal sizes of the
C          arrays WORK and IWORK, returns these values as the first
C          entries of the WORK and IWORK arrays, and no error messages
C          related to LWORK or LIWORK are issued by XERBLA.
C
C  IWORK   (workspace/output) INTEGER array, dimension (MAX(1,LIWORK))
C          On exit, if INFO = 0, IWORK(1) returns the optimal LIWORK.
C
C  LIWORK  (input) INTEGER
C          The dimension of the array IWORK.
C          LIWORK >= 1; if SENSE = 'V' or 'B', LIWORK >= SDIM*(N-SDIM).
C          Note that SDIM*(N-SDIM) <= N*N/4. Note also that an error is
C          only returned if LIWORK < 1, but if SENSE = 'V' or 'B' this
C          may not be large enough.
C
C          If LIWORK = -1, then a workspace query is assumed; the
C          routine only calculates upper bounds on the optimal sizes of
C          the arrays WORK and IWORK, returns these values as the first
C          entries of the WORK and IWORK arrays, and no error messages
C          related to LWORK or LIWORK are issued by XERBLA.
C
C  BWORK   (workspace) LOGICAL array, dimension (N)
C          Not referenced if SORT = 'N'.
C
C  INFO    (output) INTEGER
C          = 0: successful exit
C          < 0: if INFO = -i, the i-th argument had an illegal value.
C          > 0: if INFO = i, and i is
C             <= N: the QR algorithm failed to compute all the
C                   eigenvalues; elements 1:ILO-1 and i+1:N of WR and WI
C                   contain those eigenvalues which have converged; if
C                   JOBVS = 'V', VS contains the transformation which
C                   reduces A to its partially converged Schur form.
C             = N+1: the eigenvalues could not be reordered because some
C                   eigenvalues were too close to separate (the problem
C                   is very ill-conditioned);
C             = N+2: after reordering, roundoff changed values of some
C                   complex eigenvalues so that leading eigenvalues in
C                   the Schur form no longer satisfy SELECT=.TRUE.  This
C                   could also be caused by underflow due to scaling.
C
C  =====================================================================
C
C     .. Parameters ..
C     ..
C     .. Local Scalars ..
C     ..
C     .. Local Arrays ..
C     ..
C     .. External Subroutines ..
C     ..
C     .. External Functions ..
C     ..
C     .. Intrinsic Functions ..
C     ..
C     .. Executable Statements ..
C
C     Test the input arguments
C
      info = 0
      wantvs = LSAME(jobvs, 'V')
      wantst = LSAME(sort, 'S')
      wantsn = LSAME(sense, 'N')
      wantse = LSAME(sense, 'E')
      wantsv = LSAME(sense, 'V')
      wantsb = LSAME(sense, 'B')
      lquery = lwork .EQ. -1 .OR. liwork .EQ. -1
      result1 = LSAME(jobvs, 'N')
      IF (.NOT.wantvs .AND. (.NOT.result1)) THEN
        info = -1
      ELSE
        result1 = LSAME(sort, 'N')
        IF (.NOT.wantst .AND. (.NOT.result1)) THEN
          info = -2
        ELSE IF (.NOT.(wantsn .OR. wantse .OR. wantsv .OR. wantsb) .OR.
     +      .NOT.wantst .AND. (.NOT.wantsn)) THEN
          info = -4
        ELSE IF (n .LT. 0) THEN
          info = -5
        ELSE
          IF (1 .LT. n) THEN
            max1 = n
          ELSE
            max1 = 1
          END IF
          IF (lda .LT. max1) THEN
            info = -7
          ELSE IF (ldvs .LT. 1 .OR. wantvs .AND. ldvs .LT. n) THEN
            info = -12
          END IF
        END IF
      END IF
C
C     Compute workspace
C      (Note: Comments in the code beginning "RWorkspace:" describe the
C       minimal amount of real workspace needed at that point in the
C       code, as well as the preferred amount for good performance.
C       IWorkspace refers to integer workspace.
C       NB refers to the optimal block size for the immediately
C       following subroutine, as returned by ILAENV.
C       HSWORK refers to the workspace preferred by DHSEQR, as
C       calculated below. HSWORK is computed assuming ILO=1 and IHI=N,
C       the worst case.
C       If SENSE = 'E', 'V' or 'B', then the amount of workspace needed
C       depends on SDIM, which is computed by the routine DTRSEN later
C       in the code.)
C
      IF (info .EQ. 0) THEN
        liwrk = 1
        IF (n .EQ. 0) THEN
          minwrk = 1
          lwrk = 1
          DO ii1=1,n
            DO nd=1,nbdirs
              wrd(nd, ii1) = 0.D0
            ENDDO
          ENDDO
          DO ii1=1,MAX(1,lwork)
            DO nd=1,nbdirs
              workd(nd, ii1) = 0.D0
            ENDDO
          ENDDO
          DO ii1=1,n
            DO ii2=1,ldvs
              DO nd=1,nbdirs
                vsd(nd, ii2, ii1) = 0.D0
              ENDDO
            ENDDO
          ENDDO
          DO ii1=1,n
            DO nd=1,nbdirs
              wid(nd, ii1) = 0.D0
            ENDDO
          ENDDO
        ELSE
          result10 = ILAENV(1, 'DGEHRD', ' ', n, 1, n, 0)
          maxwrk = 2*n + n*result10
          minwrk = 3*n
C
          arg1 = -1
          DO nd=1,nbdirs
            DO ii2=1,n
              wrd(nd, ii2) = 0.D0
            ENDDO
            DO ii2=1,MAX(1,lwork)
              workd(nd, ii2) = 0.D0
            ENDDO
            DO ii2=1,n
              DO ii3=1,ldvs
                vsd(nd, ii3, ii2) = 0.D0
              ENDDO
            ENDDO
            DO ii2=1,n
              wid(nd, ii2) = 0.D0
            ENDDO
          ENDDO
          CALL DHSEQR_DV('S', jobvs, n, 1, n, a, ad, lda, wr, wrd, wi,
     +                   wid, vs, vsd, ldvs, work, workd, arg1, ieval,
     +                   nbdirs)
          hswork = work(1)
C
          IF (.NOT.wantvs) THEN
            IF (maxwrk .LT. n + hswork) THEN
              maxwrk = n + hswork
            ELSE
              maxwrk = maxwrk
            END IF
          ELSE
            arg1 = -1
            result10 = ILAENV(1, 'DORGHR', ' ', n, 1, n, arg1)
            y1 = 2*n + (n-1)*result10
            IF (maxwrk .LT. y1) THEN
              maxwrk = y1
            ELSE
              maxwrk = maxwrk
            END IF
            IF (maxwrk .LT. n + hswork) THEN
              maxwrk = n + hswork
            ELSE
              maxwrk = maxwrk
            END IF
          END IF
          lwrk = maxwrk
          IF (.NOT.wantsn) THEN
            IF (lwrk .LT. n + n*n/2) THEN
              lwrk = n + n*n/2
            ELSE
              lwrk = lwrk
            END IF
          END IF
          IF (wantsv .OR. wantsb) liwrk = n*n/4
        END IF
        iwork(1) = liwrk
        DO nd=1,nbdirs
          workd(nd, 1) = 0.D0
        ENDDO
        work(1) = lwrk
C
        IF (lwork .LT. minwrk .AND. (.NOT.lquery)) THEN
          info = -16
        ELSE IF (liwork .LT. 1 .AND. (.NOT.lquery)) THEN
          info = -18
        END IF
      ELSE
        DO ii1=1,n
          DO nd=1,nbdirs
            wrd(nd, ii1) = 0.D0
          ENDDO
        ENDDO
        DO ii1=1,MAX(1,lwork)
          DO nd=1,nbdirs
            workd(nd, ii1) = 0.D0
          ENDDO
        ENDDO
        DO ii1=1,n
          DO ii2=1,ldvs
            DO nd=1,nbdirs
              vsd(nd, ii2, ii1) = 0.D0
            ENDDO
          ENDDO
        ENDDO
        DO ii1=1,n
          DO nd=1,nbdirs
            wid(nd, ii1) = 0.D0
          ENDDO
        ENDDO
      END IF
C
      IF (info .NE. 0) THEN
        arg1 = -info
        CALL XERBLA('DGEESX', arg1)
        RETURN
      ELSE IF (n .EQ. 0) THEN
C
C     Quick return if possible
C
        sdim = 0
        RETURN
      ELSE
C
C     Get machine constants
C
        eps = DLAMCH('P')
        smlnum = DLAMCH('S')
        bignum = one/smlnum
        CALL DLABAD(smlnum, bignum)
        result11 = SQRT(smlnum)
        smlnum = result11/eps
        bignum = one/smlnum
        DO nd=1,nbdirs
          DO ii2=1,1
            dumd(nd, ii2) = 0.D0
          ENDDO
        ENDDO
C
C     Scale A if max element outside range [SMLNUM,BIGNUM]
C
        CALL DLANGE_DV('M', n, n, a, ad, lda, dum, dumd, anrm, anrmd,
     +                 nbdirs)
        scalea = .false.
        IF (anrm .GT. zero .AND. anrm .LT. smlnum) THEN
          scalea = .true.
          cscale = smlnum
        ELSE IF (anrm .GT. bignum) THEN
          scalea = .true.
          cscale = bignum
        END IF
        IF (scalea) THEN
          DO nd=1,nbdirs
            cscaled(nd) = 0.D0
          ENDDO
          CALL DLASCL_DV('G', 0, 0, anrm, anrmd, cscale, cscaled, n, n,
     +                   a, ad, lda, ierr, nbdirs)
        END IF
C
C     Permute the matrix to make it more nearly triangular
C     (RWorkspace: need N)
C
        ibal = 1
        CALL DGEBAL_DV('P', n, a, ad, lda, ilo, ihi, work(ibal), workd(1
     +                 , ibal), ierr, nbdirs)
C
C     Reduce to upper Hessenberg form
C     (RWorkspace: need 3*N, prefer 2*N+N*NB)
C
        itau = n + ibal
        iwrk = n + itau
        arg1 = lwork - iwrk + 1
        CALL DGEHRD_DV(n, ilo, ihi, a, ad, lda, work(itau), workd(1,
     +                 itau), work(iwrk), workd(1, iwrk), arg1, ierr,
     +                 nbdirs)
C
        IF (wantvs) THEN
C
C        Copy Householder vectors to VS
C
          CALL DLACPY_DV('L', n, n, a, ad, lda, vs, vsd, ldvs, nbdirs)
C
C        Generate orthogonal matrix in VS
C        (RWorkspace: need 3*N-1, prefer 2*N+(N-1)*NB)
C
          arg1 = lwork - iwrk + 1
          CALL DORGHR_DV(n, ilo, ihi, vs, vsd, ldvs, work(itau), workd(1
     +                   , itau), work(iwrk), workd(1, iwrk), arg1, ierr
     +                   , nbdirs)
        END IF
C
        sdim = 0
C
C     Perform QR iteration, accumulating Schur vectors in VS if desired
C     (RWorkspace: need N+1, prefer N+HSWORK (see comments) )
C
        iwrk = itau
        arg1 = lwork - iwrk + 1
        CALL DHSEQR_DV('S', jobvs, n, ilo, ihi, a, ad, lda, wr, wrd, wi
     +                 , wid, vs, vsd, ldvs, work(iwrk), workd(1, iwrk)
     +                 , arg1, ieval, nbdirs)
        IF (ieval .GT. 0) info = ieval
C
C     Sort eigenvalues if desired
C
        IF (wantst .AND. info .EQ. 0) THEN
          IF (scalea) THEN
            CALL DLASCL('G', 0, 0, cscale, anrm, n, 1, wr, n, ierr)
            CALL DLASCL('G', 0, 0, cscale, anrm, n, 1, wi, n, ierr)
          END IF
          DO i=1,n
            bwork(i) = SELECT(wr(i), wi(i))
          ENDDO
C
C        Reorder eigenvalues, transform Schur vectors, and compute
C        reciprocal condition numbers
C        (RWorkspace: if SENSE is not 'N', need N+2*SDIM*(N-SDIM)
C                     otherwise, need N )
C        (IWorkspace: if SENSE is 'V' or 'B', need SDIM*(N-SDIM)
C                     otherwise, need 0 )
C
          arg1 = lwork - iwrk + 1
          CALL DTRSEN_DV(sense, jobvs, bwork, n, a, ad, lda, vs, vsd,
     +                   ldvs, wr, wi, sdim, rconde, rcondv, work(iwrk)
     +                   , workd(1, iwrk), arg1, iwork, liwork, icond,
     +                   nbdirs)
          IF (.NOT.wantsn) THEN
            IF (maxwrk .LT. n + 2*sdim*(n-sdim)) THEN
              maxwrk = n + 2*sdim*(n-sdim)
            ELSE
              maxwrk = maxwrk
            END IF
          END IF
          IF (icond .EQ. -15) THEN
C
C           Not enough real workspace
C
            info = -16
          ELSE IF (icond .EQ. -17) THEN
C
C           Not enough integer workspace
C
            info = -18
          ELSE IF (icond .GT. 0) THEN
C
C           DTRSEN failed to reorder or to restore standard Schur form
C
            info = icond + n
          END IF
        END IF
C
        IF (wantvs) CALL DGEBAK_DV('P', 'R', n, ilo, ihi, work(ibal),
     +                             workd(1, ibal), n, vs, vsd, ldvs,
     +                             ierr, nbdirs)
C
C        Undo balancing
C        (RWorkspace: need N)
C
C
        IF (scalea) THEN
C
C        Undo scaling for the Schur form of A
C
          CALL DLASCL('H', 0, 0, cscale, anrm, n, n, a, lda, ierr)
          arg1 = lda + 1
          CALL DCOPY(n, a, arg1, wr, 1)
          IF ((wantsv .OR. wantsb) .AND. info .EQ. 0) THEN
            dum(1) = rcondv
            CALL DLASCL('G', 0, 0, cscale, anrm, 1, 1, dum, 1, ierr)
            rcondv = dum(1)
          END IF
          IF (cscale .EQ. smlnum) THEN
C
C           If scaling back towards underflow, adjust WI if an
C           offdiagonal element of a 2-by-2 block in the Schur form
C           underflows.
C
            IF (ieval .GT. 0) THEN
              i1 = ieval + 1
              i2 = ihi - 1
              arg1 = ilo - 1
              CALL DLASCL('G', 0, 0, cscale, anrm, arg1, 1, wi, n, ierr)
            ELSE IF (wantst) THEN
              i1 = 1
              i2 = n - 1
            ELSE
              i1 = ilo
              i2 = ihi - 1
            END IF
            inxt = i1 - 1
            DO i=i1,i2
              IF (.NOT.i .LT. inxt) THEN
                IF (wi(i) .EQ. zero) THEN
                  inxt = i + 1
                ELSE
                  IF (a(i+1, i) .EQ. zero) THEN
                    wi(i) = zero
                    wi(i+1) = zero
                  ELSE IF (a(i+1, i) .NE. zero .AND. a(i, i+1) .EQ. zero
     +            ) THEN
                    wi(i) = zero
                    wi(i+1) = zero
                    IF (i .GT. 1) THEN
                      arg1 = i - 1
                      CALL DSWAP(arg1, a(1, i), 1, a(1, i+1), 1)
                    END IF
                    IF (n .GT. i + 1) THEN
                      arg1 = n - i - 1
                      CALL DSWAP(arg1, a(i, i+2), lda, a(i+1, i+2), lda)
                    END IF
                    CALL DSWAP_DV(n, vs(1, i), vsd(1, 1, i), 1, vs(1, i+
     +                            1), vsd(1, 1, i+1), 1, nbdirs)
                    a(i, i+1) = a(i+1, i)
                    a(i+1, i) = zero
                  END IF
                  inxt = i + 2
                END IF
              END IF
            ENDDO
          END IF
          IF (n - ieval .LT. 1) THEN
            max2 = 1
          ELSE
            max2 = n - ieval
          END IF
          arg1 = n - ieval
          CALL DLASCL('G', 0, 0, cscale, anrm, arg1, 1, wi(ieval+1),
     +                max2, ierr)
        END IF
C
        IF (wantst .AND. info .EQ. 0) THEN
C
C        Check if reordering successful
C
          lastsl = .true.
          lst2sl = .true.
          sdim = 0
          ip = 0
          DO i=1,n
            cursl = SELECT(wr(i), wi(i))
            IF (wi(i) .EQ. zero) THEN
              IF (cursl) sdim = sdim + 1
              ip = 0
              IF (cursl .AND. (.NOT.lastsl)) info = n + 2
            ELSE IF (ip .EQ. 1) THEN
C
C                 Last eigenvalue of conjugate pair
C
              cursl = cursl .OR. lastsl
              lastsl = cursl
              IF (cursl) sdim = sdim + 2
              ip = -1
              IF (cursl .AND. (.NOT.lst2sl)) info = n + 2
            ELSE
C
C                 First eigenvalue of conjugate pair
C
              ip = 1
            END IF
            lst2sl = lastsl
            lastsl = cursl
          ENDDO
        END IF
C
        work(1) = maxwrk
        IF (wantsv .OR. wantsb) THEN
          IF (1 .LT. sdim*(n-sdim)) THEN
            iwork(1) = sdim*(n-sdim)
          ELSE
            iwork(1) = 1
          END IF
        ELSE
          iwork(1) = 1
        END IF
C
        RETURN
      END IF
      END

!
! Copyright (C) 2006-2014 Houtan Bastani and Luca Guerrieri
!
!
! This free software: you can redistribute it and/or modify
! it under the terms of the GNU General Public License as published by
! the Free Software Foundation, either version 3 of the License, or
! (at your option) any later version.
!
! It is distributed in the hope that it will be useful,
! but WITHOUT ANY WARRANTY; without even the implied warranty of
! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
! GNU General Public License for more details.
!
! You should have received a copy of the GNU General Public License
! along with Dynare.  If not, see <http://www.gnu.org/licenses/>.
!

C        Generated by TAPENADE     (INRIA, Tropics team)
C  Tapenade - Version 2.2 (r1239) - Wed 28 Jun 2006 04:59:55 PM CEST
C
C  Differentiation of dgebak in forward (tangent) mode: (multi-directional mode)
C   variations  of output variables: v
C   with respect to input variables: v scale
      SUBROUTINE DGEBAK_DV(job, side, n, ilo, ihi, scale, scaled, m, v,
     +                     vd, ldv, info, nbdirs)
      USE DIFFSIZES
      IMPLICIT NONE
C
C     End of DGEBAK
C
      INTEGER ihi, ilo, info, m, n
      INTEGER ldv, nbdirs
      DOUBLE PRECISION scale(*), scaled(nbdirsmax, *), v(ldv, *), vd(
     +                 nbdirsmax, ldv, *)
      CHARACTER job, side
      DOUBLE PRECISION one
      PARAMETER (one=1.0d+0)
      LOGICAL leftv, LSAME, result1, result2, result3, result4, rightv
      INTEGER arg1, i, ii, k, max1, max2, min1, nd
      DOUBLE PRECISION s, sd(nbdirsmax)
      INTRINSIC MAX, MIN
      EXTERNAL XERBLA, LSAME
C
C  -- LAPACK routine (version 3.1) --
C     Univ. of Tennessee, Univ. of California Berkeley and NAG Ltd..
C     November 2006
C
C     .. Scalar Arguments ..
C     ..
C     .. Array Arguments ..
C     ..
C
C  Purpose
C  =======
C
C  DGEBAK forms the right or left eigenvectors of a real general matrix
C  by backward transformation on the computed eigenvectors of the
C  balanced matrix output by DGEBAL.
C
C  Arguments
C  =========
C
C  JOB     (input) CHARACTER*1
C          Specifies the type of backward transformation required:
C          = 'N', do nothing, return immediately;
C          = 'P', do backward transformation for permutation only;
C          = 'S', do backward transformation for scaling only;
C          = 'B', do backward transformations for both permutation and
C                 scaling.
C          JOB must be the same as the argument JOB supplied to DGEBAL.
C
C  SIDE    (input) CHARACTER*1
C          = 'R':  V contains right eigenvectors;
C          = 'L':  V contains left eigenvectors.
C
C  N       (input) INTEGER
C          The number of rows of the matrix V.  N >= 0.
C
C  ILO     (input) INTEGER
C  IHI     (input) INTEGER
C          The integers ILO and IHI determined by DGEBAL.
C          1 <= ILO <= IHI <= N, if N > 0; ILO=1 and IHI=0, if N=0.
C
C  SCALE   (input) DOUBLE PRECISION array, dimension (N)
C          Details of the permutation and scaling factors, as returned
C          by DGEBAL.
C
C  M       (input) INTEGER
C          The number of columns of the matrix V.  M >= 0.
C
C  V       (input/output) DOUBLE PRECISION array, dimension (LDV,M)
C          On entry, the matrix of right or left eigenvectors to be
C          transformed, as returned by DHSEIN or DTREVC.
C          On exit, V is overwritten by the transformed eigenvectors.
C
C  LDV     (input) INTEGER
C          The leading dimension of the array V. LDV >= max(1,N).
C
C  INFO    (output) INTEGER
C          = 0:  successful exit
C          < 0:  if INFO = -i, the i-th argument had an illegal value.
C
C  =====================================================================
C
C     .. Parameters ..
C     ..
C     .. Local Scalars ..
C     ..
C     .. External Functions ..
C     ..
C     .. External Subroutines ..
C     ..
C     .. Intrinsic Functions ..
C     ..
C     .. Executable Statements ..
C
C     Decode and Test the input parameters
C
      rightv = LSAME(side, 'R')
      leftv = LSAME(side, 'L')
C
      info = 0
      result1 = LSAME(job, 'N')
      result2 = LSAME(job, 'P')
      result3 = LSAME(job, 'S')
      result4 = LSAME(job, 'B')
      IF (.NOT.result1 .AND. (.NOT.result2) .AND. (.NOT.result3) .AND. (
     +    .NOT.result4)) THEN
        info = -1
      ELSE IF (.NOT.rightv .AND. (.NOT.leftv)) THEN
        info = -2
      ELSE IF (n .LT. 0) THEN
        info = -3
      ELSE
        IF (1 .LT. n) THEN
          max1 = n
        ELSE
          max1 = 1
        END IF
        IF (ilo .LT. 1 .OR. ilo .GT. max1) THEN
          info = -4
        ELSE
          IF (ilo .GT. n) THEN
            min1 = n
          ELSE
            min1 = ilo
          END IF
          IF (ihi .LT. min1 .OR. ihi .GT. n) THEN
            info = -5
          ELSE IF (m .LT. 0) THEN
            info = -7
          ELSE
            IF (1 .LT. n) THEN
              max2 = n
            ELSE
              max2 = 1
            END IF
            IF (ldv .LT. max2) info = -9
          END IF
        END IF
      END IF
      IF (info .NE. 0) THEN
        arg1 = -info
        CALL XERBLA('DGEBAK', arg1)
        RETURN
      ELSE IF (n .EQ. 0) THEN
C
C     Quick return if possible
C
        RETURN
      ELSE IF (m .EQ. 0) THEN
        RETURN
      ELSE
        result1 = LSAME(job, 'N')
        IF (result1) THEN
          RETURN
        ELSE
C
          IF (.NOT.ilo .EQ. ihi) THEN
C
C     Backward balance
C
            result1 = LSAME(job, 'S')
            result2 = LSAME(job, 'B')
            IF (result1 .OR. result2) THEN
C
              IF (rightv) THEN
                DO i=ilo,ihi
                  DO nd=1,nbdirs
                    sd(nd) = scaled(nd, i)
                  ENDDO
                  s = scale(i)
                  CALL DSCAL_DV(m, s, sd, v(i, 1), vd(1, i, 1), ldv,
     +                          nbdirs)
                ENDDO
              END IF
C
              IF (leftv) THEN
                DO i=ilo,ihi
                  DO nd=1,nbdirs
                    sd(nd) = -(one*scaled(nd, i)/scale(i)**2)
                  ENDDO
                  s = one/scale(i)
                  CALL DSCAL_DV(m, s, sd, v(i, 1), vd(1, i, 1), ldv,
     +                          nbdirs)
                ENDDO
              END IF
            END IF
          END IF
C
C
C     Backward permutation
C
C     For  I = ILO-1 step -1 until 1,
C              IHI+1 step 1 until N do --
C
          result1 = LSAME(job, 'P')
          result2 = LSAME(job, 'B')
          IF (result1 .OR. result2) THEN
            IF (rightv) THEN
              DO ii=1,n
                i = ii
                IF (.NOT.(i .GE. ilo .AND. i .LE. ihi)) THEN
                  IF (i .LT. ilo) i = ilo - ii
                  k = scale(i)
                  IF (.NOT.k .EQ. i) CALL DSWAP_DV(m, v(i, 1), vd(1, i,
     +                                             1), ldv, v(k, 1), vd(
     +                                             1, k, 1), ldv, nbdirs
     +                                            )
                END IF
              ENDDO
            END IF
C
            IF (leftv) THEN
              DO ii=1,n
                i = ii
                IF (.NOT.(i .GE. ilo .AND. i .LE. ihi)) THEN
                  IF (i .LT. ilo) i = ilo - ii
                  k = scale(i)
                  IF (.NOT.k .EQ. i) CALL DSWAP_DV(m, v(i, 1), vd(1, i,
     +                                             1), ldv, v(k, 1), vd(
     +                                             1, k, 1), ldv, nbdirs
     +                                            )
                END IF
              ENDDO
            END IF
          END IF
C
          RETURN
        END IF
      END IF
      END

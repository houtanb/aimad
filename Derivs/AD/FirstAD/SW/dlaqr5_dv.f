!
! Copyright (C) 2006-2014 Houtan Bastani and Luca Guerrieri
!
!
! This free software: you can redistribute it and/or modify
! it under the terms of the GNU General Public License as published by
! the Free Software Foundation, either version 3 of the License, or
! (at your option) any later version.
!
! It is distributed in the hope that it will be useful,
! but WITHOUT ANY WARRANTY; without even the implied warranty of
! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
! GNU General Public License for more details.
!
! You should have received a copy of the GNU General Public License
! along with Dynare.  If not, see <http://www.gnu.org/licenses/>.
!

C        Generated by TAPENADE     (INRIA, Tropics team)
C  Tapenade - Version 2.2 (r1239) - Wed 28 Jun 2006 04:59:55 PM CEST
C
C  Differentiation of dlaqr5 in forward (tangent) mode: (multi-directional mode)
C   variations  of output variables: h wv u v z si sr wh
C   with respect to input variables: h wv u v z si sr wh
      SUBROUTINE DLAQR5_DV(wantt, wantz, kacc22, n, ktop, kbot, nshfts,
     +                     sr, srd, si, sid, h, hd, ldh, iloz, ihiz, z,
     +                     zd, ldz, v, vd, ldv, u, ud, ldu, nv, wv, wvd
     +                     , ldwv, nh, wh, whd, ldwh, nbdirs)
      USE DIFFSIZES
      IMPLICIT NONE
C
C     ==== End of DLAQR5 ====
C
      INTEGER ihiz, iloz, kacc22, kbot, ktop, n, nh, nshfts, nv
      INTEGER ldh, ldu, ldv, ldwh, ldwv, ldz, nbdirs
      LOGICAL wantt, wantz
      DOUBLE PRECISION h(ldh, *), hd(nbdirsmax, ldh, *), si(*), sid(
     +                 nbdirsmax, *), sr(*), srd(nbdirsmax, *), u(ldu, *
     +                 ), ud(nbdirsmax, ldu, *), v(ldv, *), vd(nbdirsmax
     +                 , ldv, *), wh(ldwh, *), whd(nbdirsmax, ldwh, *),
     +                 wv(ldwv, *), wvd(nbdirsmax, ldwv, *), z(ldz, *),
     +                 zd(nbdirsmax, ldz, *)
      DOUBLE PRECISION one, zero
      PARAMETER (one=1.0d0, zero=0.0d0)
      LOGICAL accum, blk22, bmp22
      DOUBLE PRECISION DLAMCH
      INTEGER arg1, arg2, i, i2, i4, ii1, incol, j, j2, j4, jbot, jcol,
     +        jlen, jrow, jtop, k, k1, kdu, kms, knz, krcol, kzs, m, m22
     +        , max1, max10, max11, max2, max3, max4, max6, max7, max8,
     +        mbot, mend, min1, min2, min3, min4, min5, mstart, mtop,
     +        nbmps, nd, ndcol, ns, nu, y5, y6
      DOUBLE PRECISION alpha, alphad(nbdirsmax), beta, betad(nbdirsmax)
     +                 , h11, h12, h21, h22, max5, max9, refsum, refsumd
     +                 (nbdirsmax), safmax, safmin, scl, scld(nbdirsmax)
     +                 , smlnum, swap, swapd(nbdirsmax), tst1, tst2, ulp
      DOUBLE PRECISION abs1, abs11, abs11d(nbdirsmax), abs12, abs14,
     +                 abs14d(nbdirsmax), abs15, abs16, abs1d(nbdirsmax)
     +                 , vt(3), vtd(nbdirsmax, 3)
      DOUBLE PRECISION abs10, abs13, abs17, abs18, abs19, abs2, abs3,
     +                 abs4, abs5, abs6, abs7, abs8, abs9, x1, x2, x3,
     +                 x4, y1, y2, y3, y4
      EXTERNAL DLABAD, DLAMCH
      INTRINSIC MOD, MAX, ABS, DBLE, MIN
C
C  -- LAPACK auxiliary routine (version 3.1) --
C     Univ. of Tennessee, Univ. of California Berkeley and NAG Ltd..
C     November 2006
C
C     .. Scalar Arguments ..
C     ..
C     .. Array Arguments ..
C     ..
C
C     This auxiliary subroutine called by DLAQR0 performs a
C     single small-bulge multi-shift QR sweep.
C
C      WANTT  (input) logical scalar
C             WANTT = .true. if the quasi-triangular Schur factor
C             is being computed.  WANTT is set to .false. otherwise.
C
C      WANTZ  (input) logical scalar
C             WANTZ = .true. if the orthogonal Schur factor is being
C             computed.  WANTZ is set to .false. otherwise.
C
C      KACC22 (input) integer with value 0, 1, or 2.
C             Specifies the computation mode of far-from-diagonal
C             orthogonal updates.
C        = 0: DLAQR5 does not accumulate reflections and does not
C             use matrix-matrix multiply to update far-from-diagonal
C             matrix entries.
C        = 1: DLAQR5 accumulates reflections and uses matrix-matrix
C             multiply to update the far-from-diagonal matrix entries.
C        = 2: DLAQR5 accumulates reflections, uses matrix-matrix
C             multiply to update the far-from-diagonal matrix entries,
C             and takes advantage of 2-by-2 block structure during
C             matrix multiplies.
C
C      N      (input) integer scalar
C             N is the order of the Hessenberg matrix H upon which this
C             subroutine operates.
C
C      KTOP   (input) integer scalar
C      KBOT   (input) integer scalar
C             These are the first and last rows and columns of an
C             isolated diagonal block upon which the QR sweep is to be
C             applied. It is assumed without a check that
C                       either KTOP = 1  or   H(KTOP,KTOP-1) = 0
C             and
C                       either KBOT = N  or   H(KBOT+1,KBOT) = 0.
C
C      NSHFTS (input) integer scalar
C             NSHFTS gives the number of simultaneous shifts.  NSHFTS
C             must be positive and even.
C
C      SR     (input) DOUBLE PRECISION array of size (NSHFTS)
C      SI     (input) DOUBLE PRECISION array of size (NSHFTS)
C             SR contains the real parts and SI contains the imaginary
C             parts of the NSHFTS shifts of origin that define the
C             multi-shift QR sweep.
C
C      H      (input/output) DOUBLE PRECISION array of size (LDH,N)
C             On input H contains a Hessenberg matrix.  On output a
C             multi-shift QR sweep with shifts SR(J)+i*SI(J) is applied
C             to the isolated diagonal block in rows and columns KTOP
C             through KBOT.
C
C      LDH    (input) integer scalar
C             LDH is the leading dimension of H just as declared in the
C             calling procedure.  LDH.GE.MAX(1,N).
C
C      ILOZ   (input) INTEGER
C      IHIZ   (input) INTEGER
C             Specify the rows of Z to which transformations must be
C             applied if WANTZ is .TRUE.. 1 .LE. ILOZ .LE. IHIZ .LE. N
C
C      Z      (input/output) DOUBLE PRECISION array of size (LDZ,IHI)
C             If WANTZ = .TRUE., then the QR Sweep orthogonal
C             similarity transformation is accumulated into
C             Z(ILOZ:IHIZ,ILO:IHI) from the right.
C             If WANTZ = .FALSE., then Z is unreferenced.
C
C      LDZ    (input) integer scalar
C             LDA is the leading dimension of Z just as declared in
C             the calling procedure. LDZ.GE.N.
C
C      V      (workspace) DOUBLE PRECISION array of size (LDV,NSHFTS/2)
C
C      LDV    (input) integer scalar
C             LDV is the leading dimension of V as declared in the
C             calling procedure.  LDV.GE.3.
C
C      U      (workspace) DOUBLE PRECISION array of size
C             (LDU,3*NSHFTS-3)
C
C      LDU    (input) integer scalar
C             LDU is the leading dimension of U just as declared in the
C             in the calling subroutine.  LDU.GE.3*NSHFTS-3.
C
C      NH     (input) integer scalar
C             NH is the number of columns in array WH available for
C             workspace. NH.GE.1.
C
C      WH     (workspace) DOUBLE PRECISION array of size (LDWH,NH)
C
C      LDWH   (input) integer scalar
C             Leading dimension of WH just as declared in the
C             calling procedure.  LDWH.GE.3*NSHFTS-3.
C
C      NV     (input) integer scalar
C             NV is the number of rows in WV agailable for workspace.
C             NV.GE.1.
C
C      WV     (workspace) DOUBLE PRECISION array of size
C             (LDWV,3*NSHFTS-3)
C
C      LDWV   (input) integer scalar
C             LDWV is the leading dimension of WV as declared in the
C             in the calling subroutine.  LDWV.GE.NV.
C
C
C     ================================================================
C     Based on contributions by
C        Karen Braman and Ralph Byers, Department of Mathematics,
C        University of Kansas, USA
C
C     ============================================================
C     Reference:
C
C     K. Braman, R. Byers and R. Mathias, The Multi-Shift QR
C     Algorithm Part I: Maintaining Well Focused Shifts, and
C     Level 3 Performance, SIAM Journal of Matrix Analysis,
C     volume 23, pages 929--947, 2002.
C
C     ============================================================
C     .. Parameters ..
C     ..
C     .. Local Scalars ..
C     ..
C     .. External Functions ..
C     ..
C     .. Intrinsic Functions ..
C
C     ..
C     .. Local Arrays ..
C     ..
C     .. External Subroutines ..
C     ..
C     .. Executable Statements ..
C
C     ==== If there are no shifts, then there is nothing to do. ====
C
      IF (nshfts .LT. 2) THEN
        RETURN
      ELSE IF (ktop .GE. kbot) THEN
C
C     ==== If the active block is empty or 1-by-1, then there
C     .    is nothing to do. ====
C
        RETURN
      ELSE
C
C     ==== Shuffle shifts into pairs of real shifts and pairs
C     .    of complex conjugate shifts assuming complex
C     .    conjugate shifts are already adjacent to one
C     .    another. ====
C
        DO i=1,nshfts-2,2
          IF (si(i) .NE. -si(i+1)) THEN
            DO nd=1,nbdirs
              swapd(nd) = srd(nd, i)
              srd(nd, i) = srd(nd, i+1)
              srd(nd, i+1) = srd(nd, i+2)
              srd(nd, i+2) = swapd(nd)
              swapd(nd) = sid(nd, i)
              sid(nd, i) = sid(nd, i+1)
              sid(nd, i+1) = sid(nd, i+2)
              sid(nd, i+2) = swapd(nd)
            ENDDO
C
            swap = sr(i)
            sr(i) = sr(i+1)
            sr(i+1) = sr(i+2)
            sr(i+2) = swap
C
            swap = si(i)
            si(i) = si(i+1)
            si(i+1) = si(i+2)
            si(i+2) = swap
          END IF
        ENDDO
C
C     ==== NSHFTS is supposed to be even, but if is odd,
C     .    then simply reduce it by one.  The shuffle above
C     .    ensures that the dropped shift is real and that
C     .    the remaining shifts are paired. ====
C
        ns = nshfts - MOD(nshfts, 2)
C
C     ==== Machine constants for deflation ====
C
        safmin = DLAMCH('SAFE MINIMUM')
        safmax = one/safmin
        CALL DLABAD(safmin, safmax)
        ulp = DLAMCH('PRECISION')
        smlnum = safmin*(DBLE(n)/ulp)
C
C     ==== Use accumulated reflections to update far-from-diagonal
C     .    entries ? ====
C
        accum = kacc22 .EQ. 1 .OR. kacc22 .EQ. 2
C
C     ==== If so, exploit the 2-by-2 block structure? ====
C
        blk22 = ns .GT. 2 .AND. kacc22 .EQ. 2
C
C     ==== clear trash ====
C
        IF (ktop + 2 .LE. kbot) THEN
          DO nd=1,nbdirs
            hd(nd, ktop+2, ktop) = 0.D0
          ENDDO
          h(ktop+2, ktop) = zero
        END IF
C
C     ==== NBMPS = number of 2-shift bulges in the chain ====
C
        nbmps = ns/2
C
C     ==== KDU = width of slab ====
C
        kdu = 6*nbmps - 3
        DO ii1=1,3
          DO nd=1,nbdirs
            vtd(nd, ii1) = 0.D0
          ENDDO
        ENDDO
C
C     ==== Create and chase chains of NBMPS bulges ====
C
        DO incol=3*(1-nbmps)+ktop-1,kbot-2,3*nbmps-2
          ndcol = incol + kdu
          IF (accum) CALL DLASET_DV('ALL', kdu, kdu, zero, one, u, ud,
     +                              ldu, nbdirs)
          IF (incol + 3*nbmps - 3 .GT. kbot - 2) THEN
            min1 = kbot - 2
          ELSE
            min1 = incol + 3*nbmps - 3
          END IF
C
C        ==== Near-the-diagonal bulge chase.  The following loop
C        .    performs the near-the-diagonal part of a small bulge
C        .    multi-shift QR sweep.  Each 6*NBMPS-2 column diagonal
C        .    chunk extends from column INCOL to column NDCOL
C        .    (including both column INCOL and column NDCOL). The
C        .    following loop chases a 3*NBMPS column long chain of
C        .    NBMPS bulges 3*NBMPS-2 columns to the right.  (INCOL
C        .    may be less than KTOP and and NDCOL may be greater than
C        .    KBOT indicating phantom columns from which to chase
C        .    bulges before they are actually introduced or to which
C        .    to chase bulges beyond column KBOT.)  ====
C
          DO krcol=incol,min1
            IF (1 .LT. (ktop-1-krcol+2)/3 + 1) THEN
              mtop = (ktop-1-krcol+2)/3 + 1
            ELSE
              mtop = 1
            END IF
            IF (nbmps .GT. (kbot-krcol)/3) THEN
              mbot = (kbot-krcol)/3
            ELSE
              mbot = nbmps
            END IF
            m22 = mbot + 1
            bmp22 = mbot .LT. nbmps .AND. krcol + 3*(m22-1) .EQ. kbot -
     +        2
C
C           ==== Generate reflections to chase the chain right
C           .    one column.  (The minimum value of K is KTOP-1.) ====
C
            DO m=mtop,mbot
              k = krcol + 3*(m-1)
              IF (k .EQ. ktop - 1) THEN
                CALL DLAQR1_DV(3, h(ktop, ktop), hd(1, ktop, ktop), ldh
     +                         , sr(2*m-1), srd(1, 2*m-1), si(2*m-1),
     +                         sid(1, 2*m-1), sr(2*m), srd(1, 2*m), si(2
     +                         *m), sid(1, 2*m), v(1, m), vd(1, 1, m),
     +                         nbdirs)
                DO nd=1,nbdirs
                  alphad(nd) = vd(nd, 1, m)
                ENDDO
                alpha = v(1, m)
                CALL DLARFG_DV(3, alpha, alphad, v(2, m), vd(1, 2, m), 1
     +                         , v(1, m), vd(1, 1, m), nbdirs)
              ELSE
                beta = h(k+1, k)
                DO nd=1,nbdirs
                  vd(nd, 2, m) = hd(nd, k+2, k)
                  betad(nd) = hd(nd, k+1, k)
                  vd(nd, 3, m) = hd(nd, k+3, k)
                ENDDO
                v(2, m) = h(k+2, k)
                v(3, m) = h(k+3, k)
                CALL DLARFG_DV(3, beta, betad, v(2, m), vd(1, 2, m), 1,
     +                         v(1, m), vd(1, 1, m), nbdirs)
C
C                 ==== A Bulge may collapse because of vigilant
C                 .    deflation or destructive underflow.  (The
C                 .    initial bulge is always collapsed.) Use
C                 .    the two-small-subdiagonals trick to try
C                 .    to get it started again. If V(2,M).NE.0 and
C                 .    V(3,M) = H(K+3,K+1) = H(K+3,K+2) = 0, then
C                 .    this bulge is collapsing into a zero
C                 .    subdiagonal.  It will be restarted next
C                 .    trip through the loop.)
C
                IF (v(1, m) .NE. zero .AND. (v(3, m) .NE. zero .OR. h(k+
     +              3, k+1) .EQ. zero .AND. h(k+3, k+2) .EQ. zero)) THEN
                  DO nd=1,nbdirs
                    hd(nd, k+1, k) = betad(nd)
                    hd(nd, k+2, k) = 0.D0
                    hd(nd, k+3, k) = 0.D0
                  ENDDO
C
C                    ==== Typical case: not collapsed (yet). ====
C
                  h(k+1, k) = beta
                  h(k+2, k) = zero
                  h(k+3, k) = zero
                ELSE
C
C                    ==== Atypical case: collapsed.  Attempt to
C                    .    reintroduce ignoring H(K+1,K).  If the
C                    .    fill resulting from the new reflector
C                    .    is too large, then abandon it.
C                    .    Otherwise, use the new one. ====
C
                  CALL DLAQR1_DV(3, h(k+1, k+1), hd(1, k+1, k+1), ldh,
     +                           sr(2*m-1), srd(1, 2*m-1), si(2*m-1),
     +                           sid(1, 2*m-1), sr(2*m), srd(1, 2*m), si
     +                           (2*m), sid(1, 2*m), vt, vtd, nbdirs)
                  IF (vt(1) .GE. 0.) THEN
                    DO nd=1,nbdirs
                      abs1d(nd) = vtd(nd, 1)
                    ENDDO
                    abs1 = vt(1)
                  ELSE
                    DO nd=1,nbdirs
                      abs1d(nd) = -vtd(nd, 1)
                    ENDDO
                    abs1 = -vt(1)
                  END IF
                  IF (vt(2) .GE. 0.) THEN
                    DO nd=1,nbdirs
                      abs11d(nd) = vtd(nd, 2)
                    ENDDO
                    abs11 = vt(2)
                  ELSE
                    DO nd=1,nbdirs
                      abs11d(nd) = -vtd(nd, 2)
                    ENDDO
                    abs11 = -vt(2)
                  END IF
                  IF (vt(3) .GE. 0.) THEN
                    DO nd=1,nbdirs
                      abs14d(nd) = vtd(nd, 3)
                    ENDDO
                    abs14 = vt(3)
                  ELSE
                    DO nd=1,nbdirs
                      abs14d(nd) = -vtd(nd, 3)
                    ENDDO
                    abs14 = -vt(3)
                  END IF
                  DO nd=1,nbdirs
                    scld(nd) = abs1d(nd) + abs11d(nd) + abs14d(nd)
                  ENDDO
                  scl = abs1 + abs11 + abs14
                  IF (scl .NE. zero) THEN
                    DO nd=1,nbdirs
                      vtd(nd, 1) = (vtd(nd, 1)*scl-vt(1)*scld(nd))/scl**
     +                  2
                    ENDDO
                    vt(1) = vt(1)/scl
                    DO nd=1,nbdirs
                      vtd(nd, 2) = (vtd(nd, 2)*scl-vt(2)*scld(nd))/scl**
     +                  2
                    ENDDO
                    vt(2) = vt(2)/scl
                    DO nd=1,nbdirs
                      vtd(nd, 3) = (vtd(nd, 3)*scl-vt(3)*scld(nd))/scl**
     +                  2
                    ENDDO
                    vt(3) = vt(3)/scl
                  END IF
                  IF (h(k+1, k) .GE. 0.) THEN
                    abs2 = h(k+1, k)
                  ELSE
                    abs2 = -h(k+1, k)
                  END IF
                  IF (vt(2) .GE. 0.) THEN
                    abs12 = vt(2)
                  ELSE
                    abs12 = -vt(2)
                  END IF
                  IF (vt(3) .GE. 0.) THEN
                    abs15 = vt(3)
                  ELSE
                    abs15 = -vt(3)
                  END IF
                  IF (vt(1) .GE. 0.) THEN
                    abs16 = vt(1)
                  ELSE
                    abs16 = -vt(1)
                  END IF
                  IF (h(k, k) .GE. 0.) THEN
                    abs17 = h(k, k)
                  ELSE
                    abs17 = -h(k, k)
                  END IF
                  IF (h(k+1, k+1) .GE. 0.) THEN
                    abs18 = h(k+1, k+1)
                  ELSE
                    abs18 = -h(k+1, k+1)
                  END IF
                  IF (h(k+2, k+2) .GE. 0.) THEN
                    abs19 = h(k+2, k+2)
                  ELSE
                    abs19 = -h(k+2, k+2)
                  END IF
C
C                    ==== The following is the traditional and
C                    .    conservative two-small-subdiagonals
C                    .    test.  ====
C                    .
                  IF (abs2*(abs12+abs15) .GT. ulp*abs16*(abs17+abs18+
     +                abs19)) THEN
C
C                       ==== Starting a new bulge here would
C                       .    create non-negligible fill.   If
C                       .    the old reflector is diagonal (only
C                       .    possible with underflows), then
C                       .    change it to I.  Otherwise, use
C                       .    it with trepidation. ====
C
                    IF (v(2, m) .EQ. zero .AND. v(3, m) .EQ. zero) THEN
                      DO nd=1,nbdirs
                        vd(nd, 1, m) = 0.D0
                      ENDDO
                      v(1, m) = zero
                    ELSE
                      DO nd=1,nbdirs
                        hd(nd, k+1, k) = betad(nd)
                        hd(nd, k+2, k) = 0.D0
                        hd(nd, k+3, k) = 0.D0
                      ENDDO
                      h(k+1, k) = beta
                      h(k+2, k) = zero
                      h(k+3, k) = zero
                    END IF
                  ELSE
                    DO nd=1,nbdirs
                      alphad(nd) = vtd(nd, 1)
                    ENDDO
C
C                       ==== Stating a new bulge here would
C                       .    create only negligible fill.
C                       .    Replace the old reflector with
C                       .    the new one. ====
C
                    alpha = vt(1)
                    CALL DLARFG_DV(3, alpha, alphad, vt(2), vtd(1, 2), 1
     +                             , vt(1), vtd(1, 1), nbdirs)
                    refsum = h(k+1, k) + h(k+2, k)*vt(2) + h(k+3, k)*vt(
     +                3)
                    DO nd=1,nbdirs
                      vd(nd, 1, m) = vtd(nd, 1)
                      vd(nd, 2, m) = vtd(nd, 2)
                      refsumd(nd) = hd(nd, k+1, k) + hd(nd, k+2, k)*vt(2
     +                  ) + h(k+2, k)*vtd(nd, 2) + hd(nd, k+3, k)*vt(3)
     +                  + h(k+3, k)*vtd(nd, 3)
                      vd(nd, 3, m) = vtd(nd, 3)
                      hd(nd, k+1, k) = hd(nd, k+1, k) - vtd(nd, 1)*
     +                  refsum - vt(1)*refsumd(nd)
                      hd(nd, k+2, k) = 0.D0
                      hd(nd, k+3, k) = 0.D0
                    ENDDO
                    h(k+1, k) = h(k+1, k) - vt(1)*refsum
                    h(k+2, k) = zero
                    h(k+3, k) = zero
                    v(1, m) = vt(1)
                    v(2, m) = vt(2)
                    v(3, m) = vt(3)
                  END IF
                END IF
              END IF
            ENDDO
C
C           ==== Generate a 2-by-2 reflection, if needed. ====
C
            k = krcol + 3*(m22-1)
            IF (bmp22) THEN
              IF (k .EQ. ktop - 1) THEN
                CALL DLAQR1_DV(2, h(k+1, k+1), hd(1, k+1, k+1), ldh, sr(
     +                         2*m22-1), srd(1, 2*m22-1), si(2*m22-1),
     +                         sid(1, 2*m22-1), sr(2*m22), srd(1, 2*m22)
     +                         , si(2*m22), sid(1, 2*m22), v(1, m22), vd
     +                         (1, 1, m22), nbdirs)
                DO nd=1,nbdirs
                  betad(nd) = vd(nd, 1, m22)
                ENDDO
                beta = v(1, m22)
                CALL DLARFG_DV(2, beta, betad, v(2, m22), vd(1, 2, m22)
     +                         , 1, v(1, m22), vd(1, 1, m22), nbdirs)
              ELSE
                DO nd=1,nbdirs
                  betad(nd) = hd(nd, k+1, k)
                  vd(nd, 2, m22) = hd(nd, k+2, k)
                ENDDO
                beta = h(k+1, k)
                v(2, m22) = h(k+2, k)
                CALL DLARFG_DV(2, beta, betad, v(2, m22), vd(1, 2, m22)
     +                         , 1, v(1, m22), vd(1, 1, m22), nbdirs)
                DO nd=1,nbdirs
                  hd(nd, k+1, k) = betad(nd)
                  hd(nd, k+2, k) = 0.D0
                ENDDO
                h(k+1, k) = beta
                h(k+2, k) = zero
              END IF
            ELSE
              DO nd=1,nbdirs
                vd(nd, 1, m22) = 0.D0
              ENDDO
C
C              ==== Initialize V(1,M22) here to avoid possible undefined
C              .    variable problems later. ====
C
              v(1, m22) = zero
            END IF
C
C           ==== Multiply H by reflections from the left ====
C
            IF (accum) THEN
              IF (ndcol .GT. kbot) THEN
                jbot = kbot
              ELSE
                jbot = ndcol
              END IF
            ELSE IF (wantt) THEN
              jbot = n
            ELSE
              jbot = kbot
            END IF
            IF (ktop .LT. krcol) THEN
              max1 = krcol
            ELSE
              max1 = ktop
            END IF
            DO j=max1,jbot
              IF (mbot .GT. (j-krcol+2)/3) THEN
                mend = (j-krcol+2)/3
              ELSE
                mend = mbot
              END IF
              DO m=mtop,mend
                k = krcol + 3*(m-1)
                refsum = v(1, m)*(h(k+1, j)+v(2, m)*h(k+2, j)+v(3, m)*h(
     +            k+3, j))
                DO nd=1,nbdirs
                  refsumd(nd) = vd(nd, 1, m)*(h(k+1, j)+v(2, m)*h(k+2, j
     +              )+v(3, m)*h(k+3, j)) + v(1, m)*(hd(nd, k+1, j)+vd(nd
     +              , 2, m)*h(k+2, j)+v(2, m)*hd(nd, k+2, j)+vd(nd, 3, m
     +              )*h(k+3, j)+v(3, m)*hd(nd, k+3, j))
                  hd(nd, k+1, j) = hd(nd, k+1, j) - refsumd(nd)
                  hd(nd, k+2, j) = hd(nd, k+2, j) - refsumd(nd)*v(2, m)
     +              - refsum*vd(nd, 2, m)
                  hd(nd, k+3, j) = hd(nd, k+3, j) - refsumd(nd)*v(3, m)
     +              - refsum*vd(nd, 3, m)
                ENDDO
                h(k+1, j) = h(k+1, j) - refsum
                h(k+2, j) = h(k+2, j) - refsum*v(2, m)
                h(k+3, j) = h(k+3, j) - refsum*v(3, m)
              ENDDO
            ENDDO
            IF (bmp22) THEN
              k = krcol + 3*(m22-1)
              IF (k + 1 .LT. ktop) THEN
                max2 = ktop
              ELSE
                max2 = k + 1
              END IF
              DO j=max2,jbot
                refsum = v(1, m22)*(h(k+1, j)+v(2, m22)*h(k+2, j))
                DO nd=1,nbdirs
                  refsumd(nd) = vd(nd, 1, m22)*(h(k+1, j)+v(2, m22)*h(k+
     +              2, j)) + v(1, m22)*(hd(nd, k+1, j)+vd(nd, 2, m22)*h(
     +              k+2, j)+v(2, m22)*hd(nd, k+2, j))
                  hd(nd, k+1, j) = hd(nd, k+1, j) - refsumd(nd)
                  hd(nd, k+2, j) = hd(nd, k+2, j) - refsumd(nd)*v(2, m22
     +              ) - refsum*vd(nd, 2, m22)
                ENDDO
                h(k+1, j) = h(k+1, j) - refsum
                h(k+2, j) = h(k+2, j) - refsum*v(2, m22)
              ENDDO
            END IF
C
C           ==== Multiply H by reflections from the right.
C           .    Delay filling in the last row until the
C           .    vigilant deflation check is complete. ====
C
            IF (accum) THEN
              IF (ktop .LT. incol) THEN
                jtop = incol
              ELSE
                jtop = ktop
              END IF
            ELSE IF (wantt) THEN
              jtop = 1
            ELSE
              jtop = ktop
            END IF
            DO m=mtop,mbot
              IF (v(1, m) .NE. zero) THEN
                k = krcol + 3*(m-1)
                IF (kbot .GT. k + 3) THEN
                  min2 = k + 3
                ELSE
                  min2 = kbot
                END IF
                DO j=jtop,min2
                  refsum = v(1, m)*(h(j, k+1)+v(2, m)*h(j, k+2)+v(3, m)*
     +              h(j, k+3))
                  DO nd=1,nbdirs
                    refsumd(nd) = vd(nd, 1, m)*(h(j, k+1)+v(2, m)*h(j, k
     +                +2)+v(3, m)*h(j, k+3)) + v(1, m)*(hd(nd, j, k+1)+
     +                vd(nd, 2, m)*h(j, k+2)+v(2, m)*hd(nd, j, k+2)+vd(
     +                nd, 3, m)*h(j, k+3)+v(3, m)*hd(nd, j, k+3))
                    hd(nd, j, k+1) = hd(nd, j, k+1) - refsumd(nd)
                    hd(nd, j, k+2) = hd(nd, j, k+2) - refsumd(nd)*v(2, m
     +                ) - refsum*vd(nd, 2, m)
                    hd(nd, j, k+3) = hd(nd, j, k+3) - refsumd(nd)*v(3, m
     +                ) - refsum*vd(nd, 3, m)
                  ENDDO
                  h(j, k+1) = h(j, k+1) - refsum
                  h(j, k+2) = h(j, k+2) - refsum*v(2, m)
                  h(j, k+3) = h(j, k+3) - refsum*v(3, m)
                ENDDO
C
                IF (accum) THEN
C
C                    ==== Accumulate U. (If necessary, update Z later
C                    .    with with an efficient matrix-matrix
C                    .    multiply.) ====
C
                  kms = k - incol
                  IF (1 .LT. ktop - incol) THEN
                    max3 = ktop - incol
                  ELSE
                    max3 = 1
                  END IF
                  DO j=max3,kdu
                    refsum = v(1, m)*(u(j, kms+1)+v(2, m)*u(j, kms+2)+v(
     +                3, m)*u(j, kms+3))
                    DO nd=1,nbdirs
                      refsumd(nd) = vd(nd, 1, m)*(u(j, kms+1)+v(2, m)*u(
     +                  j, kms+2)+v(3, m)*u(j, kms+3)) + v(1, m)*(ud(nd
     +                  , j, kms+1)+vd(nd, 2, m)*u(j, kms+2)+v(2, m)*ud(
     +                  nd, j, kms+2)+vd(nd, 3, m)*u(j, kms+3)+v(3, m)*
     +                  ud(nd, j, kms+3))
                      ud(nd, j, kms+1) = ud(nd, j, kms+1) - refsumd(nd)
                      ud(nd, j, kms+2) = ud(nd, j, kms+2) - refsumd(nd)*
     +                  v(2, m) - refsum*vd(nd, 2, m)
                      ud(nd, j, kms+3) = ud(nd, j, kms+3) - refsumd(nd)*
     +                  v(3, m) - refsum*vd(nd, 3, m)
                    ENDDO
                    u(j, kms+1) = u(j, kms+1) - refsum
                    u(j, kms+2) = u(j, kms+2) - refsum*v(2, m)
                    u(j, kms+3) = u(j, kms+3) - refsum*v(3, m)
                  ENDDO
                ELSE IF (wantz) THEN
C
C                    ==== U is not accumulated, so update Z
C                    .    now by multiplying by reflections
C                    .    from the right. ====
C
                  DO j=iloz,ihiz
                    refsum = v(1, m)*(z(j, k+1)+v(2, m)*z(j, k+2)+v(3, m
     +                )*z(j, k+3))
                    DO nd=1,nbdirs
                      refsumd(nd) = vd(nd, 1, m)*(z(j, k+1)+v(2, m)*z(j
     +                  , k+2)+v(3, m)*z(j, k+3)) + v(1, m)*(zd(nd, j, k
     +                  +1)+vd(nd, 2, m)*z(j, k+2)+v(2, m)*zd(nd, j, k+2
     +                  )+vd(nd, 3, m)*z(j, k+3)+v(3, m)*zd(nd, j, k+3))
                      zd(nd, j, k+1) = zd(nd, j, k+1) - refsumd(nd)
                      zd(nd, j, k+2) = zd(nd, j, k+2) - refsumd(nd)*v(2
     +                  , m) - refsum*vd(nd, 2, m)
                      zd(nd, j, k+3) = zd(nd, j, k+3) - refsumd(nd)*v(3
     +                  , m) - refsum*vd(nd, 3, m)
                    ENDDO
                    z(j, k+1) = z(j, k+1) - refsum
                    z(j, k+2) = z(j, k+2) - refsum*v(2, m)
                    z(j, k+3) = z(j, k+3) - refsum*v(3, m)
                  ENDDO
                END IF
              END IF
            ENDDO
C
C           ==== Special case: 2-by-2 reflection (if needed) ====
C
            k = krcol + 3*(m22-1)
            IF (bmp22 .AND. v(1, m22) .NE. zero) THEN
              IF (kbot .GT. k + 3) THEN
                min3 = k + 3
              ELSE
                min3 = kbot
              END IF
              DO j=jtop,min3
                refsum = v(1, m22)*(h(j, k+1)+v(2, m22)*h(j, k+2))
                DO nd=1,nbdirs
                  refsumd(nd) = vd(nd, 1, m22)*(h(j, k+1)+v(2, m22)*h(j
     +              , k+2)) + v(1, m22)*(hd(nd, j, k+1)+vd(nd, 2, m22)*h
     +              (j, k+2)+v(2, m22)*hd(nd, j, k+2))
                  hd(nd, j, k+1) = hd(nd, j, k+1) - refsumd(nd)
                  hd(nd, j, k+2) = hd(nd, j, k+2) - refsumd(nd)*v(2, m22
     +              ) - refsum*vd(nd, 2, m22)
                ENDDO
                h(j, k+1) = h(j, k+1) - refsum
                h(j, k+2) = h(j, k+2) - refsum*v(2, m22)
              ENDDO
C
              IF (accum) THEN
                kms = k - incol
                IF (1 .LT. ktop - incol) THEN
                  max4 = ktop - incol
                ELSE
                  max4 = 1
                END IF
                DO j=max4,kdu
                  refsum = v(1, m22)*(u(j, kms+1)+v(2, m22)*u(j, kms+2))
                  DO nd=1,nbdirs
                    refsumd(nd) = vd(nd, 1, m22)*(u(j, kms+1)+v(2, m22)*
     +                u(j, kms+2)) + v(1, m22)*(ud(nd, j, kms+1)+vd(nd,
     +                2, m22)*u(j, kms+2)+v(2, m22)*ud(nd, j, kms+2))
                    ud(nd, j, kms+1) = ud(nd, j, kms+1) - refsumd(nd)
                    ud(nd, j, kms+2) = ud(nd, j, kms+2) - refsumd(nd)*v(
     +                2, m22) - refsum*vd(nd, 2, m22)
                  ENDDO
                  u(j, kms+1) = u(j, kms+1) - refsum
                  u(j, kms+2) = u(j, kms+2) - refsum*v(2, m22)
                ENDDO
              ELSE IF (wantz) THEN
                DO j=iloz,ihiz
                  refsum = v(1, m22)*(z(j, k+1)+v(2, m22)*z(j, k+2))
                  DO nd=1,nbdirs
                    refsumd(nd) = vd(nd, 1, m22)*(z(j, k+1)+v(2, m22)*z(
     +                j, k+2)) + v(1, m22)*(zd(nd, j, k+1)+vd(nd, 2, m22
     +                )*z(j, k+2)+v(2, m22)*zd(nd, j, k+2))
                    zd(nd, j, k+1) = zd(nd, j, k+1) - refsumd(nd)
                    zd(nd, j, k+2) = zd(nd, j, k+2) - refsumd(nd)*v(2,
     +                m22) - refsum*vd(nd, 2, m22)
                  ENDDO
                  z(j, k+1) = z(j, k+1) - refsum
                  z(j, k+2) = z(j, k+2) - refsum*v(2, m22)
                ENDDO
              END IF
            END IF
C
C           ==== Vigilant deflation check ====
C
            mstart = mtop
            IF (krcol + 3*(mstart-1) .LT. ktop) mstart = mstart + 1
            mend = mbot
            IF (bmp22) mend = mend + 1
            IF (krcol .EQ. kbot - 2) mend = mend + 1
            DO m=mstart,mend
              IF (kbot - 1 .GT. krcol + 3*(m-1)) THEN
                k = krcol + 3*(m-1)
              ELSE
                k = kbot - 1
              END IF
C
C              ==== The following convergence test requires that
C              .    the tradition small-compared-to-nearby-diagonals
C              .    criterion and the Ahues & Tisseur (LAWN 122, 1997)
C              .    criteria both be satisfied.  The latter improves
C              .    accuracy in some examples. Falling back on an
C              .    alternate convergence criterion when TST1 or TST2
C              .    is zero (as done here) is traditional but probably
C              .    unnecessary. ====
C
              IF (h(k+1, k) .NE. zero) THEN
                IF (h(k, k) .GE. 0.) THEN
                  abs3 = h(k, k)
                ELSE
                  abs3 = -h(k, k)
                END IF
                IF (h(k+1, k+1) .GE. 0.) THEN
                  abs13 = h(k+1, k+1)
                ELSE
                  abs13 = -h(k+1, k+1)
                END IF
                tst1 = abs3 + abs13
                IF (tst1 .EQ. zero) THEN
                  IF (k .GE. ktop + 1) THEN
                    IF (h(k, k-1) .GE. 0.) THEN
                      abs4 = h(k, k-1)
                    ELSE
                      abs4 = -h(k, k-1)
                    END IF
                    tst1 = tst1 + abs4
                  END IF
                  IF (k .GE. ktop + 2) THEN
                    IF (h(k, k-2) .GE. 0.) THEN
                      abs5 = h(k, k-2)
                    ELSE
                      abs5 = -h(k, k-2)
                    END IF
                    tst1 = tst1 + abs5
                  END IF
                  IF (k .GE. ktop + 3) THEN
                    IF (h(k, k-3) .GE. 0.) THEN
                      abs6 = h(k, k-3)
                    ELSE
                      abs6 = -h(k, k-3)
                    END IF
                    tst1 = tst1 + abs6
                  END IF
                  IF (k .LE. kbot - 2) THEN
                    IF (h(k+2, k+1) .GE. 0.) THEN
                      abs7 = h(k+2, k+1)
                    ELSE
                      abs7 = -h(k+2, k+1)
                    END IF
                    tst1 = tst1 + abs7
                  END IF
                  IF (k .LE. kbot - 3) THEN
                    IF (h(k+3, k+1) .GE. 0.) THEN
                      abs8 = h(k+3, k+1)
                    ELSE
                      abs8 = -h(k+3, k+1)
                    END IF
                    tst1 = tst1 + abs8
                  END IF
                  IF (k .LE. kbot - 4) THEN
                    IF (h(k+4, k+1) .GE. 0.) THEN
                      abs9 = h(k+4, k+1)
                    ELSE
                      abs9 = -h(k+4, k+1)
                    END IF
                    tst1 = tst1 + abs9
                  END IF
                END IF
                IF (h(k+1, k) .GE. 0.) THEN
                  abs10 = h(k+1, k)
                ELSE
                  abs10 = -h(k+1, k)
                END IF
                IF (smlnum .LT. ulp*tst1) THEN
                  max9 = ulp*tst1
                ELSE
                  max9 = smlnum
                END IF
                IF (abs10 .LE. max9) THEN
                  IF (h(k+1, k) .GE. 0.) THEN
                    x1 = h(k+1, k)
                  ELSE
                    x1 = -h(k+1, k)
                  END IF
                  IF (h(k, k+1) .GE. 0.) THEN
                    y1 = h(k, k+1)
                  ELSE
                    y1 = -h(k, k+1)
                  END IF
                  IF (x1 .LT. y1) THEN
                    h12 = y1
                  ELSE
                    h12 = x1
                  END IF
                  IF (h(k+1, k) .GE. 0.) THEN
                    x2 = h(k+1, k)
                  ELSE
                    x2 = -h(k+1, k)
                  END IF
                  IF (h(k, k+1) .GE. 0.) THEN
                    y2 = h(k, k+1)
                  ELSE
                    y2 = -h(k, k+1)
                  END IF
                  IF (x2 .GT. y2) THEN
                    h21 = y2
                  ELSE
                    h21 = x2
                  END IF
                  IF (h(k+1, k+1) .GE. 0.) THEN
                    x3 = h(k+1, k+1)
                  ELSE
                    x3 = -h(k+1, k+1)
                  END IF
                  IF (h(k, k) - h(k+1, k+1) .GE. 0.) THEN
                    y3 = h(k, k) - h(k+1, k+1)
                  ELSE
                    y3 = -(h(k, k)-h(k+1, k+1))
                  END IF
                  IF (x3 .LT. y3) THEN
                    h11 = y3
                  ELSE
                    h11 = x3
                  END IF
                  IF (h(k+1, k+1) .GE. 0.) THEN
                    x4 = h(k+1, k+1)
                  ELSE
                    x4 = -h(k+1, k+1)
                  END IF
                  IF (h(k, k) - h(k+1, k+1) .GE. 0.) THEN
                    y4 = h(k, k) - h(k+1, k+1)
                  ELSE
                    y4 = -(h(k, k)-h(k+1, k+1))
                  END IF
                  IF (x4 .GT. y4) THEN
                    h22 = y4
                  ELSE
                    h22 = x4
                  END IF
                  scl = h11 + h12
                  tst2 = h22*(h11/scl)
                  IF (smlnum .LT. ulp*tst2) THEN
                    max5 = ulp*tst2
                  ELSE
                    max5 = smlnum
                  END IF
C
                  IF (tst2 .EQ. zero .OR. h21*(h12/scl) .LE. max5) THEN
                    DO nd=1,nbdirs
                      hd(nd, k+1, k) = 0.D0
                    ENDDO
                    h(k+1, k) = zero
                  END IF
                END IF
              END IF
            ENDDO
            IF (nbmps .GT. (kbot-krcol-1)/3) THEN
              mend = (kbot-krcol-1)/3
            ELSE
              mend = nbmps
            END IF
            DO m=mtop,mend
              k = krcol + 3*(m-1)
              refsum = v(1, m)*v(3, m)*h(k+4, k+3)
              DO nd=1,nbdirs
                refsumd(nd) = (vd(nd, 1, m)*v(3, m)+v(1, m)*vd(nd, 3, m)
     +            )*h(k+4, k+3) + v(1, m)*v(3, m)*hd(nd, k+4, k+3)
                hd(nd, k+4, k+1) = -refsumd(nd)
                hd(nd, k+4, k+2) = -(refsumd(nd)*v(2, m)+refsum*vd(nd, 2
     +            , m))
                hd(nd, k+4, k+3) = hd(nd, k+4, k+3) - refsumd(nd)*v(3, m
     +            ) - refsum*vd(nd, 3, m)
              ENDDO
              h(k+4, k+1) = -refsum
              h(k+4, k+2) = -(refsum*v(2, m))
              h(k+4, k+3) = h(k+4, k+3) - refsum*v(3, m)
            ENDDO
          ENDDO
C
C           ==== End of near-the-diagonal bulge chase. ====
C
C
C        ==== Use U (if accumulated) to update far-from-diagonal
C        .    entries in H.  If required, use U to update Z as
C        .    well. ====
C
          IF (accum) THEN
            IF (wantt) THEN
              jtop = 1
              jbot = n
            ELSE
              jtop = ktop
              jbot = kbot
            END IF
            IF (.NOT.blk22 .OR. incol .LT. ktop .OR. ndcol .GT. kbot
     +          .OR. ns .LE. 2) THEN
              IF (1 .LT. ktop - incol) THEN
                k1 = ktop - incol
              ELSE
                k1 = 1
              END IF
              IF (0 .LT. ndcol - kbot) THEN
                max6 = ndcol - kbot
              ELSE
                max6 = 0
              END IF
              nu = kdu - max6 - k1 + 1
              IF (ndcol .GT. kbot) THEN
                min4 = kbot
              ELSE
                min4 = ndcol
              END IF
C
C              ==== Horizontal Multiply ====
C
              DO jcol=min4+1,jbot,nh
                IF (nh .GT. jbot - jcol + 1) THEN
                  jlen = jbot - jcol + 1
                ELSE
                  jlen = nh
                END IF
                CALL DGEMM_DV('C', 'N', nu, jlen, nu, one, u(k1, k1), ud
     +                        (1, k1, k1), ldu, h(incol+k1, jcol), hd(1
     +                        , incol+k1, jcol), ldh, zero, wh, whd,
     +                        ldwh, nbdirs)
                CALL DLACPY_DV('ALL', nu, jlen, wh, whd, ldwh, h(incol+
     +                         k1, jcol), hd(1, incol+k1, jcol), ldh,
     +                         nbdirs)
              ENDDO
              IF (ktop .LT. incol) THEN
                max7 = incol
              ELSE
                max7 = ktop
              END IF
C
C              ==== Vertical multiply ====
C
              DO jrow=jtop,max7-1,nv
                IF (ktop .LT. incol) THEN
                  max10 = incol
                ELSE
                  max10 = ktop
                END IF
                y5 = max10 - jrow
                IF (nv .GT. y5) THEN
                  jlen = y5
                ELSE
                  jlen = nv
                END IF
                CALL DGEMM_DV('N', 'N', jlen, nu, nu, one, h(jrow, incol
     +                        +k1), hd(1, jrow, incol+k1), ldh, u(k1, k1
     +                        ), ud(1, k1, k1), ldu, zero, wv, wvd, ldwv
     +                        , nbdirs)
                CALL DLACPY_DV('ALL', jlen, nu, wv, wvd, ldwv, h(jrow,
     +                         incol+k1), hd(1, jrow, incol+k1), ldh,
     +                         nbdirs)
              ENDDO
C
C              ==== Z multiply (also vertical) ====
C
              IF (wantz) THEN
                DO jrow=iloz,ihiz,nv
                  IF (nv .GT. ihiz - jrow + 1) THEN
                    jlen = ihiz - jrow + 1
                  ELSE
                    jlen = nv
                  END IF
                  CALL DGEMM_DV('N', 'N', jlen, nu, nu, one, z(jrow,
     +                          incol+k1), zd(1, jrow, incol+k1), ldz, u
     +                          (k1, k1), ud(1, k1, k1), ldu, zero, wv,
     +                          wvd, ldwv, nbdirs)
                  CALL DLACPY_DV('ALL', jlen, nu, wv, wvd, ldwv, z(jrow
     +                           , incol+k1), zd(1, jrow, incol+k1), ldz
     +                           , nbdirs)
                ENDDO
              END IF
            ELSE
C
C              ==== Updates exploiting U's 2-by-2 block structure.
C              .    (I2, I4, J2, J4 are the last rows and columns
C              .    of the blocks.) ====
C
              i2 = (kdu+1)/2
              i4 = kdu
              j2 = i4 - i2
              j4 = kdu
C
C              ==== KZS and KNZ deal with the band of zeros
C              .    along the diagonal of one of the triangular
C              .    blocks. ====
C
              kzs = j4 - j2 - (ns+1)
              knz = ns + 1
              IF (ndcol .GT. kbot) THEN
                min5 = kbot
              ELSE
                min5 = ndcol
              END IF
C
C              ==== Horizontal multiply ====
C
              DO jcol=min5+1,jbot,nh
                IF (nh .GT. jbot - jcol + 1) THEN
                  jlen = jbot - jcol + 1
                ELSE
                  jlen = nh
                END IF
C
C                 ==== Copy bottom of H to top+KZS of scratch ====
C                  (The first KZS rows get multiplied by zero.) ====
C
                CALL DLACPY_DV('ALL', knz, jlen, h(incol+1+j2, jcol), hd
     +                         (1, incol+1+j2, jcol), ldh, wh(kzs+1, 1)
     +                         , whd(1, kzs+1, 1), ldwh, nbdirs)
C
C                 ==== Multiply by U21' ====
C
                CALL DLASET_DV('ALL', kzs, jlen, zero, zero, wh, whd,
     +                         ldwh, nbdirs)
                CALL DTRMM_DV('L', 'U', 'C', 'N', knz, jlen, one, u(j2+1
     +                        , 1+kzs), ud(1, j2+1, 1+kzs), ldu, wh(kzs+
     +                        1, 1), whd(1, kzs+1, 1), ldwh, nbdirs)
C
C                 ==== Multiply top of H by U11' ====
C
                CALL DGEMM_DV('C', 'N', i2, jlen, j2, one, u, ud, ldu, h
     +                        (incol+1, jcol), hd(1, incol+1, jcol), ldh
     +                        , one, wh, whd, ldwh, nbdirs)
C
C                 ==== Copy top of H bottom of WH ====
C
                CALL DLACPY_DV('ALL', j2, jlen, h(incol+1, jcol), hd(1,
     +                         incol+1, jcol), ldh, wh(i2+1, 1), whd(1,
     +                         i2+1, 1), ldwh, nbdirs)
C
C                 ==== Multiply by U21' ====
C
                CALL DTRMM_DV('L', 'L', 'C', 'N', j2, jlen, one, u(1, i2
     +                        +1), ud(1, 1, i2+1), ldu, wh(i2+1, 1), whd
     +                        (1, i2+1, 1), ldwh, nbdirs)
C
C                 ==== Multiply by U22 ====
C
                arg1 = i4 - i2
                arg2 = j4 - j2
                CALL DGEMM_DV('C', 'N', arg1, jlen, arg2, one, u(j2+1,
     +                        i2+1), ud(1, j2+1, i2+1), ldu, h(incol+1+
     +                        j2, jcol), hd(1, incol+1+j2, jcol), ldh,
     +                        one, wh(i2+1, 1), whd(1, i2+1, 1), ldwh,
     +                        nbdirs)
C
C                 ==== Copy it back ====
C
                CALL DLACPY_DV('ALL', kdu, jlen, wh, whd, ldwh, h(incol+
     +                         1, jcol), hd(1, incol+1, jcol), ldh,
     +                         nbdirs)
              ENDDO
              IF (incol .LT. ktop) THEN
                max8 = ktop
              ELSE
                max8 = incol
              END IF
C
C              ==== Vertical multiply ====
C
              DO jrow=jtop,max8-1,nv
                IF (incol .LT. ktop) THEN
                  max11 = ktop
                ELSE
                  max11 = incol
                END IF
                y6 = max11 - jrow
                IF (nv .GT. y6) THEN
                  jlen = y6
                ELSE
                  jlen = nv
                END IF
C
C                 ==== Copy right of H to scratch (the first KZS
C                 .    columns get multiplied by zero) ====
C
                CALL DLACPY_DV('ALL', jlen, knz, h(jrow, incol+1+j2), hd
     +                         (1, jrow, incol+1+j2), ldh, wv(1, 1+kzs)
     +                         , wvd(1, 1, 1+kzs), ldwv, nbdirs)
C
C                 ==== Multiply by U21 ====
C
                CALL DLASET_DV('ALL', jlen, kzs, zero, zero, wv, wvd,
     +                         ldwv, nbdirs)
                CALL DTRMM_DV('R', 'U', 'N', 'N', jlen, knz, one, u(j2+1
     +                        , 1+kzs), ud(1, j2+1, 1+kzs), ldu, wv(1, 1
     +                        +kzs), wvd(1, 1, 1+kzs), ldwv, nbdirs)
C
C                 ==== Multiply by U11 ====
C
                CALL DGEMM_DV('N', 'N', jlen, i2, j2, one, h(jrow, incol
     +                        +1), hd(1, jrow, incol+1), ldh, u, ud, ldu
     +                        , one, wv, wvd, ldwv, nbdirs)
C
C                 ==== Copy left of H to right of scratch ====
C
                CALL DLACPY_DV('ALL', jlen, j2, h(jrow, incol+1), hd(1,
     +                         jrow, incol+1), ldh, wv(1, 1+i2), wvd(1,
     +                         1, 1+i2), ldwv, nbdirs)
C
C                 ==== Multiply by U21 ====
C
                arg1 = i4 - i2
                CALL DTRMM_DV('R', 'L', 'N', 'N', jlen, arg1, one, u(1,
     +                        i2+1), ud(1, 1, i2+1), ldu, wv(1, 1+i2),
     +                        wvd(1, 1, 1+i2), ldwv, nbdirs)
C
C                 ==== Multiply by U22 ====
C
                arg1 = i4 - i2
                arg2 = j4 - j2
                CALL DGEMM_DV('N', 'N', jlen, arg1, arg2, one, h(jrow,
     +                        incol+1+j2), hd(1, jrow, incol+1+j2), ldh
     +                        , u(j2+1, i2+1), ud(1, j2+1, i2+1), ldu,
     +                        one, wv(1, 1+i2), wvd(1, 1, 1+i2), ldwv,
     +                        nbdirs)
C
C                 ==== Copy it back ====
C
                CALL DLACPY_DV('ALL', jlen, kdu, wv, wvd, ldwv, h(jrow,
     +                         incol+1), hd(1, jrow, incol+1), ldh,
     +                         nbdirs)
              ENDDO
C
C              ==== Multiply Z (also vertical) ====
C
              IF (wantz) THEN
                DO jrow=iloz,ihiz,nv
                  IF (nv .GT. ihiz - jrow + 1) THEN
                    jlen = ihiz - jrow + 1
                  ELSE
                    jlen = nv
                  END IF
C
C                    ==== Copy right of Z to left of scratch (first
C                    .     KZS columns get multiplied by zero) ====
C
                  CALL DLACPY_DV('ALL', jlen, knz, z(jrow, incol+1+j2),
     +                           zd(1, jrow, incol+1+j2), ldz, wv(1, 1+
     +                           kzs), wvd(1, 1, 1+kzs), ldwv, nbdirs)
C
C                    ==== Multiply by U12 ====
C
                  CALL DLASET_DV('ALL', jlen, kzs, zero, zero, wv, wvd,
     +                           ldwv, nbdirs)
                  CALL DTRMM_DV('R', 'U', 'N', 'N', jlen, knz, one, u(j2
     +                          +1, 1+kzs), ud(1, j2+1, 1+kzs), ldu, wv(
     +                          1, 1+kzs), wvd(1, 1, 1+kzs), ldwv,
     +                          nbdirs)
C
C                    ==== Multiply by U11 ====
C
                  CALL DGEMM_DV('N', 'N', jlen, i2, j2, one, z(jrow,
     +                          incol+1), zd(1, jrow, incol+1), ldz, u,
     +                          ud, ldu, one, wv, wvd, ldwv, nbdirs)
C
C                    ==== Copy left of Z to right of scratch ====
C
                  CALL DLACPY_DV('ALL', jlen, j2, z(jrow, incol+1), zd(1
     +                           , jrow, incol+1), ldz, wv(1, 1+i2), wvd
     +                           (1, 1, 1+i2), ldwv, nbdirs)
C
C                    ==== Multiply by U21 ====
C
                  arg1 = i4 - i2
                  CALL DTRMM_DV('R', 'L', 'N', 'N', jlen, arg1, one, u(1
     +                          , i2+1), ud(1, 1, i2+1), ldu, wv(1, 1+i2
     +                          ), wvd(1, 1, 1+i2), ldwv, nbdirs)
C
C                    ==== Multiply by U22 ====
C
                  arg1 = i4 - i2
                  arg2 = j4 - j2
                  CALL DGEMM_DV('N', 'N', jlen, arg1, arg2, one, z(jrow
     +                          , incol+1+j2), zd(1, jrow, incol+1+j2),
     +                          ldz, u(j2+1, i2+1), ud(1, j2+1, i2+1),
     +                          ldu, one, wv(1, 1+i2), wvd(1, 1, 1+i2),
     +                          ldwv, nbdirs)
C
C                    ==== Copy the result back to Z ====
C
                  CALL DLACPY_DV('ALL', jlen, kdu, wv, wvd, ldwv, z(jrow
     +                           , incol+1), zd(1, jrow, incol+1), ldz,
     +                           nbdirs)
                ENDDO
              END IF
            END IF
          END IF
        ENDDO
      END IF
      END

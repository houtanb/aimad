!
! Copyright (C) 2006-2014 Houtan Bastani and Luca Guerrieri
!
!
! This free software: you can redistribute it and/or modify
! it under the terms of the GNU General Public License as published by
! the Free Software Foundation, either version 3 of the License, or
! (at your option) any later version.
!
! It is distributed in the hope that it will be useful,
! but WITHOUT ANY WARRANTY; without even the implied warranty of
! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
! GNU General Public License for more details.
!
! You should have received a copy of the GNU General Public License
! along with Dynare.  If not, see <http://www.gnu.org/licenses/>.
!

C        Generated by TAPENADE     (INRIA, Tropics team)
C  Tapenade - Version 2.2 (r1239) - Wed 28 Jun 2006 04:59:55 PM CEST
C
C  Differentiation of dlartg in forward (tangent) mode: (multi-directional mode)
C   variations  of output variables: sn cs
C   with respect to input variables: f g
      SUBROUTINE DLARTG_DV(f, fd, g, gd, cs, csd, sn, snd, r, nbdirs)
      USE DIFFSIZES
      IMPLICIT NONE
C
C     End of DLARTG
C
      INTEGER nbdirs
      DOUBLE PRECISION cs, csd(nbdirsmax), f, fd(nbdirsmax), g, gd(
     +                 nbdirsmax), r, sn, snd(nbdirsmax)
      DOUBLE PRECISION one
      PARAMETER (one=1.0d0)
      DOUBLE PRECISION two
      PARAMETER (two=2.0d0)
      DOUBLE PRECISION zero
      PARAMETER (zero=0.0d0)
      DOUBLE PRECISION arg2, DLAMCH, pwx1
      INTEGER count, i, nd, pwy1
      DOUBLE PRECISION abs1, abs2, rd(nbdirsmax)
      DOUBLE PRECISION arg1, arg1d(nbdirsmax), arg3, eps, f1, f1d(
     +                 nbdirsmax), g1, g1d(nbdirsmax), safmin, safmn2,
     +                 safmx2, scale, x1, x2, x3, y1, y2, y3
      EXTERNAL DLAMCH
      INTRINSIC MAX, ABS, LOG, INT, SQRT
C
C  -- LAPACK auxiliary routine (version 3.1) --
C     Univ. of Tennessee, Univ. of California Berkeley and NAG Ltd..
C     November 2006
C
C     .. Scalar Arguments ..
C     ..
C
C  Purpose
C  =======
C
C  DLARTG generate a plane rotation so that
C
C     [  CS  SN  ]  .  [ F ]  =  [ R ]   where CS**2 + SN**2 = 1.
C     [ -SN  CS  ]     [ G ]     [ 0 ]
C
C  This is a slower, more accurate version of the BLAS1 routine DROTG,
C  with the following other differences:
C     F and G are unchanged on return.
C     If G=0, then CS=1 and SN=0.
C     If F=0 and (G .ne. 0), then CS=0 and SN=1 without doing any
C        floating point operations (saves work in DBDSQR when
C        there are zeros on the diagonal).
C
C  If F exceeds G in magnitude, CS will be positive.
C
C  Arguments
C  =========
C
C  F       (input) DOUBLE PRECISION
C          The first component of vector to be rotated.
C
C  G       (input) DOUBLE PRECISION
C          The second component of vector to be rotated.
C
C  CS      (output) DOUBLE PRECISION
C          The cosine of the rotation.
C
C  SN      (output) DOUBLE PRECISION
C          The sine of the rotation.
C
C  R       (output) DOUBLE PRECISION
C          The nonzero component of the rotated vector.
C
C  This version has a few statements commented out for thread safety
C  (machine parameters are computed on each entry). 10 feb 03, SJH.
C
C  =====================================================================
C
C     .. Parameters ..
C     ..
C     .. Local Scalars ..
C     LOGICAL            FIRST
C     ..
C     .. External Functions ..
C     ..
C     .. Intrinsic Functions ..
C     ..
C     .. Save statement ..
C     SAVE               FIRST, SAFMX2, SAFMIN, SAFMN2
C     ..
C     .. Data statements ..
C     DATA               FIRST / .TRUE. /
C     ..
C     .. Executable Statements ..
C
C     IF( FIRST ) THEN
      safmin = DLAMCH('S')
      eps = DLAMCH('E')
      pwx1 = DLAMCH('B')
      arg1 = safmin/eps
      arg2 = DLAMCH('B')
      arg3 = LOG(arg1)/LOG(arg2)/two
      pwy1 = INT(arg3)
      safmn2 = pwx1**pwy1
      safmx2 = one/safmn2
C        FIRST = .FALSE.
C     END IF
      IF (g .EQ. zero) THEN
        cs = one
        sn = zero
        r = f
        DO nd=1,nbdirs
          snd(nd) = 0.D0
        ENDDO
        DO nd=1,nbdirs
          csd(nd) = 0.D0
        ENDDO
      ELSE IF (f .EQ. zero) THEN
        cs = zero
        sn = one
        r = g
        DO nd=1,nbdirs
          snd(nd) = 0.D0
        ENDDO
        DO nd=1,nbdirs
          csd(nd) = 0.D0
        ENDDO
      ELSE
        DO nd=1,nbdirs
          f1d(nd) = fd(nd)
          g1d(nd) = gd(nd)
        ENDDO
        f1 = f
        g1 = g
        IF (f1 .GE. 0.) THEN
          x1 = f1
        ELSE
          x1 = -f1
        END IF
        IF (g1 .GE. 0.) THEN
          y1 = g1
        ELSE
          y1 = -g1
        END IF
        IF (x1 .LT. y1) THEN
          scale = y1
        ELSE
          scale = x1
        END IF
        IF (scale .GE. safmx2) THEN
          count = 0
 10       count = count + 1
          DO nd=1,nbdirs
            f1d(nd) = safmn2*f1d(nd)
            g1d(nd) = safmn2*g1d(nd)
          ENDDO
          f1 = f1*safmn2
          g1 = g1*safmn2
          IF (f1 .GE. 0.) THEN
            x2 = f1
          ELSE
            x2 = -f1
          END IF
          IF (g1 .GE. 0.) THEN
            y2 = g1
          ELSE
            y2 = -g1
          END IF
          IF (x2 .LT. y2) THEN
            scale = y2
          ELSE
            scale = x2
          END IF
          IF (scale .GE. safmx2) GOTO 10
          arg1 = f1**2 + g1**2
          r = SQRT(arg1)
          DO nd=1,nbdirs
            arg1d(nd) = 2*f1*f1d(nd) + 2*g1*g1d(nd)
            IF (arg1d(nd) .EQ. 0.0 .OR. arg1 .EQ. 0.0) THEN
              rd(nd) = 0.D0
            ELSE
              rd(nd) = arg1d(nd)/(2.0*SQRT(arg1))
            END IF
            snd(nd) = (g1d(nd)*r-g1*rd(nd))/r**2
            csd(nd) = (f1d(nd)*r-f1*rd(nd))/r**2
          ENDDO
          cs = f1/r
          sn = g1/r
          DO i=1,count
            r = r*safmx2
          ENDDO
        ELSE IF (scale .LE. safmn2) THEN
          count = 0
 30       count = count + 1
          DO nd=1,nbdirs
            f1d(nd) = safmx2*f1d(nd)
            g1d(nd) = safmx2*g1d(nd)
          ENDDO
          f1 = f1*safmx2
          g1 = g1*safmx2
          IF (f1 .GE. 0.) THEN
            x3 = f1
          ELSE
            x3 = -f1
          END IF
          IF (g1 .GE. 0.) THEN
            y3 = g1
          ELSE
            y3 = -g1
          END IF
          IF (x3 .LT. y3) THEN
            scale = y3
          ELSE
            scale = x3
          END IF
          IF (scale .LE. safmn2) GOTO 30
          arg1 = f1**2 + g1**2
          r = SQRT(arg1)
          DO nd=1,nbdirs
            arg1d(nd) = 2*f1*f1d(nd) + 2*g1*g1d(nd)
            IF (arg1d(nd) .EQ. 0.0 .OR. arg1 .EQ. 0.0) THEN
              rd(nd) = 0.D0
            ELSE
              rd(nd) = arg1d(nd)/(2.0*SQRT(arg1))
            END IF
            snd(nd) = (g1d(nd)*r-g1*rd(nd))/r**2
            csd(nd) = (f1d(nd)*r-f1*rd(nd))/r**2
          ENDDO
          cs = f1/r
          sn = g1/r
          DO i=1,count
            r = r*safmn2
          ENDDO
        ELSE
          arg1 = f1**2 + g1**2
          r = SQRT(arg1)
          DO nd=1,nbdirs
            arg1d(nd) = 2*f1*f1d(nd) + 2*g1*g1d(nd)
            IF (arg1d(nd) .EQ. 0.0 .OR. arg1 .EQ. 0.0) THEN
              rd(nd) = 0.D0
            ELSE
              rd(nd) = arg1d(nd)/(2.0*SQRT(arg1))
            END IF
            snd(nd) = (g1d(nd)*r-g1*rd(nd))/r**2
            csd(nd) = (f1d(nd)*r-f1*rd(nd))/r**2
          ENDDO
          cs = f1/r
          sn = g1/r
        END IF
        IF (f .GE. 0.) THEN
          abs1 = f
        ELSE
          abs1 = -f
        END IF
        IF (g .GE. 0.) THEN
          abs2 = g
        ELSE
          abs2 = -g
        END IF
        IF (abs1 .GT. abs2 .AND. cs .LT. zero) THEN
          DO nd=1,nbdirs
            csd(nd) = -csd(nd)
            snd(nd) = -snd(nd)
          ENDDO
          cs = -cs
          sn = -sn
          r = -r
        END IF
      END IF
      RETURN
      END

!
! Copyright (C) 2006-2014 Houtan Bastani and Luca Guerrieri
!
!
! This free software: you can redistribute it and/or modify
! it under the terms of the GNU General Public License as published by
! the Free Software Foundation, either version 3 of the License, or
! (at your option) any later version.
!
! It is distributed in the hope that it will be useful,
! but WITHOUT ANY WARRANTY; without even the implied warranty of
! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
! GNU General Public License for more details.
!
! You should have received a copy of the GNU General Public License
! along with Dynare.  If not, see <http://www.gnu.org/licenses/>.
!

C        Generated by TAPENADE     (INRIA, Tropics team)
C  Tapenade - Version 2.2 (r1239) - Wed 28 Jun 2006 04:59:55 PM CEST
C
C  Differentiation of dlascl in forward (tangent) mode: (multi-directional mode)
C   variations  of output variables: a
C   with respect to input variables: cto cfrom a
      SUBROUTINE DLASCL_DV(type, kl, ku, cfrom, cfromd, cto, ctod, m, n
     +                     , a, ad, lda, info, nbdirs)
      USE DIFFSIZES
      IMPLICIT NONE
C
C     End of DLASCL
C
      INTEGER info, kl, ku, m, n
      INTEGER lda, nbdirs
      DOUBLE PRECISION a(lda, *), ad(nbdirsmax, lda, *)
      DOUBLE PRECISION cfrom, cfromd(nbdirsmax), cto, ctod(nbdirsmax)
      CHARACTER type
      DOUBLE PRECISION one, zero
      PARAMETER (one=1.0d0, zero=0.0d0)
      DOUBLE PRECISION DLAMCH
      LOGICAL done, LSAME, result1
      INTEGER arg1, i, itype, j, k1, k2, k3, k4, max1, max2, max3, max4
     +        , max5, min1, min2, min3, min4, nd
      DOUBLE PRECISION abs1, abs2, abs3, abs4, bignum, cfrom1, cfrom1d(
     +                 nbdirsmax), cfromc, cfromcd(nbdirsmax), cto1,
     +                 cto1d(nbdirsmax), ctoc, ctocd(nbdirsmax), mul,
     +                 muld(nbdirsmax), smlnum
      INTRINSIC MAX, ABS, MIN
      EXTERNAL XERBLA, LSAME, DLAMCH
C
C  -- LAPACK auxiliary routine (version 3.1) --
C     Univ. of Tennessee, Univ. of California Berkeley and NAG Ltd..
C     November 2006
C
C     .. Scalar Arguments ..
C     ..
C     .. Array Arguments ..
C     ..
C
C  Purpose
C  =======
C
C  DLASCL multiplies the M by N real matrix A by the real scalar
C  CTO/CFROM.  This is done without over/underflow as long as the final
C  result CTO*A(I,J)/CFROM does not over/underflow. TYPE specifies that
C  A may be full, upper triangular, lower triangular, upper Hessenberg,
C  or banded.
C
C  Arguments
C  =========
C
C  TYPE    (input) CHARACTER*1
C          TYPE indices the storage type of the input matrix.
C          = 'G':  A is a full matrix.
C          = 'L':  A is a lower triangular matrix.
C          = 'U':  A is an upper triangular matrix.
C          = 'H':  A is an upper Hessenberg matrix.
C          = 'B':  A is a symmetric band matrix with lower bandwidth KL
C                  and upper bandwidth KU and with the only the lower
C                  half stored.
C          = 'Q':  A is a symmetric band matrix with lower bandwidth KL
C                  and upper bandwidth KU and with the only the upper
C                  half stored.
C          = 'Z':  A is a band matrix with lower bandwidth KL and upper
C                  bandwidth KU.
C
C  KL      (input) INTEGER
C          The lower bandwidth of A.  Referenced only if TYPE = 'B',
C          'Q' or 'Z'.
C
C  KU      (input) INTEGER
C          The upper bandwidth of A.  Referenced only if TYPE = 'B',
C          'Q' or 'Z'.
C
C  CFROM   (input) DOUBLE PRECISION
C  CTO     (input) DOUBLE PRECISION
C          The matrix A is multiplied by CTO/CFROM. A(I,J) is computed
C          without over/underflow if the final result CTO*A(I,J)/CFROM
C          can be represented without over/underflow.  CFROM must be
C          nonzero.
C
C  M       (input) INTEGER
C          The number of rows of the matrix A.  M >= 0.
C
C  N       (input) INTEGER
C          The number of columns of the matrix A.  N >= 0.
C
C  A       (input/output) DOUBLE PRECISION array, dimension (LDA,N)
C          The matrix to be multiplied by CTO/CFROM.  See TYPE for the
C          storage type.
C
C  LDA     (input) INTEGER
C          The leading dimension of the array A.  LDA >= max(1,M).
C
C  INFO    (output) INTEGER
C          0  - successful exit
C          <0 - if INFO = -i, the i-th argument had an illegal value.
C
C  =====================================================================
C
C     .. Parameters ..
C     ..
C     .. Local Scalars ..
C     ..
C     .. External Functions ..
C     ..
C     .. Intrinsic Functions ..
C     ..
C     .. External Subroutines ..
C     ..
C     .. Executable Statements ..
C
C     Test the input arguments
C
      info = 0
C
      result1 = LSAME(type, 'G')
      IF (result1) THEN
        itype = 0
      ELSE
        result1 = LSAME(type, 'L')
        IF (result1) THEN
          itype = 1
        ELSE
          result1 = LSAME(type, 'U')
          IF (result1) THEN
            itype = 2
          ELSE
            result1 = LSAME(type, 'H')
            IF (result1) THEN
              itype = 3
            ELSE
              result1 = LSAME(type, 'B')
              IF (result1) THEN
                itype = 4
              ELSE
                result1 = LSAME(type, 'Q')
                IF (result1) THEN
                  itype = 5
                ELSE
                  result1 = LSAME(type, 'Z')
                  IF (result1) THEN
                    itype = 6
                  ELSE
                    itype = -1
                  END IF
                END IF
              END IF
            END IF
          END IF
        END IF
      END IF
C
      IF (itype .EQ. -1) THEN
        info = -1
      ELSE IF (cfrom .EQ. zero) THEN
        info = -4
      ELSE IF (m .LT. 0) THEN
        info = -6
      ELSE IF (n .LT. 0 .OR. itype .EQ. 4 .AND. n .NE. m .OR. itype .EQ.
     +    5 .AND. n .NE. m) THEN
        info = -7
      ELSE
        IF (1 .LT. m) THEN
          max1 = m
        ELSE
          max1 = 1
        END IF
        IF (itype .LE. 3 .AND. lda .LT. max1) THEN
          info = -9
        ELSE IF (itype .GE. 4) THEN
          IF (m - 1 .LT. 0) THEN
            max2 = 0
          ELSE
            max2 = m - 1
          END IF
          IF (kl .LT. 0 .OR. kl .GT. max2) THEN
            info = -2
          ELSE
            IF (n - 1 .LT. 0) THEN
              max3 = 0
            ELSE
              max3 = n - 1
            END IF
            IF (ku .LT. 0 .OR. ku .GT. max3 .OR. (itype .EQ. 4 .OR.
     +          itype .EQ. 5) .AND. kl .NE. ku) THEN
              info = -3
            ELSE IF (itype .EQ. 4 .AND. lda .LT. kl + 1 .OR. itype .EQ.
     +          5 .AND. lda .LT. ku + 1 .OR. itype .EQ. 6 .AND. lda .LT.
     +          2*kl + ku + 1) THEN
              info = -9
            END IF
          END IF
        END IF
      END IF
C
      IF (info .NE. 0) THEN
        arg1 = -info
        CALL XERBLA('DLASCL', arg1)
        RETURN
      ELSE IF (n .EQ. 0 .OR. m .EQ. 0) THEN
C
C     Quick return if possible
C
        RETURN
      ELSE
C
C     Get machine parameters
C
        smlnum = DLAMCH('S')
        bignum = one/smlnum
        DO nd=1,nbdirs
          cfromcd(nd) = cfromd(nd)
          ctocd(nd) = ctod(nd)
        ENDDO
C
        cfromc = cfrom
        ctoc = cto
 10     DO nd=1,nbdirs
          cfrom1d(nd) = smlnum*cfromcd(nd)
          cto1d(nd) = ctocd(nd)/bignum
        ENDDO
C
        cfrom1 = cfromc*smlnum
        cto1 = ctoc/bignum
        IF (cfrom1 .GE. 0.) THEN
          abs1 = cfrom1
        ELSE
          abs1 = -cfrom1
        END IF
        IF (ctoc .GE. 0.) THEN
          abs3 = ctoc
        ELSE
          abs3 = -ctoc
        END IF
        IF (abs1 .GT. abs3 .AND. ctoc .NE. zero) THEN
          mul = smlnum
          done = .false.
          DO nd=1,nbdirs
            cfromcd(nd) = cfrom1d(nd)
          ENDDO
          cfromc = cfrom1
          DO nd=1,nbdirs
            muld(nd) = 0.D0
          ENDDO
        ELSE
          IF (cto1 .GE. 0.) THEN
            abs2 = cto1
          ELSE
            abs2 = -cto1
          END IF
          IF (cfromc .GE. 0.) THEN
            abs4 = cfromc
          ELSE
            abs4 = -cfromc
          END IF
          IF (abs2 .GT. abs4) THEN
            mul = bignum
            done = .false.
            DO nd=1,nbdirs
              ctocd(nd) = cto1d(nd)
            ENDDO
            ctoc = cto1
            DO nd=1,nbdirs
              muld(nd) = 0.D0
            ENDDO
          ELSE
            DO nd=1,nbdirs
              muld(nd) = (ctocd(nd)*cfromc-ctoc*cfromcd(nd))/cfromc**2
            ENDDO
            mul = ctoc/cfromc
            done = .true.
          END IF
        END IF
C
        IF (itype .EQ. 0) THEN
C
C        Full matrix
C
          DO j=1,n
            DO i=1,m
              DO nd=1,nbdirs
                ad(nd, i, j) = ad(nd, i, j)*mul + a(i, j)*muld(nd)
              ENDDO
              a(i, j) = a(i, j)*mul
            ENDDO
          ENDDO
        ELSE IF (itype .EQ. 1) THEN
C
C
C        Lower triangular matrix
C
          DO j=1,n
            DO i=j,m
              DO nd=1,nbdirs
                ad(nd, i, j) = ad(nd, i, j)*mul + a(i, j)*muld(nd)
              ENDDO
              a(i, j) = a(i, j)*mul
            ENDDO
          ENDDO
        ELSE IF (itype .EQ. 2) THEN
C
C
C        Upper triangular matrix
C
          DO j=1,n
            IF (j .GT. m) THEN
              min1 = m
            ELSE
              min1 = j
            END IF
            DO i=1,min1
              DO nd=1,nbdirs
                ad(nd, i, j) = ad(nd, i, j)*mul + a(i, j)*muld(nd)
              ENDDO
              a(i, j) = a(i, j)*mul
            ENDDO
          ENDDO
        ELSE IF (itype .EQ. 3) THEN
C
C
C        Upper Hessenberg matrix
C
          DO j=1,n
            IF (j + 1 .GT. m) THEN
              min2 = m
            ELSE
              min2 = j + 1
            END IF
            DO i=1,min2
              DO nd=1,nbdirs
                ad(nd, i, j) = ad(nd, i, j)*mul + a(i, j)*muld(nd)
              ENDDO
              a(i, j) = a(i, j)*mul
            ENDDO
          ENDDO
        ELSE IF (itype .EQ. 4) THEN
C
C
C        Lower half of a symmetric band matrix
C
          k3 = kl + 1
          k4 = n + 1
          DO j=1,n
            IF (k3 .GT. k4 - j) THEN
              min3 = k4 - j
            ELSE
              min3 = k3
            END IF
            DO i=1,min3
              DO nd=1,nbdirs
                ad(nd, i, j) = ad(nd, i, j)*mul + a(i, j)*muld(nd)
              ENDDO
              a(i, j) = a(i, j)*mul
            ENDDO
          ENDDO
        ELSE IF (itype .EQ. 5) THEN
C
C
C        Upper half of a symmetric band matrix
C
          k1 = ku + 2
          k3 = ku + 1
          DO j=1,n
            IF (k1 - j .LT. 1) THEN
              max4 = 1
            ELSE
              max4 = k1 - j
            END IF
            DO i=max4,k3
              DO nd=1,nbdirs
                ad(nd, i, j) = ad(nd, i, j)*mul + a(i, j)*muld(nd)
              ENDDO
              a(i, j) = a(i, j)*mul
            ENDDO
          ENDDO
        ELSE IF (itype .EQ. 6) THEN
C
C
C        Band matrix
C
          k1 = kl + ku + 2
          k2 = kl + 1
          k3 = 2*kl + ku + 1
          k4 = kl + ku + 1 + m
          DO j=1,n
            IF (k1 - j .LT. k2) THEN
              max5 = k2
            ELSE
              max5 = k1 - j
            END IF
            IF (k3 .GT. k4 - j) THEN
              min4 = k4 - j
            ELSE
              min4 = k3
            END IF
            DO i=max5,min4
              DO nd=1,nbdirs
                ad(nd, i, j) = ad(nd, i, j)*mul + a(i, j)*muld(nd)
              ENDDO
              a(i, j) = a(i, j)*mul
            ENDDO
          ENDDO
        END IF
C
C
        IF (.NOT.done) GOTO 10
C
        RETURN
      END IF
      END

!
! Copyright (C) 2006-2014 Houtan Bastani and Luca Guerrieri
!
!
! This free software: you can redistribute it and/or modify
! it under the terms of the GNU General Public License as published by
! the Free Software Foundation, either version 3 of the License, or
! (at your option) any later version.
!
! It is distributed in the hope that it will be useful,
! but WITHOUT ANY WARRANTY; without even the implied warranty of
! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
! GNU General Public License for more details.
!
! You should have received a copy of the GNU General Public License
! along with Dynare.  If not, see <http://www.gnu.org/licenses/>.
!

C        Generated by TAPENADE     (INRIA, Tropics team)
C  Tapenade - Version 2.2 (r1239) - Wed 28 Jun 2006 04:59:55 PM CEST
C
C  Differentiation of dlaexc in forward (tangent) mode: (multi-directional mode)
C   variations  of output variables: q t work
C   with respect to input variables: q t work
      SUBROUTINE DLAEXC_DV(wantq, n, t, td, ldt, q, qd, ldq, j1, n1, n2
     +                     , work, workd, info, nbdirs)
      USE DIFFSIZES
      IMPLICIT NONE
C
C     End of DLAEXC
C
      INTEGER info, j1, n, n1, n2
      INTEGER ldq, ldt, nbdirs
      DOUBLE PRECISION q(ldq, *), qd(nbdirsmax, ldq, *), t(ldt, *), td(
     +                 nbdirsmax, ldt, *), work(*), workd(nbdirsmax, *)
      LOGICAL wantq
      INTEGER ldd, ldx
      PARAMETER (ldd=4, ldx=2)
      DOUBLE PRECISION one, zero
      PARAMETER (one=1.0d+0, zero=0.0d+0)
      DOUBLE PRECISION ten
      PARAMETER (ten=1.0d+1)
      DOUBLE PRECISION DLANGE
      INTEGER arg10, ierr, ii2, ii3, j2, j3, j4, k, nd, nd0
      DOUBLE PRECISION DLAMCH, result1
      DOUBLE PRECISION arg1, arg1d(nbdirsmax), cs, csd(nbdirsmax), dnorm
     +                 , dnormd(nbdirsmax), eps, scale, scaled(nbdirsmax
     +                 ), smlnum, sn, snd(nbdirsmax), t11, t11d(
     +                 nbdirsmax), t22, t22d(nbdirsmax), t33, t33d(
     +                 nbdirsmax), tau, tau1, tau1d(nbdirsmax), tau2,
     +                 tau2d(nbdirsmax), taud(nbdirsmax), temp, tempd(
     +                 nbdirsmax), thresh, wi1, wi1d(nbdirsmax), wi2,
     +                 wi2d(nbdirsmax), wr1, wr1d(nbdirsmax), wr2, wr2d(
     +                 nbdirsmax), xnorm
      DOUBLE PRECISION abs1, abs2, abs3, abs4, d(ldd, 4), dd(nbdirsmax,
     +                 ldd, 4), max1, max2, u(3), u1(3), u1d(nbdirsmax,
     +                 3), u2(3), u2d(nbdirsmax, 3), ud(nbdirsmax, 3), x
     +                 (ldx, 2), x1, x2, xd(nbdirsmax, ldx, 2), y1, y2,
     +                 z1, z2
      EXTERNAL DLAMCH
      INTRINSIC MAX, ABS
C
C  -- LAPACK auxiliary routine (version 3.1) --
C     Univ. of Tennessee, Univ. of California Berkeley and NAG Ltd..
C     November 2006
C
C     .. Scalar Arguments ..
C     ..
C     .. Array Arguments ..
C     ..
C
C  Purpose
C  =======
C
C  DLAEXC swaps adjacent diagonal blocks T11 and T22 of order 1 or 2 in
C  an upper quasi-triangular matrix T by an orthogonal similarity
C  transformation.
C
C  T must be in Schur canonical form, that is, block upper triangular
C  with 1-by-1 and 2-by-2 diagonal blocks; each 2-by-2 diagonal block
C  has its diagonal elemnts equal and its off-diagonal elements of
C  opposite sign.
C
C  Arguments
C  =========
C
C  WANTQ   (input) LOGICAL
C          = .TRUE. : accumulate the transformation in the matrix Q;
C          = .FALSE.: do not accumulate the transformation.
C
C  N       (input) INTEGER
C          The order of the matrix T. N >= 0.
C
C  T       (input/output) DOUBLE PRECISION array, dimension (LDT,N)
C          On entry, the upper quasi-triangular matrix T, in Schur
C          canonical form.
C          On exit, the updated matrix T, again in Schur canonical form.
C
C  LDT     (input)  INTEGER
C          The leading dimension of the array T. LDT >= max(1,N).
C
C  Q       (input/output) DOUBLE PRECISION array, dimension (LDQ,N)
C          On entry, if WANTQ is .TRUE., the orthogonal matrix Q.
C          On exit, if WANTQ is .TRUE., the updated matrix Q.
C          If WANTQ is .FALSE., Q is not referenced.
C
C  LDQ     (input) INTEGER
C          The leading dimension of the array Q.
C          LDQ >= 1; and if WANTQ is .TRUE., LDQ >= N.
C
C  J1      (input) INTEGER
C          The index of the first row of the first block T11.
C
C  N1      (input) INTEGER
C          The order of the first block T11. N1 = 0, 1 or 2.
C
C  N2      (input) INTEGER
C          The order of the second block T22. N2 = 0, 1 or 2.
C
C  WORK    (workspace) DOUBLE PRECISION array, dimension (N)
C
C  INFO    (output) INTEGER
C          = 0: successful exit
C          = 1: the transformed matrix T would be too far from Schur
C               form; the blocks are not swapped and T and Q are
C               unchanged.
C
C  =====================================================================
C
C     .. Parameters ..
C     ..
C     .. Local Scalars ..
C     ..
C     .. Local Arrays ..
C     ..
C     .. External Functions ..
C     ..
C     .. External Subroutines ..
C     ..
C     .. Intrinsic Functions ..
C     ..
C     .. Executable Statements ..
C
      info = 0
C
C     Quick return if possible
C
      IF (n .EQ. 0 .OR. n1 .EQ. 0 .OR. n2 .EQ. 0) THEN
        RETURN
      ELSE IF (j1 + n1 .GT. n) THEN
        RETURN
      ELSE
C
        j2 = j1 + 1
        j3 = j1 + 2
        j4 = j1 + 3
C
        IF (n1 .EQ. 1 .AND. n2 .EQ. 1) THEN
C
C        Swap two 1-by-1 blocks.
C
          t11 = t(j1, j1)
          DO nd0=1,nbdirs
            t22d(nd0) = td(nd0, j2, j2)
            t11d(nd0) = td(nd0, j1, j1)
            arg1d(nd0) = t22d(nd0) - t11d(nd0)
          ENDDO
          t22 = t(j2, j2)
C
C        Determine the transformation to perform the interchange.
C
          arg1 = t22 - t11
          CALL DLARTG_DV(t(j1, j2), td(1, j1, j2), arg1, arg1d, cs, csd
     +                   , sn, snd, temp, nbdirs)
C
C        Apply transformation to the matrix T.
C
          IF (j3 .LE. n) THEN
            arg10 = n - j1 - 1
            CALL DROT_DV(arg10, t(j1, j3), td(1, j1, j3), ldt, t(j2, j3)
     +                   , td(1, j2, j3), ldt, cs, csd, sn, snd, nbdirs)
          END IF
          arg10 = j1 - 1
          CALL DROT_DV(arg10, t(1, j1), td(1, 1, j1), 1, t(1, j2), td(1
     +                 , 1, j2), 1, cs, csd, sn, snd, nbdirs)
          DO nd0=1,nbdirs
            td(nd0, j1, j1) = t22d(nd0)
            td(nd0, j2, j2) = t11d(nd0)
          ENDDO
C
          t(j1, j1) = t22
          t(j2, j2) = t11
C
          IF (wantq) CALL DROT_DV(n, q(1, j1), qd(1, 1, j1), 1, q(1, j2)
     +                            , qd(1, 1, j2), 1, cs, csd, sn, snd,
     +                            nbdirs)
C
C           Accumulate transformation in the matrix Q.
C
        ELSE
C
C
C        Swapping involves at least one 2-by-2 block.
C
C        Copy the diagonal block of order N1+N2 to the local array D
C        and compute its norm.
C
          nd = n1 + n2
          DO nd0=1,nbdirs
            DO ii2=1,4
              DO ii3=1,4
                dd(nd0, ii3, ii2) = 0.D0
              ENDDO
            ENDDO
          ENDDO
          CALL DLACPY_DV('Full', nd, nd, t(j1, j1), td(1, j1, j1), ldt,
     +                   d, dd, ldd, nbdirs)
          CALL DLANGE_DV('Max', nd, nd, d, dd, ldd, work, workd, dnorm,
     +                   dnormd, nbdirs)
C
C        Compute machine-dependent threshold for test for accepting
C        swap.
C
          eps = DLAMCH('P')
          result1 = DLAMCH('S')
          smlnum = result1/eps
          IF (ten*eps*dnorm .LT. smlnum) THEN
            thresh = smlnum
          ELSE
            thresh = ten*eps*dnorm
          END IF
C
C        Solve T11*X - X*T22 = scale*T12 for X.
C
          arg10 = -1
          DO nd0=1,nbdirs
            scaled(nd0) = 0.D0
            DO ii2=1,2
              DO ii3=1,2
                xd(nd0, ii3, ii2) = 0.D0
              ENDDO
            ENDDO
          ENDDO
          CALL DLASY2_DV(.false., .false., arg10, n1, n2, d, dd, ldd, d(
     +                   n1+1, n1+1), dd(1, n1+1, n1+1), ldd, d(1, n1+1)
     +                   , dd(1, 1, n1+1), ldd, scale, scaled, x, xd,
     +                   ldx, xnorm, ierr, nbdirs)
C
C        Swap the adjacent diagonal blocks.
C
          k = n1 + n1 + n2 - 3
          GOTO (10, 20, 30) k
          GOTO 10
 30       DO nd0=1,nbdirs
            u1d(nd0, 1) = -xd(nd0, 1, 1)
            u1d(nd0, 2) = -xd(nd0, 2, 1)
            u1d(nd0, 3) = scaled(nd0)
          ENDDO
C
C
C        N1 = 2, N2 = 2: generate elementary reflectors H(1) and H(2) so
C        that:
C
C        H(2) H(1) (  -X11  -X12 ) = (  *  * )
C                  (  -X21  -X22 )   (  0  * )
C                  ( scale    0  )   (  0  0 )
C                  (    0  scale )   (  0  0 )
C
          u1(1) = -x(1, 1)
          u1(2) = -x(2, 1)
          u1(3) = scale
          CALL DLARFG_DV(3, u1(1), u1d(1, 1), u1(2), u1d(1, 2), 1, tau1
     +                   , tau1d, nbdirs)
          u1(1) = one
C
          temp = -(tau1*(x(1, 2)+u1(2)*x(2, 2)))
          DO nd0=1,nbdirs
            u1d(nd0, 1) = 0.D0
            tempd(nd0) = -(tau1d(nd0)*(x(1, 2)+u1(2)*x(2, 2))+tau1*(xd(
     +        nd0, 1, 2)+u1d(nd0, 2)*x(2, 2)+u1(2)*xd(nd0, 2, 2)))
            u2d(nd0, 1) = -(tempd(nd0)*u1(2)) - temp*u1d(nd0, 2) - xd(
     +        nd0, 2, 2)
            u2d(nd0, 2) = -(tempd(nd0)*u1(3)+temp*u1d(nd0, 3))
            u2d(nd0, 3) = scaled(nd0)
          ENDDO
          u2(1) = -(temp*u1(2)) - x(2, 2)
          u2(2) = -(temp*u1(3))
          u2(3) = scale
          CALL DLARFG_DV(3, u2(1), u2d(1, 1), u2(2), u2d(1, 2), 1, tau2
     +                   , tau2d, nbdirs)
          DO nd0=1,nbdirs
            u2d(nd0, 1) = 0.D0
          ENDDO
          u2(1) = one
C
C        Perform swap provisionally on diagonal block in D.
C
          CALL DLARFX_DV('L', 3, 4, u1, u1d, tau1, tau1d, d, dd, ldd,
     +                   work, workd, nbdirs)
          CALL DLARFX_DV('R', 4, 3, u1, u1d, tau1, tau1d, d, dd, ldd,
     +                   work, workd, nbdirs)
          CALL DLARFX_DV('L', 3, 4, u2, u2d, tau2, tau2d, d(2, 1), dd(1
     +                   , 2, 1), ldd, work, workd, nbdirs)
          CALL DLARFX_DV('R', 4, 3, u2, u2d, tau2, tau2d, d(1, 2), dd(1
     +                   , 1, 2), ldd, work, workd, nbdirs)
          IF (d(3, 1) .GE. 0.) THEN
            abs1 = d(3, 1)
          ELSE
            abs1 = -d(3, 1)
          END IF
          IF (d(3, 2) .GE. 0.) THEN
            abs2 = d(3, 2)
          ELSE
            abs2 = -d(3, 2)
          END IF
          IF (d(4, 1) .GE. 0.) THEN
            abs3 = d(4, 1)
          ELSE
            abs3 = -d(4, 1)
          END IF
          IF (d(4, 2) .GE. 0.) THEN
            abs4 = d(4, 2)
          ELSE
            abs4 = -d(4, 2)
          END IF
C
C        Test whether to reject swap.
C
          IF (MAX(abs1, abs2, abs3, abs4) .GT. thresh) THEN
            GOTO 50
          ELSE
C
C        Accept swap: apply transformation to the entire matrix T.
C
            arg10 = n - j1 + 1
            CALL DLARFX_DV('L', 3, arg10, u1, u1d, tau1, tau1d, t(j1, j1
     +                     ), td(1, j1, j1), ldt, work, workd, nbdirs)
            CALL DLARFX_DV('R', j4, 3, u1, u1d, tau1, tau1d, t(1, j1),
     +                     td(1, 1, j1), ldt, work, workd, nbdirs)
            arg10 = n - j1 + 1
            CALL DLARFX_DV('L', 3, arg10, u2, u2d, tau2, tau2d, t(j2, j1
     +                     ), td(1, j2, j1), ldt, work, workd, nbdirs)
            CALL DLARFX_DV('R', j4, 3, u2, u2d, tau2, tau2d, t(1, j2),
     +                     td(1, 1, j2), ldt, work, workd, nbdirs)
            DO nd0=1,nbdirs
              td(nd0, j3, j1) = 0.D0
              td(nd0, j3, j2) = 0.D0
              td(nd0, j4, j1) = 0.D0
              td(nd0, j4, j2) = 0.D0
            ENDDO
C
            t(j3, j1) = zero
            t(j3, j2) = zero
            t(j4, j1) = zero
            t(j4, j2) = zero
C
            IF (wantq) THEN
C
C           Accumulate transformation in the matrix Q.
C
              CALL DLARFX_DV('R', n, 3, u1, u1d, tau1, tau1d, q(1, j1),
     +                       qd(1, 1, j1), ldq, work, workd, nbdirs)
              CALL DLARFX_DV('R', n, 3, u2, u2d, tau2, tau2d, q(1, j2),
     +                       qd(1, 1, j2), ldq, work, workd, nbdirs)
            END IF
            GOTO 40
          END IF
 20       DO nd0=1,nbdirs
            ud(nd0, 1) = -xd(nd0, 1, 1)
            t33d(nd0) = td(nd0, j3, j3)
            ud(nd0, 2) = -xd(nd0, 2, 1)
            ud(nd0, 3) = scaled(nd0)
          ENDDO
C
C
C        N1 = 2, N2 = 1: generate elementary reflector H so that:
C
C        H (  -X11 ) = ( * )
C          (  -X21 ) = ( 0 )
C          ( scale ) = ( 0 )
C
          u(1) = -x(1, 1)
          u(2) = -x(2, 1)
          u(3) = scale
          CALL DLARFG_DV(3, u(1), ud(1, 1), u(2), ud(1, 2), 1, tau, taud
     +                   , nbdirs)
          DO nd0=1,nbdirs
            ud(nd0, 1) = 0.D0
          ENDDO
          u(1) = one
          t33 = t(j3, j3)
C
C        Perform swap provisionally on diagonal block in D.
C
          CALL DLARFX_DV('L', 3, 3, u, ud, tau, taud, d, dd, ldd, work,
     +                   workd, nbdirs)
          CALL DLARFX_DV('R', 3, 3, u, ud, tau, taud, d, dd, ldd, work,
     +                   workd, nbdirs)
          IF (d(2, 1) .GE. 0.) THEN
            x2 = d(2, 1)
          ELSE
            x2 = -d(2, 1)
          END IF
          IF (d(3, 1) .GE. 0.) THEN
            y2 = d(3, 1)
          ELSE
            y2 = -d(3, 1)
          END IF
          IF (d(1, 1) - t33 .GE. 0.) THEN
            z2 = d(1, 1) - t33
          ELSE
            z2 = -(d(1, 1)-t33)
          END IF
          IF (x2 .LT. y2) THEN
            IF (y2 .LT. z2) THEN
              max2 = z2
            ELSE
              max2 = y2
            END IF
          ELSE IF (x2 .LT. z2) THEN
            max2 = z2
          ELSE
            max2 = x2
          END IF
C
C        Test whether to reject swap.
C
          IF (max2 .GT. thresh) THEN
            GOTO 50
          ELSE
C
C        Accept swap: apply transformation to the entire matrix T.
C
            CALL DLARFX_DV('R', j3, 3, u, ud, tau, taud, t(1, j1), td(1
     +                     , 1, j1), ldt, work, workd, nbdirs)
            arg10 = n - j1
            CALL DLARFX_DV('L', 3, arg10, u, ud, tau, taud, t(j1, j2),
     +                     td(1, j1, j2), ldt, work, workd, nbdirs)
            DO nd0=1,nbdirs
              td(nd0, j1, j1) = t33d(nd0)
              td(nd0, j2, j1) = 0.D0
              td(nd0, j3, j1) = 0.D0
            ENDDO
C
            t(j1, j1) = t33
            t(j2, j1) = zero
            t(j3, j1) = zero
C
            IF (wantq) CALL DLARFX_DV('R', n, 3, u, ud, tau, taud, q(1,
     +                                j1), qd(1, 1, j1), ldq, work,
     +                                workd, nbdirs)
C
C           Accumulate transformation in the matrix Q.
C
            GOTO 40
          END IF
 10       DO nd0=1,nbdirs
            ud(nd0, 1) = scaled(nd0)
            t11d(nd0) = td(nd0, j1, j1)
            ud(nd0, 2) = xd(nd0, 1, 1)
            ud(nd0, 3) = xd(nd0, 1, 2)
          ENDDO
C
C
C        N1 = 1, N2 = 2: generate elementary reflector H so that:
C
C        ( scale, X11, X12 ) H = ( 0, 0, * )
C
          u(1) = scale
          u(2) = x(1, 1)
          u(3) = x(1, 2)
          CALL DLARFG_DV(3, u(3), ud(1, 3), u, ud, 1, tau, taud, nbdirs)
          DO nd0=1,nbdirs
            ud(nd0, 3) = 0.D0
          ENDDO
          u(3) = one
          t11 = t(j1, j1)
C
C        Perform swap provisionally on diagonal block in D.
C
          CALL DLARFX_DV('L', 3, 3, u, ud, tau, taud, d, dd, ldd, work,
     +                   workd, nbdirs)
          CALL DLARFX_DV('R', 3, 3, u, ud, tau, taud, d, dd, ldd, work,
     +                   workd, nbdirs)
          IF (d(3, 1) .GE. 0.) THEN
            x1 = d(3, 1)
          ELSE
            x1 = -d(3, 1)
          END IF
          IF (d(3, 2) .GE. 0.) THEN
            y1 = d(3, 2)
          ELSE
            y1 = -d(3, 2)
          END IF
          IF (d(3, 3) - t11 .GE. 0.) THEN
            z1 = d(3, 3) - t11
          ELSE
            z1 = -(d(3, 3)-t11)
          END IF
          IF (x1 .LT. y1) THEN
            IF (y1 .LT. z1) THEN
              max1 = z1
            ELSE
              max1 = y1
            END IF
          ELSE IF (x1 .LT. z1) THEN
            max1 = z1
          ELSE
            max1 = x1
          END IF
C
C        Test whether to reject swap.
C
          IF (max1 .GT. thresh) THEN
            GOTO 50
          ELSE
C
C        Accept swap: apply transformation to the entire matrix T.
C
            arg10 = n - j1 + 1
            CALL DLARFX_DV('L', 3, arg10, u, ud, tau, taud, t(j1, j1),
     +                     td(1, j1, j1), ldt, work, workd, nbdirs)
            CALL DLARFX_DV('R', j2, 3, u, ud, tau, taud, t(1, j1), td(1
     +                     , 1, j1), ldt, work, workd, nbdirs)
            DO nd0=1,nbdirs
              td(nd0, j3, j1) = 0.D0
              td(nd0, j3, j2) = 0.D0
              td(nd0, j3, j3) = t11d(nd0)
            ENDDO
C
            t(j3, j1) = zero
            t(j3, j2) = zero
            t(j3, j3) = t11
C
            IF (wantq) CALL DLARFX_DV('R', n, 3, u, ud, tau, taud, q(1,
     +                                j1), qd(1, 1, j1), ldq, work,
     +                                workd, nbdirs)
C
C           Accumulate transformation in the matrix Q.
C
          END IF
C
C
 40       IF (n2 .EQ. 2) THEN
C
C           Standardize new 2-by-2 block T11
C
            CALL DLANV2_DV(t(j1, j1), td(1, j1, j1), t(j1, j2), td(1, j1
     +                     , j2), t(j2, j1), td(1, j2, j1), t(j2, j2),
     +                     td(1, j2, j2), wr1, wr1d, wi1, wi1d, wr2,
     +                     wr2d, wi2, wi2d, cs, csd, sn, snd, nbdirs)
            arg10 = n - j1 - 1
            CALL DROT_DV(arg10, t(j1, j1+2), td(1, j1, j1+2), ldt, t(j2
     +                   , j1+2), td(1, j2, j1+2), ldt, cs, csd, sn, snd
     +                   , nbdirs)
            arg10 = j1 - 1
            CALL DROT_DV(arg10, t(1, j1), td(1, 1, j1), 1, t(1, j2), td(
     +                   1, 1, j2), 1, cs, csd, sn, snd, nbdirs)
            IF (wantq) CALL DROT_DV(n, q(1, j1), qd(1, 1, j1), 1, q(1,
     +                              j2), qd(1, 1, j2), 1, cs, csd, sn,
     +                              snd, nbdirs)
          END IF
C
          IF (n1 .EQ. 2) THEN
C
C           Standardize new 2-by-2 block T22
C
            j3 = j1 + n2
            j4 = j3 + 1
            CALL DLANV2_DV(t(j3, j3), td(1, j3, j3), t(j3, j4), td(1, j3
     +                     , j4), t(j4, j3), td(1, j4, j3), t(j4, j4),
     +                     td(1, j4, j4), wr1, wr1d, wi1, wi1d, wr2,
     +                     wr2d, wi2, wi2d, cs, csd, sn, snd, nbdirs)
            IF (j3 + 2 .LE. n) THEN
              arg10 = n - j3 - 1
              CALL DROT_DV(arg10, t(j3, j3+2), td(1, j3, j3+2), ldt, t(
     +                     j4, j3+2), td(1, j4, j3+2), ldt, cs, csd, sn
     +                     , snd, nbdirs)
            END IF
            arg10 = j3 - 1
            CALL DROT_DV(arg10, t(1, j3), td(1, 1, j3), 1, t(1, j4), td(
     +                   1, 1, j4), 1, cs, csd, sn, snd, nbdirs)
            IF (wantq) CALL DROT_DV(n, q(1, j3), qd(1, 1, j3), 1, q(1,
     +                              j4), qd(1, 1, j4), 1, cs, csd, sn,
     +                              snd, nbdirs)
          END IF
          GOTO 100
C
C     Exit with INFO = 1 if swap was rejected.
C
 50       info = 1
          RETURN
        END IF
C
 100    RETURN
      END IF
      END

!
! Copyright (C) 2006-2014 Houtan Bastani and Luca Guerrieri
!
!
! This free software: you can redistribute it and/or modify
! it under the terms of the GNU General Public License as published by
! the Free Software Foundation, either version 3 of the License, or
! (at your option) any later version.
!
! It is distributed in the hope that it will be useful,
! but WITHOUT ANY WARRANTY; without even the implied warranty of
! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
! GNU General Public License for more details.
!
! You should have received a copy of the GNU General Public License
! along with Dynare.  If not, see <http://www.gnu.org/licenses/>.
!

C        Generated by TAPENADE     (INRIA, Tropics team)
C  Tapenade - Version 2.2 (r1239) - Wed 28 Jun 2006 04:59:55 PM CEST
C
C  Differentiation of dlanv2 in forward (tangent) mode: (multi-directional mode)
C   variations  of output variables: d rt2i rt2r rt1i sn rt1r cs
C                a b c
C   with respect to input variables: d a b c
      SUBROUTINE DLANV2_DV(a, ad, b, bd, c, cd, d, dd0, rt1r, rt1rd,
     +                     rt1i, rt1id, rt2r, rt2rd, rt2i, rt2id, cs,
     +                     csd, sn, snd, nbdirs)
      USE DIFFSIZES
      IMPLICIT NONE
C
C     End of DLANV2
C
      INTEGER nbdirs
      DOUBLE PRECISION a, ad(nbdirsmax), b, bd(nbdirsmax), c, cd(
     +                 nbdirsmax), cs, csd(nbdirsmax), d, dd0(nbdirsmax)
     +                 , rt1i, rt1id(nbdirsmax), rt1r, rt1rd(nbdirsmax)
     +                 , rt2i, rt2id(nbdirsmax), rt2r, rt2rd(nbdirsmax)
     +                 , sn, snd(nbdirsmax)
      DOUBLE PRECISION multpl
      PARAMETER (multpl=4.0d+0)
      DOUBLE PRECISION half, one, zero
      PARAMETER (half=0.5d+0, one=1.0d+0, zero=0.0d+0)
      DOUBLE PRECISION DLAMCH
      DOUBLE PRECISION DLAPY2
      DOUBLE PRECISION abs2, abs2d(nbdirsmax), abs3, abs3d(nbdirsmax),
     +                 abs4, abs4d(nbdirsmax), abs5, abs5d(nbdirsmax),
     +                 abs6, abs6d(nbdirsmax), min1, min1d(nbdirsmax),
     +                 x1, x1d(nbdirsmax), x2, x2d(nbdirsmax), y1, y1d(
     +                 nbdirsmax), y2, y2d(nbdirsmax)
      INTEGER nd
      DOUBLE PRECISION aa, aad(nbdirsmax), abs1, abs1d(nbdirsmax), arg1
     +                 , arg1d(nbdirsmax), bb, bbd(nbdirsmax), bcmax,
     +                 bcmaxd(nbdirsmax), bcmis, bcmisd(nbdirsmax), cc,
     +                 ccd(nbdirsmax), cs1, cs1d(nbdirsmax), dd, ddd(
     +                 nbdirsmax), eps, p, pd(nbdirsmax), result1,
     +                 result1d(nbdirsmax), result2, result2d(nbdirsmax)
     +                 , sab, sabd(nbdirsmax), sac, sacd(nbdirsmax),
     +                 scale, scaled(nbdirsmax), sigma, sigmad(nbdirsmax
     +                 ), sn1, sn1d(nbdirsmax), tau, taud(nbdirsmax),
     +                 temp, tempd(nbdirsmax), x3, x3d(nbdirsmax), z, zd
     +                 (nbdirsmax)
      EXTERNAL DLAMCH
      INTRINSIC MAX, SIGN, ABS, MIN, SQRT
C
C  -- LAPACK driver routine (version 3.1) --
C     Univ. of Tennessee, Univ. of California Berkeley and NAG Ltd..
C     November 2006
C
C     .. Scalar Arguments ..
C     ..
C
C  Purpose
C  =======
C
C  DLANV2 computes the Schur factorization of a real 2-by-2 nonsymmetric
C  matrix in standard form:
C
C       [ A  B ] = [ CS -SN ] [ AA  BB ] [ CS  SN ]
C       [ C  D ]   [ SN  CS ] [ CC  DD ] [-SN  CS ]
C
C  where either
C  1) CC = 0 so that AA and DD are real eigenvalues of the matrix, or
C  2) AA = DD and BB*CC < 0, so that AA + or - sqrt(BB*CC) are complex
C  conjugate eigenvalues.
C
C  Arguments
C  =========
C
C  A       (input/output) DOUBLE PRECISION
C  B       (input/output) DOUBLE PRECISION
C  C       (input/output) DOUBLE PRECISION
C  D       (input/output) DOUBLE PRECISION
C          On entry, the elements of the input matrix.
C          On exit, they are overwritten by the elements of the
C          standardised Schur form.
C
C  RT1R    (output) DOUBLE PRECISION
C  RT1I    (output) DOUBLE PRECISION
C  RT2R    (output) DOUBLE PRECISION
C  RT2I    (output) DOUBLE PRECISION
C          The real and imaginary parts of the eigenvalues. If the
C          eigenvalues are a complex conjugate pair, RT1I > 0.
C
C  CS      (output) DOUBLE PRECISION
C  SN      (output) DOUBLE PRECISION
C          Parameters of the rotation matrix.
C
C  Further Details
C  ===============
C
C  Modified by V. Sima, Research Institute for Informatics, Bucharest,
C  Romania, to reduce the risk of cancellation errors,
C  when computing real eigenvalues, and to ensure, if possible, that
C  abs(RT1R) >= abs(RT2R).
C
C  =====================================================================
C
C     .. Parameters ..
C     ..
C     .. Local Scalars ..
C     ..
C     .. External Functions ..
C     ..
C     .. Intrinsic Functions ..
C     ..
C     .. Executable Statements ..
C
      eps = DLAMCH('P')
      IF (c .EQ. zero) THEN
        cs = one
        sn = zero
        DO nd=1,nbdirs
          snd(nd) = 0.D0
        ENDDO
        DO nd=1,nbdirs
          csd(nd) = 0.D0
        ENDDO
      ELSE IF (b .EQ. zero) THEN
C
C
C        Swap rows and columns
C
        cs = zero
        sn = one
        DO nd=1,nbdirs
          tempd(nd) = dd0(nd)
          bd(nd) = -cd(nd)
          dd0(nd) = ad(nd)
          ad(nd) = tempd(nd)
        ENDDO
        temp = d
        d = a
        a = temp
        b = -c
        c = zero
        DO nd=1,nbdirs
          snd(nd) = 0.D0
        ENDDO
        DO nd=1,nbdirs
          csd(nd) = 0.D0
        ENDDO
        DO nd=1,nbdirs
          cd(nd) = 0.D0
        ENDDO
      ELSE IF (a - d .EQ. zero .AND. SIGN(one, b) .NE. SIGN(one, c))
     +THEN
        cs = one
        sn = zero
        DO nd=1,nbdirs
          snd(nd) = 0.D0
        ENDDO
        DO nd=1,nbdirs
          csd(nd) = 0.D0
        ENDDO
      ELSE
        DO nd=1,nbdirs
          tempd(nd) = ad(nd) - dd0(nd)
          pd(nd) = half*tempd(nd)
        ENDDO
C
        temp = a - d
        p = half*temp
        IF (b .GE. 0.) THEN
          DO nd=1,nbdirs
            x1d(nd) = bd(nd)
          ENDDO
          x1 = b
        ELSE
          DO nd=1,nbdirs
            x1d(nd) = -bd(nd)
          ENDDO
          x1 = -b
        END IF
        IF (c .GE. 0.) THEN
          DO nd=1,nbdirs
            y1d(nd) = cd(nd)
          ENDDO
          y1 = c
        ELSE
          DO nd=1,nbdirs
            y1d(nd) = -cd(nd)
          ENDDO
          y1 = -c
        END IF
        IF (x1 .LT. y1) THEN
          DO nd=1,nbdirs
            bcmaxd(nd) = y1d(nd)
          ENDDO
          bcmax = y1
        ELSE
          DO nd=1,nbdirs
            bcmaxd(nd) = x1d(nd)
          ENDDO
          bcmax = x1
        END IF
        IF (b .GE. 0.) THEN
          DO nd=1,nbdirs
            x2d(nd) = bd(nd)
          ENDDO
          x2 = b
        ELSE
          DO nd=1,nbdirs
            x2d(nd) = -bd(nd)
          ENDDO
          x2 = -b
        END IF
        IF (c .GE. 0.) THEN
          DO nd=1,nbdirs
            y2d(nd) = cd(nd)
          ENDDO
          y2 = c
        ELSE
          DO nd=1,nbdirs
            y2d(nd) = -cd(nd)
          ENDDO
          y2 = -c
        END IF
        IF (x2 .GT. y2) THEN
          DO nd=1,nbdirs
            min1d(nd) = y2d(nd)
          ENDDO
          min1 = y2
        ELSE
          DO nd=1,nbdirs
            min1d(nd) = x2d(nd)
          ENDDO
          min1 = x2
        END IF
        DO nd=1,nbdirs
          bcmisd(nd) = SIGN(one, b)*SIGN(one, c)*min1d(nd)
        ENDDO
        bcmis = min1*SIGN(one, b)*SIGN(one, c)
        IF (p .GE. 0.) THEN
          DO nd=1,nbdirs
            x3d(nd) = pd(nd)
          ENDDO
          x3 = p
        ELSE
          DO nd=1,nbdirs
            x3d(nd) = -pd(nd)
          ENDDO
          x3 = -p
        END IF
        IF (x3 .LT. bcmax) THEN
          DO nd=1,nbdirs
            scaled(nd) = bcmaxd(nd)
          ENDDO
          scale = bcmax
        ELSE
          DO nd=1,nbdirs
            scaled(nd) = x3d(nd)
          ENDDO
          scale = x3
        END IF
        DO nd=1,nbdirs
          zd(nd) = (pd(nd)*scale-p*scaled(nd))*p/scale**2 + p*pd(nd)/
     +      scale + (bcmaxd(nd)*scale-bcmax*scaled(nd))*bcmis/scale**2 +
     +      bcmax*bcmisd(nd)/scale
        ENDDO
        z = p/scale*p + bcmax/scale*bcmis
C
C        If Z is of the order of the machine accuracy, postpone the
C        decision on the nature of eigenvalues
C
        IF (z .GE. multpl*eps) THEN
C
C           Real eigenvalues. Compute A and D.
C
          result1 = SQRT(scale)
          DO nd=1,nbdirs
            IF (zd(nd) .EQ. 0.0 .OR. z .EQ. 0.0) THEN
              result2d(nd) = 0.D0
            ELSE
              result2d(nd) = zd(nd)/(2.0*SQRT(z))
            END IF
          ENDDO
          result2 = SQRT(z)
          arg1 = result1*result2
          z = p + SIGN(arg1, p)
          DO nd=1,nbdirs
            IF (scaled(nd) .EQ. 0.0 .OR. scale .EQ. 0.0) THEN
              result1d(nd) = 0.D0
            ELSE
              result1d(nd) = scaled(nd)/(2.0*SQRT(scale))
            END IF
            bd(nd) = bd(nd) - cd(nd)
            arg1d(nd) = result1d(nd)*result2 + result1*result2d(nd)
            zd(nd) = pd(nd) + SIGN(arg1d(nd), p)
            ad(nd) = dd0(nd) + zd(nd)
            dd0(nd) = dd0(nd) - (bcmaxd(nd)*z-bcmax*zd(nd))*bcmis/z**2 -
     +        bcmax*bcmisd(nd)/z
          ENDDO
          a = d + z
          d = d - bcmax/z*bcmis
C
C           Compute B and the rotation matrix
C
          CALL DLAPY2_DV(c, cd, z, zd, tau, taud, nbdirs)
          DO nd=1,nbdirs
            csd(nd) = (zd(nd)*tau-z*taud(nd))/tau**2
            snd(nd) = (cd(nd)*tau-c*taud(nd))/tau**2
          ENDDO
          cs = z/tau
          sn = c/tau
          b = b - c
          c = zero
          DO nd=1,nbdirs
            cd(nd) = 0.D0
          ENDDO
        ELSE
          DO nd=1,nbdirs
            sigmad(nd) = bd(nd) + cd(nd)
          ENDDO
C
C           Complex eigenvalues, or real (almost) equal eigenvalues.
C           Make diagonal elements equal.
C
          sigma = b + c
          CALL DLAPY2_DV(sigma, sigmad, temp, tempd, tau, taud, nbdirs)
          IF (sigma .GE. 0.) THEN
            DO nd=1,nbdirs
              abs1d(nd) = sigmad(nd)
            ENDDO
            abs1 = sigma
          ELSE
            DO nd=1,nbdirs
              abs1d(nd) = -sigmad(nd)
            ENDDO
            abs1 = -sigma
          END IF
          arg1 = half*(one+abs1/tau)
          cs = SQRT(arg1)
          sn = -(p/(tau*cs)*SIGN(one, sigma))
C
C           Compute [ AA  BB ] = [ A  B ] [ CS -SN ]
C                   [ CC  DD ]   [ C  D ] [ SN  CS ]
C
          aa = a*cs + b*sn
          bb = -(a*sn) + b*cs
          cc = c*cs + d*sn
          dd = -(c*sn) + d*cs
          DO nd=1,nbdirs
            arg1d(nd) = half*(abs1d(nd)*tau-abs1*taud(nd))/tau**2
            IF (arg1d(nd) .EQ. 0.0 .OR. arg1 .EQ. 0.0) THEN
              csd(nd) = 0.D0
            ELSE
              csd(nd) = arg1d(nd)/(2.0*SQRT(arg1))
            END IF
            snd(nd) = -(SIGN(one, sigma)*(pd(nd)*tau*cs-p*(taud(nd)*cs+
     +        tau*csd(nd)))/(tau**2*cs**2))
            ddd(nd) = dd0(nd)*cs - c*snd(nd) - cd(nd)*sn + d*csd(nd)
            ccd(nd) = cd(nd)*cs + c*csd(nd) + dd0(nd)*sn + d*snd(nd)
            bbd(nd) = bd(nd)*cs - a*snd(nd) - ad(nd)*sn + b*csd(nd)
            dd0(nd) = ddd(nd)*cs - bb*snd(nd) - bbd(nd)*sn + dd*csd(nd)
            aad(nd) = ad(nd)*cs + a*csd(nd) + bd(nd)*sn + b*snd(nd)
            cd(nd) = ccd(nd)*cs - aa*snd(nd) - aad(nd)*sn + cc*csd(nd)
            bd(nd) = bbd(nd)*cs + bb*csd(nd) + ddd(nd)*sn + dd*snd(nd)
            ad(nd) = aad(nd)*cs + aa*csd(nd) + ccd(nd)*sn + cc*snd(nd)
            tempd(nd) = half*(ad(nd)+dd0(nd))
            dd0(nd) = tempd(nd)
            ad(nd) = tempd(nd)
          ENDDO
C
C           Compute [ A  B ] = [ CS  SN ] [ AA  BB ]
C                   [ C  D ]   [-SN  CS ] [ CC  DD ]
C
          a = aa*cs + cc*sn
          b = bb*cs + dd*sn
          c = -(aa*sn) + cc*cs
          d = -(bb*sn) + dd*cs
C
          temp = half*(a+d)
          a = temp
          d = temp
C
          IF (c .NE. zero) THEN
            IF (b .NE. zero) THEN
              IF (SIGN(one, b) .EQ. SIGN(one, c)) THEN
                IF (b .GE. 0.) THEN
                  DO nd=1,nbdirs
                    abs2d(nd) = bd(nd)
                  ENDDO
                  abs2 = b
                ELSE
                  DO nd=1,nbdirs
                    abs2d(nd) = -bd(nd)
                  ENDDO
                  abs2 = -b
                END IF
                DO nd=1,nbdirs
                  IF (abs2d(nd) .EQ. 0.0 .OR. abs2 .EQ. 0.0) THEN
                    sabd(nd) = 0.D0
                  ELSE
                    sabd(nd) = abs2d(nd)/(2.0*SQRT(abs2))
                  END IF
                ENDDO
C
C                    Real eigenvalues: reduce to upper triangular form
C
                sab = SQRT(abs2)
                IF (c .GE. 0.) THEN
                  DO nd=1,nbdirs
                    abs3d(nd) = cd(nd)
                  ENDDO
                  abs3 = c
                ELSE
                  DO nd=1,nbdirs
                    abs3d(nd) = -cd(nd)
                  ENDDO
                  abs3 = -c
                END IF
                sac = SQRT(abs3)
                DO nd=1,nbdirs
                  IF (abs3d(nd) .EQ. 0.0 .OR. abs3 .EQ. 0.0) THEN
                    sacd(nd) = 0.D0
                  ELSE
                    sacd(nd) = abs3d(nd)/(2.0*SQRT(abs3))
                  END IF
                  arg1d(nd) = sabd(nd)*sac + sab*sacd(nd)
                  pd(nd) = SIGN(arg1d(nd), c)
                ENDDO
                arg1 = sab*sac
                p = SIGN(arg1, c)
                IF (b + c .GE. 0.) THEN
                  DO nd=1,nbdirs
                    abs4d(nd) = bd(nd) + cd(nd)
                  ENDDO
                  abs4 = b + c
                ELSE
                  DO nd=1,nbdirs
                    abs4d(nd) = -(bd(nd)+cd(nd))
                  ENDDO
                  abs4 = -(b+c)
                END IF
                result1 = SQRT(abs4)
                tau = one/result1
                cs1 = sab*tau
                sn1 = sac*tau
                DO nd=1,nbdirs
                  IF (abs4d(nd) .EQ. 0.0 .OR. abs4 .EQ. 0.0) THEN
                    result1d(nd) = 0.D0
                  ELSE
                    result1d(nd) = abs4d(nd)/(2.0*SQRT(abs4))
                  END IF
                  bd(nd) = bd(nd) - cd(nd)
                  dd0(nd) = tempd(nd) - pd(nd)
                  ad(nd) = tempd(nd) + pd(nd)
                  taud(nd) = -(one*result1d(nd)/result1**2)
                  sn1d(nd) = sacd(nd)*tau + sac*taud(nd)
                  cs1d(nd) = sabd(nd)*tau + sab*taud(nd)
                  tempd(nd) = csd(nd)*cs1 + cs*cs1d(nd) - snd(nd)*sn1 -
     +              sn*sn1d(nd)
                  snd(nd) = csd(nd)*sn1 + cs*sn1d(nd) + snd(nd)*cs1 + sn
     +              *cs1d(nd)
                  csd(nd) = tempd(nd)
                ENDDO
                a = temp + p
                d = temp - p
                b = b - c
                c = zero
                temp = cs*cs1 - sn*sn1
                sn = cs*sn1 + sn*cs1
                cs = temp
                DO nd=1,nbdirs
                  cd(nd) = 0.D0
                ENDDO
              END IF
            ELSE
              b = -c
              c = zero
              DO nd=1,nbdirs
                tempd(nd) = csd(nd)
                csd(nd) = -snd(nd)
                bd(nd) = -cd(nd)
                snd(nd) = tempd(nd)
              ENDDO
              temp = cs
              cs = -sn
              sn = temp
              DO nd=1,nbdirs
                cd(nd) = 0.D0
              ENDDO
            END IF
          END IF
        END IF
      END IF
      DO nd=1,nbdirs
        rt1rd(nd) = ad(nd)
        rt2rd(nd) = dd0(nd)
      ENDDO
C
C
C
C     Store eigenvalues in (RT1R,RT1I) and (RT2R,RT2I).
C
      rt1r = a
      rt2r = d
      IF (c .EQ. zero) THEN
        rt1i = zero
        rt2i = zero
        DO nd=1,nbdirs
          rt2id(nd) = 0.D0
        ENDDO
        DO nd=1,nbdirs
          rt1id(nd) = 0.D0
        ENDDO
      ELSE
        IF (b .GE. 0.) THEN
          DO nd=1,nbdirs
            abs5d(nd) = bd(nd)
          ENDDO
          abs5 = b
        ELSE
          DO nd=1,nbdirs
            abs5d(nd) = -bd(nd)
          ENDDO
          abs5 = -b
        END IF
        IF (c .GE. 0.) THEN
          DO nd=1,nbdirs
            abs6d(nd) = cd(nd)
          ENDDO
          abs6 = c
        ELSE
          DO nd=1,nbdirs
            abs6d(nd) = -cd(nd)
          ENDDO
          abs6 = -c
        END IF
        result1 = SQRT(abs5)
        result2 = SQRT(abs6)
        DO nd=1,nbdirs
          IF (abs6d(nd) .EQ. 0.0 .OR. abs6 .EQ. 0.0) THEN
            result2d(nd) = 0.D0
          ELSE
            result2d(nd) = abs6d(nd)/(2.0*SQRT(abs6))
          END IF
          IF (abs5d(nd) .EQ. 0.0 .OR. abs5 .EQ. 0.0) THEN
            result1d(nd) = 0.D0
          ELSE
            result1d(nd) = abs5d(nd)/(2.0*SQRT(abs5))
          END IF
          rt1id(nd) = result1d(nd)*result2 + result1*result2d(nd)
          rt2id(nd) = -rt1id(nd)
        ENDDO
        rt1i = result1*result2
        rt2i = -rt1i
      END IF
      RETURN
      END

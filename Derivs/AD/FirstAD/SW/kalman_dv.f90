!
! Copyright (C) 2006-2014 Houtan Bastani and Luca Guerrieri
!
!
! This free software: you can redistribute it and/or modify
! it under the terms of the GNU General Public License as published by
! the Free Software Foundation, either version 3 of the License, or
! (at your option) any later version.
!
! It is distributed in the hope that it will be useful,
! but WITHOUT ANY WARRANTY; without even the implied warranty of
! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
! GNU General Public License for more details.
!
! You should have received a copy of the GNU General Public License
! along with Dynare.  If not, see <http://www.gnu.org/licenses/>.
!

!        Generated by TAPENADE     (INRIA, Tropics team)
!  Tapenade - Version 2.2 (r1239) - Wed 28 Jun 2006 04:59:55 PM CEST
!
!  Differentiation of kalman in forward (tangent) mode: (multi-directional mode)
!   variations  of output variables: likel
!   with respect to input variables: f q
SUBROUTINE KALMAN_DV(f, fd, r, h, n, y, t, xi10, q, qd, ntrain, likel, likeld, explswitch, nbdirs)
  USE DIFFSIZES
  USE moderror
  IMPLICIT NONE
  INTEGER, INTENT(IN) :: explswitch
  DOUBLE PRECISION, INTENT(OUT) :: likel
  INTEGER, INTENT(IN) :: n
  INTEGER :: nbdirs
  DOUBLE PRECISION, DIMENSION(nbdirsmax), INTENT(OUT) :: likeld
  INTEGER, INTENT(IN) :: ntrain
  INTEGER, INTENT(IN) :: r
  DOUBLE PRECISION, DIMENSION(r, r), INTENT(IN) :: f
  DOUBLE PRECISION, DIMENSION(nbdirsmax, r, r), INTENT(IN) :: fd
  DOUBLE PRECISION, DIMENSION(r, n), INTENT(IN) :: h
  DOUBLE PRECISION, DIMENSION(r, r), INTENT(IN) :: q
  DOUBLE PRECISION, DIMENSION(nbdirsmax, r, r), INTENT(IN) :: qd
  INTEGER, INTENT(IN) :: t
  DOUBLE PRECISION, DIMENSION(r, 1), INTENT(IN) :: xi10
  DOUBLE PRECISION, DIMENSION(n, t), INTENT(IN) :: y
  DOUBLE PRECISION, DIMENSION(:, :), ALLOCATABLE :: b
  DOUBLE PRECISION, DIMENSION(:, :, :), ALLOCATABLE :: bd
  DOUBLE PRECISION, DIMENSION(:, :, :), ALLOCATABLE :: hd
  DOUBLE PRECISION, DIMENSION(:, :), ALLOCATABLE :: hp
  DOUBLE PRECISION, DIMENSION(:, :, :), ALLOCATABLE :: hpd
  DOUBLE PRECISION, DIMENSION(:, :), ALLOCATABLE :: hpp10h
  DOUBLE PRECISION, DIMENSION(:, :, :), ALLOCATABLE :: hpp10hd
  INTEGER, DIMENSION(:), ALLOCATABLE :: ipiv
  DOUBLE PRECISION :: det_hpp10h, det_hpp10hd(nbdirsmax), detl, detu, &
&  detud(nbdirsmax), e, likelhd, likelhdd(nbdirsmax), nhalflog2pi, pi
  DOUBLE PRECISION, DIMENSION(:, :), ALLOCATABLE :: origa
  DOUBLE PRECISION, DIMENSION(:, :, :), ALLOCATABLE :: origad
  DOUBLE PRECISION, DIMENSION(:, :), ALLOCATABLE :: p10
  DOUBLE PRECISION, DIMENSION(:, :, :), ALLOCATABLE :: p10d
  DOUBLE PRECISION, DIMENSION(:, :), ALLOCATABLE :: p11
  DOUBLE PRECISION, DIMENSION(:, :, :), ALLOCATABLE :: p11d
  DOUBLE PRECISION, DIMENSION(:, :), ALLOCATABLE :: part1
  DOUBLE PRECISION, DIMENSION(:, :, :), ALLOCATABLE :: part1d
  DOUBLE PRECISION, DIMENSION(:, :), ALLOCATABLE :: part2
  DOUBLE PRECISION, DIMENSION(:, :, :), ALLOCATABLE :: part2d
  DOUBLE PRECISION :: pwr1
  INTEGER :: i, info, j, nd, status
  DOUBLE PRECISION, DIMENSION(:, :), ALLOCATABLE :: tmp1byn
  DOUBLE PRECISION, DIMENSION(:, :, :), ALLOCATABLE :: tmp1bynd
  DOUBLE PRECISION, DIMENSION(:, :), ALLOCATABLE :: tmprby1
  DOUBLE PRECISION, DIMENSION(:, :, :), ALLOCATABLE :: tmprby1d
  DOUBLE PRECISION, DIMENSION(:, :), ALLOCATABLE :: tmprbyn
  DOUBLE PRECISION, DIMENSION(:, :), ALLOCATABLE :: tmprbyn_
  DOUBLE PRECISION, DIMENSION(:, :, :), ALLOCATABLE :: tmprbyn_d
  DOUBLE PRECISION, DIMENSION(:, :, :), ALLOCATABLE :: tmprbynd
  DOUBLE PRECISION, DIMENSION(:, :), ALLOCATABLE :: tmprbyr
  DOUBLE PRECISION, DIMENSION(:, :), ALLOCATABLE :: tmprbyr_
  DOUBLE PRECISION, DIMENSION(:, :, :), ALLOCATABLE :: tmprbyr_d
  DOUBLE PRECISION, DIMENSION(:, :, :), ALLOCATABLE :: tmprbyrd
  DOUBLE PRECISION, DIMENSION(:, :), ALLOCATABLE :: xi10history
  DOUBLE PRECISION, DIMENSION(:, :, :), ALLOCATABLE :: xi10historyd
  DOUBLE PRECISION, DIMENSION(:, :), ALLOCATABLE :: xi11history
  DOUBLE PRECISION, DIMENSION(:, :, :), ALLOCATABLE :: xi11historyd
  INTRINSIC LOG, DBLE

! if set to 1, imposes a penalty if likelihood explodes
! otherwise, skips the update for any observation that would cause explosion
! Local Vars
! if subroutine successfully completes task, info is set to 0
! info is set to -1 if memory allocation was a problem
! info is set to -2 if likelihood exploded
! info is set to -3 if there were problem with inverse computation
! info is set to -4 if more than one of the above occurred
!
! Begin Processing
!
  e = 2.718281828459046d0
  pi = 3.141592653589793d0
  nhalflog2pi = -(DBLE(n)/2.0d0*LOG(2.0d0*pi))
  info = 0
  memerr  = 0
  inverr  = 0
  explerr = 0
  likel = 0.0d0
  likelhd = 0.0d0

  ALLOCATE( xi10history(r, 1), xi11history(r, 1), xi10historyd(nbdirsmax, r, 1), xi11historyd(nbdirsmax, r, 1), &
            p10(r, r), p10d(nbdirsmax, r, r), hp(n, r), hpd(nbdirsmax, n, r), tmprbyn(r, n), hpp10h(n, n),     &
            tmprbynd(nbdirsmax, r, n), origa(n, n), origad(nbdirsmax, n, n), part1d(nbdirsmax, n, 1), part1(n, 1), &
            ipiv(n), b(n, n), bd(nbdirsmax, n, n), tmprbyn_(r, n), tmprbyn_d(nbdirsmax, r, n), tmprby1(r, 1),   &
            tmprby1d(nbdirsmax, r, 1), tmprbyr(r, r), tmprbyrd(nbdirsmax, r, r), tmprbyr_(r, r), p11(r, r),     &
            tmprbyr_d(nbdirsmax, r, r), p11d(nbdirsmax, r, r), hpp10hd(nbdirsmax, n, n), tmp1bynd(nbdirsmax, 1, n), &
            hd(nbdirsmax, r, n), tmp1byn(1, n), part2(1, 1), part2d(nbdirsmax, 1, 1), STAT=status )
  IF (status .NE. 0) THEN
    WRITE(*, *)
    WRITE(*, *) '***In Kalman Filter: Could not allocate memory***'
   memerr = -1
  END IF
!
! begin kalman filter, (references to Hamilton)
!


  ! 13.2.15
  xi11history = xi10
  DO nd=1,nbdirs
    xi11historyd(nd, :, :) = 0.D0
    p10d(nd, :, :) = qd(nd, :, :)
    xi10historyd(nd, :, :) = 0.D0
  END DO


  ! 13.2.17
  CALL MATRIXMULT_DV(f, fd, r, r, xi11history, xi11historyd, 1, xi10history, xi10historyd, nbdirs)


  ! 13.2.21
  p10 = q
  DO nd=1,nbdirs
    likeld(nd) = 0.D0
    tmprbyr_d(nd, :, :) = 0.D0
    tmp1bynd(nd, :, :) = 0.D0
    tmprbynd(nd, :, :) = 0.D0
    tmprbyrd(nd, :, :) = 0.D0
    hpp10hd(nd, :, :) = 0.D0
    tmprby1d(nd, :, :) = 0.D0
    part1d(nd, :, :) = 0.D0
    part2d(nd, :, :) = 0.D0
    tmprbyn_d(nd, :, :) = 0.D0
  END DO


  DO i=2,t
    hd(:,:,:) = 0.0d0
    CALL TRANSP_DV(h, hd, r, n, hp, hpd, nbdirs)
    hpd(:, :, :) = 0.D0

    ! part1 = y(:, i) - h'*xi10history
    CALL MATRIXMULT_DV( hp, hpd, n, r, xi10history, xi10historyd, 1, part1, part1d, nbdirs )

    ! b = (h'*p10*h)^-1
    CALL MATRIXMULT_DV( p10, p10d, r, r, h, hd, n, tmprbyn, tmprbynd, nbdirs )
    CALL MATRIXMULT_DV( hp, hpd, n, r, tmprbyn, tmprbynd, n, hpp10h, hpp10hd, nbdirs )
    CALL EYEMAT_DV( b, bd, n, nbdirs )
    DO nd=1,nbdirs
      origad(nd, :, :) = hpp10hd(nd, :, :)
    END DO
    origa = hpp10h
    CALL DGESV_DV( n, n, hpp10h, hpp10hd, n, ipiv, b, bd, n, info, nbdirs )
    CALL INVERT_DV( origa, origad, n, nbdirs )
    DO nd=1,nbdirs
      bd(nd, :, :) = origad(nd, :, :)
      hpd(nd, :, :) = 0.D0
      part1d(nd, :, 1) = -part1d(nd, :, 1)
    END DO
    part1(:, 1) = y(:, i) - part1(:, 1)
    b = origa

    IF (info .NE. 0) THEN
!      WRITE(*,*)
!      WRITE(*,*) "***In Kalman Filter: Error on return from dgesv()***"
      inverr = -1
    END IF


    IF (i .GT. ntrain) THEN
      DO nd=1,nbdirs
        tmp1bynd(nd, :, :) = 0.D0
      END DO

      !
      ! Note: do not assign to tmprbyn in this if statement
      !
      ! part2 = -0.5 * part1' * inv( hpp10h ) * part1
      tmp1byn(:, :) = 0.0d0
      tmp1bynd(:, :, :) = 0.0d0
      CALL DGEMM_DV( 'T', 'N', 1, n, n, -0.5d0, part1, part1d, n, b, bd, n, 1, tmp1byn, tmp1bynd, 1, nbdirs )
      CALL MATRIXMULT_DV( tmp1byn, tmp1bynd, 1, n, part1, part1d, 1, part2, part2d, nbdirs )


      ! 13.4.1
      ! det_hpp10h = det( hpp10h )
      detl = 1.0d0
      detu = 1.0d0
      DO nd=1,nbdirs
        detud(nd) = 0.D0
      END DO
      DO j=1,n
        IF (ipiv(j) .NE. j) detl = detl*(-1.0d0)
        DO nd=1,nbdirs
          detud(nd) = detud(nd)*hpp10h(j, j) + detu*hpp10hd(nd, j, j)
        END DO
        detu = detu*hpp10h(j, j)
      END DO
      DO nd=1,nbdirs
        det_hpp10hd(nd) = detl*detud(nd)
      END DO
      det_hpp10h = detl*detu

      ! 13.4.1 (continued)
      ! likelhd = 2PI^-n/2 * det_hpp10h^-0.5 * e^part2
      pwr1 = 10.0d0**(-300)
      IF (det_hpp10h .GT. pwr1) THEN
        DO nd=1,nbdirs
          likelhdd(nd) = part2d(nd, 1, 1) - 0.5d0*det_hpp10hd(nd)/det_hpp10h
        END DO
        likelhd = nhalflog2pi - 0.5d0*LOG(det_hpp10h) + part2(1, 1)
        IF (likel + likelhd .GT. 10.0d0**308) THEN
          IF (explswitch .EQ. 1) THEN
            likel = 10.0d0**308
            DO nd=1,nbdirs
              likeld(nd) = 0.D0
            END DO
          END IF
          explerr = -1
        ELSE
          DO nd=1,nbdirs
            likeld(nd) = likeld(nd) + likelhdd(nd)
          END DO
          likel = likel + likelhd
        END IF
      ELSE IF (explswitch .EQ. 1) THEN
        likel = 10.0d0**308
        DO nd=1,nbdirs
          likeld(nd) = 0.D0
        END DO
        explerr = -1
      END IF
    END IF


    ! 13.2.15
    ! xi11history = xi10history + p10*h*b*part1
    CALL MATRIXMULT_DV( tmprbyn, tmprbynd, r, n, b, bd, n, tmprbyn_, tmprbyn_d, nbdirs )
    CALL MATRIXMULT_DV( tmprbyn_, tmprbyn_d, r, n, part1, part1d, 1, tmprby1, tmprby1d, nbdirs )
    xi11history = xi10history + tmprby1

    ! 13.2.16
    ! p11 = p10 - p10*h*b*h'*p10
    hpd(:, :, :) = 0.D0
    CALL MATRIXMULT_DV( tmprbyn_, tmprbyn_d, r, n, hp, hpd, r, tmprbyr_, tmprbyr_d, nbdirs )
    CALL MATRIXMULT_DV( tmprbyr_, tmprbyr_d, r, r, p10, p10d, r, tmprbyr, tmprbyrd, nbdirs )
    DO nd=1,nbdirs
      p11d(nd, :, :) = p10d(nd, :, :) - tmprbyrd(nd, :, :)
      xi11historyd(nd, :, :) = xi10historyd(nd, :, :) + tmprby1d(nd, :, :)
      p10d(nd, :, :) = qd(nd, :, :)
    END DO
    p11 = p10 - tmprbyr

    ! 13.2.17
    ! xi10history = f * xi11history
    CALL MATRIXMULT_DV( f, fd, r, r, xi11history, xi11historyd, 1, xi10history, xi10historyd, nbdirs )

    ! 13.2.21
    ! p10 = f*p11*f' + q
    p10 = q
    CALL MATRIXMULT_DV( f, fd, r, r, p11, p11d, r, tmprbyr, tmprbyrd, nbdirs )
    CALL DGEMM_DV( 'N', 'T', r, r, r, 1.0d0, tmprbyr, tmprbyrd, r, f, fd, r, 1.0d0, p10, p10d, r, nbdirs )
  END DO

  IF ((explerr .NE. -1) .AND. (explswitch .EQ. 1)) THEN
     likel = -1.0d0*likel
     DO nd=1,nbdirs
        likeld(nd) = -1.0d0*likeld(nd)
     END DO
  END IF

  DEALLOCATE( xi10history, xi11history, xi10historyd, xi11historyd, &
            p10, p10d, hp, hpd, tmprbyn, hpp10h,     &
            tmprbynd, origa, origad, part1d, part1, &
            ipiv, b, bd, tmprbyn_, tmprbyn_d, tmprby1,   &
            tmprby1d, tmprbyr, tmprbyrd, tmprbyr_, p11,     &
            tmprbyr_d, p11d, hpp10hd, tmp1bynd, &
            hd, tmp1byn, part2, part2d, STAT=status )
  IF (status .NE. 0) THEN
     WRITE(*, *)
     WRITE(*, *) '***In Kalman Filter: Could not deallocate memory***'
     memerr = -1
  END IF
END SUBROUTINE KALMAN_DV

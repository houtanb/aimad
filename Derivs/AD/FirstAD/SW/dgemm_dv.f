!
! Copyright (C) 2006-2014 Houtan Bastani and Luca Guerrieri
!
!
! This free software: you can redistribute it and/or modify
! it under the terms of the GNU General Public License as published by
! the Free Software Foundation, either version 3 of the License, or
! (at your option) any later version.
!
! It is distributed in the hope that it will be useful,
! but WITHOUT ANY WARRANTY; without even the implied warranty of
! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
! GNU General Public License for more details.
!
! You should have received a copy of the GNU General Public License
! along with Dynare.  If not, see <http://www.gnu.org/licenses/>.
!

C        Generated by TAPENADE     (INRIA, Tropics team)
C  Tapenade - Version 2.2 (r1239) - Wed 28 Jun 2006 04:59:55 PM CEST
C
C  Differentiation of dgemm in forward (tangent) mode: (multi-directional mode)
C   variations  of output variables: c
C   with respect to input variables: a b c
      SUBROUTINE DGEMM_DV(transa, transb, m, n, k, alpha, a, ad, lda, b
     +                    , bd, ldb, beta, c, cd, ldc, nbdirs)
      USE DIFFSIZES
      IMPLICIT NONE
C
C     End of DGEMM .
C
      DOUBLE PRECISION alpha, beta
      INTEGER lda, ldb, ldc, nbdirs
      DOUBLE PRECISION a(lda, *), ad(nbdirsmax, lda, *), b(ldb, *), bd(
     +                 nbdirsmax, ldb, *), c(ldc, *), cd(nbdirsmax, ldc
     +                 , *)
      INTEGER k, m, n
      CHARACTER transa, transb
      DOUBLE PRECISION one, zero
      PARAMETER (one=1.0d+0, zero=0.0d+0)
      INTEGER i, info, j, l, max1, max2, max3, ncola, nd, nrowa, nrowb
      LOGICAL LSAME, nota, notb, result1, result2
      DOUBLE PRECISION temp, tempd(nbdirsmax)
      INTRINSIC MAX
      EXTERNAL XERBLA, LSAME
C     .. Scalar Arguments ..
C     ..
C     .. Array Arguments ..
C     ..
C
C  Purpose
C  =======
C
C  DGEMM  performs one of the matrix-matrix operations
C
C     C := alpha*op( A )*op( B ) + beta*C,
C
C  where  op( X ) is one of
C
C     op( X ) = X   or   op( X ) = X',
C
C  alpha and beta are scalars, and A, B and C are matrices, with op( A )
C  an m by k matrix,  op( B )  a  k by n matrix and  C an m by n matrix.
C
C  Arguments
C  ==========
C
C  TRANSA - CHARACTER*1.
C           On entry, TRANSA specifies the form of op( A ) to be used in
C           the matrix multiplication as follows:
C
C              TRANSA = 'N' or 'n',  op( A ) = A.
C
C              TRANSA = 'T' or 't',  op( A ) = A'.
C
C              TRANSA = 'C' or 'c',  op( A ) = A'.
C
C           Unchanged on exit.
C
C  TRANSB - CHARACTER*1.
C           On entry, TRANSB specifies the form of op( B ) to be used in
C           the matrix multiplication as follows:
C
C              TRANSB = 'N' or 'n',  op( B ) = B.
C
C              TRANSB = 'T' or 't',  op( B ) = B'.
C
C              TRANSB = 'C' or 'c',  op( B ) = B'.
C
C           Unchanged on exit.
C
C  M      - INTEGER.
C           On entry,  M  specifies  the number  of rows  of the  matrix
C           op( A )  and of the  matrix  C.  M  must  be at least  zero.
C           Unchanged on exit.
C
C  N      - INTEGER.
C           On entry,  N  specifies the number  of columns of the matrix
C           op( B ) and the number of columns of the matrix C. N must be
C           at least zero.
C           Unchanged on exit.
C
C  K      - INTEGER.
C           On entry,  K  specifies  the number of columns of the matrix
C           op( A ) and the number of rows of the matrix op( B ). K must
C           be at least  zero.
C           Unchanged on exit.
C
C  ALPHA  - DOUBLE PRECISION.
C           On entry, ALPHA specifies the scalar alpha.
C           Unchanged on exit.
C
C  A      - DOUBLE PRECISION array of DIMENSION ( LDA, ka ), where ka is
C           k  when  TRANSA = 'N' or 'n',  and is  m  otherwise.
C           Before entry with  TRANSA = 'N' or 'n',  the leading  m by k
C           part of the array  A  must contain the matrix  A,  otherwise
C           the leading  k by m  part of the array  A  must contain  the
C           matrix A.
C           Unchanged on exit.
C
C  LDA    - INTEGER.
C           On entry, LDA specifies the first dimension of A as declared
C           in the calling (sub) program. When  TRANSA = 'N' or 'n' then
C           LDA must be at least  max( 1, m ), otherwise  LDA must be at
C           least  max( 1, k ).
C           Unchanged on exit.
C
C  B      - DOUBLE PRECISION array of DIMENSION ( LDB, kb ), where kb is
C           n  when  TRANSB = 'N' or 'n',  and is  k  otherwise.
C           Before entry with  TRANSB = 'N' or 'n',  the leading  k by n
C           part of the array  B  must contain the matrix  B,  otherwise
C           the leading  n by k  part of the array  B  must contain  the
C           matrix B.
C           Unchanged on exit.
C
C  LDB    - INTEGER.
C           On entry, LDB specifies the first dimension of B as declared
C           in the calling (sub) program. When  TRANSB = 'N' or 'n' then
C           LDB must be at least  max( 1, k ), otherwise  LDB must be at
C           least  max( 1, n ).
C           Unchanged on exit.
C
C  BETA   - DOUBLE PRECISION.
C           On entry,  BETA  specifies the scalar  beta.  When  BETA  is
C           supplied as zero then C need not be set on input.
C           Unchanged on exit.
C
C  C      - DOUBLE PRECISION array of DIMENSION ( LDC, n ).
C           Before entry, the leading  m by n  part of the array  C must
C           contain the matrix  C,  except when  beta  is zero, in which
C           case C need not be set on entry.
C           On exit, the array  C  is overwritten by the  m by n  matrix
C           ( alpha*op( A )*op( B ) + beta*C ).
C
C  LDC    - INTEGER.
C           On entry, LDC specifies the first dimension of C as declared
C           in  the  calling  (sub)  program.   LDC  must  be  at  least
C           max( 1, m ).
C           Unchanged on exit.
C
C
C  Level 3 Blas routine.
C
C  -- Written on 8-February-1989.
C     Jack Dongarra, Argonne National Laboratory.
C     Iain Duff, AERE Harwell.
C     Jeremy Du Croz, Numerical Algorithms Group Ltd.
C     Sven Hammarling, Numerical Algorithms Group Ltd.
C
C
C     .. External Functions ..
C     ..
C     .. External Subroutines ..
C     ..
C     .. Intrinsic Functions ..
C     ..
C     .. Local Scalars ..
C     ..
C     .. Parameters ..
C     ..
C
C     Set  NOTA  and  NOTB  as  true if  A  and  B  respectively are not
C     transposed and set  NROWA, NCOLA and  NROWB  as the number of rows
C     and  columns of  A  and the  number of  rows  of  B  respectively.
C
      nota = LSAME(transa, 'N')
      notb = LSAME(transb, 'N')
      IF (nota) THEN
        nrowa = m
        ncola = k
      ELSE
        nrowa = k
        ncola = m
      END IF
      IF (notb) THEN
        nrowb = k
      ELSE
        nrowb = n
      END IF
C
C     Test the input parameters.
C
      info = 0
      result1 = LSAME(transa, 'C')
      result2 = LSAME(transa, 'T')
      IF (.NOT.nota .AND. (.NOT.result1) .AND. (.NOT.result2)) THEN
        info = 1
      ELSE
        result1 = LSAME(transb, 'C')
        result2 = LSAME(transb, 'T')
        IF (.NOT.notb .AND. (.NOT.result1) .AND. (.NOT.result2)) THEN
          info = 2
        ELSE IF (m .LT. 0) THEN
          info = 3
        ELSE IF (n .LT. 0) THEN
          info = 4
        ELSE IF (k .LT. 0) THEN
          info = 5
        ELSE
          IF (1 .LT. nrowa) THEN
            max1 = nrowa
          ELSE
            max1 = 1
          END IF
          IF (lda .LT. max1) THEN
            info = 8
          ELSE
            IF (1 .LT. nrowb) THEN
              max2 = nrowb
            ELSE
              max2 = 1
            END IF
            IF (ldb .LT. max2) THEN
              info = 10
            ELSE
              IF (1 .LT. m) THEN
                max3 = m
              ELSE
                max3 = 1
              END IF
              IF (ldc .LT. max3) info = 13
            END IF
          END IF
        END IF
      END IF
      IF (info .NE. 0) THEN
        CALL XERBLA('DGEMM ', info)
        RETURN
      ELSE IF (m .EQ. 0 .OR. n .EQ. 0 .OR. (alpha .EQ. zero .OR. k .EQ.
     +    0) .AND. beta .EQ. one) THEN
C
C     Quick return if possible.
C
        RETURN
      ELSE IF (alpha .EQ. zero) THEN
C
C     And if  alpha.eq.zero.
C
        IF (beta .EQ. zero) THEN
          DO j=1,n
            DO i=1,m
              DO nd=1,nbdirs
                cd(nd, i, j) = 0.D0
              ENDDO
              c(i, j) = zero
            ENDDO
          ENDDO
        ELSE
          DO j=1,n
            DO i=1,m
              DO nd=1,nbdirs
                cd(nd, i, j) = beta*cd(nd, i, j)
              ENDDO
              c(i, j) = beta*c(i, j)
            ENDDO
          ENDDO
        END IF
        RETURN
      ELSE
C
C     Start the operations.
C
        IF (notb) THEN
          IF (nota) THEN
C
C           Form  C := alpha*A*B + beta*C.
C
            DO j=1,n
              IF (beta .EQ. zero) THEN
                DO i=1,m
                  DO nd=1,nbdirs
                    cd(nd, i, j) = 0.D0
                  ENDDO
                  c(i, j) = zero
                ENDDO
              ELSE IF (beta .NE. one) THEN
                DO i=1,m
                  DO nd=1,nbdirs
                    cd(nd, i, j) = beta*cd(nd, i, j)
                  ENDDO
                  c(i, j) = beta*c(i, j)
                ENDDO
              END IF
              DO l=1,k
                IF (b(l, j) .NE. zero) THEN
                  DO nd=1,nbdirs
                    tempd(nd) = alpha*bd(nd, l, j)
                  ENDDO
                  temp = alpha*b(l, j)
                  DO i=1,m
                    DO nd=1,nbdirs
                      cd(nd, i, j) = cd(nd, i, j) + tempd(nd)*a(i, l) +
     +                  temp*ad(nd, i, l)
                    ENDDO
                    c(i, j) = c(i, j) + temp*a(i, l)
                  ENDDO
                END IF
              ENDDO
            ENDDO
          ELSE
C
C           Form  C := alpha*A'*B + beta*C
C
            DO j=1,n
              DO i=1,m
                temp = zero
                DO nd=1,nbdirs
                  tempd(nd) = 0.D0
                ENDDO
                DO l=1,k
                  DO nd=1,nbdirs
                    tempd(nd) = tempd(nd) + ad(nd, l, i)*b(l, j) + a(l,
     +                i)*bd(nd, l, j)
                  ENDDO
                  temp = temp + a(l, i)*b(l, j)
                ENDDO
                IF (beta .EQ. zero) THEN
                  DO nd=1,nbdirs
                    cd(nd, i, j) = alpha*tempd(nd)
                  ENDDO
                  c(i, j) = alpha*temp
                ELSE
                  DO nd=1,nbdirs
                    cd(nd, i, j) = alpha*tempd(nd) + beta*cd(nd, i, j)
                  ENDDO
                  c(i, j) = alpha*temp + beta*c(i, j)
                END IF
              ENDDO
            ENDDO
          END IF
        ELSE IF (nota) THEN
C
C           Form  C := alpha*A*B' + beta*C
C
          DO j=1,n
            IF (beta .EQ. zero) THEN
              DO i=1,m
                DO nd=1,nbdirs
                  cd(nd, i, j) = 0.D0
                ENDDO
                c(i, j) = zero
              ENDDO
            ELSE IF (beta .NE. one) THEN
              DO i=1,m
                DO nd=1,nbdirs
                  cd(nd, i, j) = beta*cd(nd, i, j)
                ENDDO
                c(i, j) = beta*c(i, j)
              ENDDO
            END IF
            DO l=1,k
              IF (b(j, l) .NE. zero) THEN
                DO nd=1,nbdirs
                  tempd(nd) = alpha*bd(nd, j, l)
                ENDDO
                temp = alpha*b(j, l)
                DO i=1,m
                  DO nd=1,nbdirs
                    cd(nd, i, j) = cd(nd, i, j) + tempd(nd)*a(i, l) +
     +                temp*ad(nd, i, l)
                  ENDDO
                  c(i, j) = c(i, j) + temp*a(i, l)
                ENDDO
              END IF
            ENDDO
          ENDDO
        ELSE
C
C           Form  C := alpha*A'*B' + beta*C
C
          DO j=1,n
            DO i=1,m
              temp = zero
              DO nd=1,nbdirs
                tempd(nd) = 0.D0
              ENDDO
              DO l=1,k
                DO nd=1,nbdirs
                  tempd(nd) = tempd(nd) + ad(nd, l, i)*b(j, l) + a(l, i)
     +              *bd(nd, j, l)
                ENDDO
                temp = temp + a(l, i)*b(j, l)
              ENDDO
              IF (beta .EQ. zero) THEN
                DO nd=1,nbdirs
                  cd(nd, i, j) = alpha*tempd(nd)
                ENDDO
                c(i, j) = alpha*temp
              ELSE
                DO nd=1,nbdirs
                  cd(nd, i, j) = alpha*tempd(nd) + beta*cd(nd, i, j)
                ENDDO
                c(i, j) = alpha*temp + beta*c(i, j)
              END IF
            ENDDO
          ENDDO
        END IF
C
        RETURN
      END IF
      END

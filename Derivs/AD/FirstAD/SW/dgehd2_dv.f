!
! Copyright (C) 2006-2014 Houtan Bastani and Luca Guerrieri
!
!
! This free software: you can redistribute it and/or modify
! it under the terms of the GNU General Public License as published by
! the Free Software Foundation, either version 3 of the License, or
! (at your option) any later version.
!
! It is distributed in the hope that it will be useful,
! but WITHOUT ANY WARRANTY; without even the implied warranty of
! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
! GNU General Public License for more details.
!
! You should have received a copy of the GNU General Public License
! along with Dynare.  If not, see <http://www.gnu.org/licenses/>.
!

C        Generated by TAPENADE     (INRIA, Tropics team)
C  Tapenade - Version 2.2 (r1239) - Wed 28 Jun 2006 04:59:55 PM CEST
C
C  Differentiation of dgehd2 in forward (tangent) mode: (multi-directional mode)
C   variations  of output variables: tau work a
C   with respect to input variables: tau work a
      SUBROUTINE DGEHD2_DV(n, ilo, ihi, a, ad, lda, tau, taud, work,
     +                     workd, info, nbdirs)

      USE DIFFSIZES
      IMPLICIT NONE
C
C     End of DGEHD2
C
      INTEGER ihi, ilo, info, n
      INTEGER lda, nbdirs
      DOUBLE PRECISION a(lda, *), ad(nbdirsmax, lda, *), tau(*), taud(
     +                 nbdirsmax, *), work(*), workd(nbdirsmax, *)
      DOUBLE PRECISION one
      PARAMETER (one=1.0d+0)
      DOUBLE PRECISION aii, aiid(nbdirsmax)
      INTEGER arg1, arg2, i, max1, max2, min1, min2, nd
      INTRINSIC MAX, MIN
      EXTERNAL XERBLA
C
C  -- LAPACK routine (version 3.1) --
C     Univ. of Tennessee, Univ. of California Berkeley and NAG Ltd..
C     November 2006
C
C     .. Scalar Arguments ..
C     ..
C     .. Array Arguments ..
C     ..
C
C  Purpose
C  =======
C
C  DGEHD2 reduces a real general matrix A to upper Hessenberg form H by
C  an orthogonal similarity transformation:  Q' * A * Q = H .
C
C  Arguments
C  =========
C
C  N       (input) INTEGER
C          The order of the matrix A.  N >= 0.
C
C  ILO     (input) INTEGER
C  IHI     (input) INTEGER
C          It is assumed that A is already upper triangular in rows
C          and columns 1:ILO-1 and IHI+1:N. ILO and IHI are normally
C          set by a previous call to DGEBAL; otherwise they should be
C          set to 1 and N respectively. See Further Details.
C          1 <= ILO <= IHI <= max(1,N).
C
C  A       (input/output) DOUBLE PRECISION array, dimension (LDA,N)
C          On entry, the n by n general matrix to be reduced.
C          On exit, the upper triangle and the first subdiagonal of A
C          are overwritten with the upper Hessenberg matrix H, and the
C          elements below the first subdiagonal, with the array TAU,
C          represent the orthogonal matrix Q as a product of elementary
C          reflectors. See Further Details.
C
C  LDA     (input) INTEGER
C          The leading dimension of the array A.  LDA >= max(1,N).
C
C  TAU     (output) DOUBLE PRECISION array, dimension (N-1)
C          The scalar factors of the elementary reflectors (see Further
C          Details).
C
C  WORK    (workspace) DOUBLE PRECISION array, dimension (N)
C
C  INFO    (output) INTEGER
C          = 0:  successful exit.
C          < 0:  if INFO = -i, the i-th argument had an illegal value.
C
C  Further Details
C  ===============
C
C  The matrix Q is represented as a product of (ihi-ilo) elementary
C  reflectors
C
C     Q = H(ilo) H(ilo+1) . . . H(ihi-1).
C
C  Each H(i) has the form
C
C     H(i) = I - tau * v * v'
C
C  where tau is a real scalar, and v is a real vector with
C  v(1:i) = 0, v(i+1) = 1 and v(ihi+1:n) = 0; v(i+2:ihi) is stored on
C  exit in A(i+2:ihi,i), and tau in TAU(i).
C
C  The contents of A are illustrated by the following example, with
C  n = 7, ilo = 2 and ihi = 6:
C
C  on entry,                        on exit,
C
C  ( a   a   a   a   a   a   a )    (  a   a   h   h   h   h   a )
C  (     a   a   a   a   a   a )    (      a   h   h   h   h   a )
C  (     a   a   a   a   a   a )    (      h   h   h   h   h   h )
C  (     a   a   a   a   a   a )    (      v2  h   h   h   h   h )
C  (     a   a   a   a   a   a )    (      v2  v3  h   h   h   h )
C  (     a   a   a   a   a   a )    (      v2  v3  v4  h   h   h )
C  (                         a )    (                          a )
C
C  where a denotes an element of the original matrix A, h denotes a
C  modified element of the upper Hessenberg matrix H, and vi denotes an
C  element of the vector defining H(i).
C
C  =====================================================================
C
C     .. Parameters ..
C     ..
C     .. Local Scalars ..
C     ..
C     .. External Subroutines ..
C     ..
C     .. Intrinsic Functions ..
C     ..
C     .. Executable Statements ..
C
C     Test the input parameters
C
      info = 0
      IF (n .LT. 0) THEN
        info = -1
      ELSE
        IF (1 .LT. n) THEN
          max1 = n
        ELSE
          max1 = 1
        END IF
        IF (ilo .LT. 1 .OR. ilo .GT. max1) THEN
          info = -2
        ELSE
          IF (ilo .GT. n) THEN
            min1 = n
          ELSE
            min1 = ilo
          END IF
          IF (ihi .LT. min1 .OR. ihi .GT. n) THEN
            info = -3
          ELSE
            IF (1 .LT. n) THEN
              max2 = n
            ELSE
              max2 = 1
            END IF
            IF (lda .LT. max2) info = -5
          END IF
        END IF
      END IF
      IF (info .NE. 0) THEN
        arg1 = -info
        CALL XERBLA('DGEHD2', arg1)
        RETURN
      ELSE
C
        DO i=ilo,ihi-1
          IF (i + 2 .GT. n) THEN
            min2 = n
          ELSE
            min2 = i + 2
          END IF
C
C        Compute elementary reflector H(i) to annihilate A(i+2:ihi,i)
C
          arg1 = ihi - i
          CALL DLARFG_DV(arg1, a(i+1, i), ad(1, i+1, i), a(min2, i), ad(
     +                   1, min2, i), 1, tau(i), taud(1, i), nbdirs)
          DO nd=1,nbdirs
            aiid(nd) = ad(nd, i+1, i)
            ad(nd, i+1, i) = 0.D0
          ENDDO
          aii = a(i+1, i)
          a(i+1, i) = one
C
C        Apply H(i) to A(1:ihi,i+1:ihi) from the right
C
          arg1 = ihi - i
          CALL DLARF_DV('Right', ihi, arg1, a(i+1, i), ad(1, i+1, i), 1
     +                  , tau(i), taud(1, i), a(1, i+1), ad(1, 1, i+1),
     +                  lda, work, workd, nbdirs)
C
C        Apply H(i) to A(i+1:ihi,i+1:n) from the left
C
          arg1 = ihi - i
          arg2 = n - i
          CALL DLARF_DV('Left', arg1, arg2, a(i+1, i), ad(1, i+1, i), 1
     +                  , tau(i), taud(1, i), a(i+1, i+1), ad(1, i+1, i+
     +                  1), lda, work, workd, nbdirs)
          DO nd=1,nbdirs
            ad(nd, i+1, i) = aiid(nd)
          ENDDO
C
          a(i+1, i) = aii
        ENDDO
C
        RETURN
      END IF
      END

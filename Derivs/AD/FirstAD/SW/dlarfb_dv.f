!
! Copyright (C) 2006-2014 Houtan Bastani and Luca Guerrieri
!
!
! This free software: you can redistribute it and/or modify
! it under the terms of the GNU General Public License as published by
! the Free Software Foundation, either version 3 of the License, or
! (at your option) any later version.
!
! It is distributed in the hope that it will be useful,
! but WITHOUT ANY WARRANTY; without even the implied warranty of
! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
! GNU General Public License for more details.
!
! You should have received a copy of the GNU General Public License
! along with Dynare.  If not, see <http://www.gnu.org/licenses/>.
!

C        Generated by TAPENADE     (INRIA, Tropics team)
C  Tapenade - Version 2.2 (r1239) - Wed 28 Jun 2006 04:59:55 PM CEST
C
C  Differentiation of dlarfb in forward (tangent) mode: (multi-directional mode)
C   variations  of output variables: work c
C   with respect to input variables: t v work c
      SUBROUTINE DLARFB_DV(side, trans, direct, storev, m, n, k, v, vd,
     +                     ldv, t, td, ldt, c, cd, ldc, work, workd,
     +                     ldwork, nbdirs)
      USE DIFFSIZES
      IMPLICIT NONE
C
C     End of DLARFB
C
      INTEGER ldc, ldt, ldv, ldwork, nbdirs
      DOUBLE PRECISION c(ldc, *), cd(nbdirsmax, ldc, *), t(ldt, *), td(
     +                 nbdirsmax, ldt, *), v(ldv, *), vd(nbdirsmax, ldv
     +                 , *), work(ldwork, *), workd(nbdirsmax, ldwork, *
     +                 )
      INTEGER k, m, n
      CHARACTER direct, side, storev, trans
      DOUBLE PRECISION one
      PARAMETER (one=1.0d+0)
      INTEGER arg1, i, j, nd
      DOUBLE PRECISION arg2
      LOGICAL LSAME, result1
      CHARACTER transt
      EXTERNAL LSAME
C
C  -- LAPACK auxiliary routine (version 3.1) --
C     Univ. of Tennessee, Univ. of California Berkeley and NAG Ltd..
C     November 2006
C
C     .. Scalar Arguments ..
C     ..
C     .. Array Arguments ..
C     ..
C
C  Purpose
C  =======
C
C  DLARFB applies a real block reflector H or its transpose H' to a
C  real m by n matrix C, from either the left or the right.
C
C  Arguments
C  =========
C
C  SIDE    (input) CHARACTER*1
C          = 'L': apply H or H' from the Left
C          = 'R': apply H or H' from the Right
C
C  TRANS   (input) CHARACTER*1
C          = 'N': apply H (No transpose)
C          = 'T': apply H' (Transpose)
C
C  DIRECT  (input) CHARACTER*1
C          Indicates how H is formed from a product of elementary
C          reflectors
C          = 'F': H = H(1) H(2) . . . H(k) (Forward)
C          = 'B': H = H(k) . . . H(2) H(1) (Backward)
C
C  STOREV  (input) CHARACTER*1
C          Indicates how the vectors which define the elementary
C          reflectors are stored:
C          = 'C': Columnwise
C          = 'R': Rowwise
C
C  M       (input) INTEGER
C          The number of rows of the matrix C.
C
C  N       (input) INTEGER
C          The number of columns of the matrix C.
C
C  K       (input) INTEGER
C          The order of the matrix T (= the number of elementary
C          reflectors whose product defines the block reflector).
C
C  V       (input) DOUBLE PRECISION array, dimension
C                                (LDV,K) if STOREV = 'C'
C                                (LDV,M) if STOREV = 'R' and SIDE = 'L'
C                                (LDV,N) if STOREV = 'R' and SIDE = 'R'
C          The matrix V. See further details.
C
C  LDV     (input) INTEGER
C          The leading dimension of the array V.
C          If STOREV = 'C' and SIDE = 'L', LDV >= max(1,M);
C          if STOREV = 'C' and SIDE = 'R', LDV >= max(1,N);
C          if STOREV = 'R', LDV >= K.
C
C  T       (input) DOUBLE PRECISION array, dimension (LDT,K)
C          The triangular k by k matrix T in the representation of the
C          block reflector.
C
C  LDT     (input) INTEGER
C          The leading dimension of the array T. LDT >= K.
C
C  C       (input/output) DOUBLE PRECISION array, dimension (LDC,N)
C          On entry, the m by n matrix C.
C          On exit, C is overwritten by H*C or H'*C or C*H or C*H'.
C
C  LDC     (input) INTEGER
C          The leading dimension of the array C. LDA >= max(1,M).
C
C  WORK    (workspace) DOUBLE PRECISION array, dimension (LDWORK,K)
C
C  LDWORK  (input) INTEGER
C          The leading dimension of the array WORK.
C          If SIDE = 'L', LDWORK >= max(1,N);
C          if SIDE = 'R', LDWORK >= max(1,M).
C
C  =====================================================================
C
C     .. Parameters ..
C     ..
C     .. Local Scalars ..
C     ..
C     .. External Functions ..
C     ..
C     .. External Subroutines ..
C     ..
C     .. Executable Statements ..
C
C     Quick return if possible
C
      IF (m .LE. 0 .OR. n .LE. 0) THEN
        RETURN
      ELSE
C
        result1 = LSAME(trans, 'N')
        IF (result1) THEN
          transt = 'T'
        ELSE
          transt = 'N'
        END IF
C
        result1 = LSAME(storev, 'C')
        IF (result1) THEN
C
          result1 = LSAME(direct, 'F')
          IF (result1) THEN
C
C           Let  V =  ( V1 )    (first K rows)
C                     ( V2 )
C           where  V1  is unit lower triangular.
C
            result1 = LSAME(side, 'L')
            IF (result1) THEN
C
C              Form  H * C  or  H' * C  where  C = ( C1 )
C                                                  ( C2 )
C
C              W := C' * V  =  (C1'*V1 + C2'*V2)  (stored in WORK)
C
C              W := C1'
C
              DO j=1,k
                CALL DCOPY_DV(n, c(j, 1), cd(1, j, 1), ldc, work(1, j),
     +                        workd(1, 1, j), 1, nbdirs)
              ENDDO
C
C              W := W * V1
C
              CALL DTRMM_DV('Right', 'Lower', 'No transpose', 'Unit', n
     +                      , k, one, v, vd, ldv, work, workd, ldwork,
     +                      nbdirs)
              IF (m .GT. k) THEN
C
C                 W := W + C2'*V2
C
                arg1 = m - k
                CALL DGEMM_DV('Transpose', 'No transpose', n, k, arg1,
     +                        one, c(k+1, 1), cd(1, k+1, 1), ldc, v(k+1
     +                        , 1), vd(1, k+1, 1), ldv, one, work, workd
     +                        , ldwork, nbdirs)
              END IF
C
C              W := W * T'  or  W * T
C
              CALL DTRMM_DV('Right', 'Upper', transt, 'Non-unit', n, k,
     +                      one, t, td, ldt, work, workd, ldwork, nbdirs
     +                     )
C
C              C := C - V * W'
C
              IF (m .GT. k) THEN
C
C                 C2 := C2 - V2 * W'
C
                arg1 = m - k
                arg2 = -one
                CALL DGEMM_DV('No transpose', 'Transpose', arg1, n, k,
     +                        arg2, v(k+1, 1), vd(1, k+1, 1), ldv, work
     +                        , workd, ldwork, one, c(k+1, 1), cd(1, k+1
     +                        , 1), ldc, nbdirs)
              END IF
C
C              W := W * V1'
C
              CALL DTRMM_DV('Right', 'Lower', 'Transpose', 'Unit', n, k
     +                      , one, v, vd, ldv, work, workd, ldwork,
     +                      nbdirs)
C
C              C1 := C1 - W'
C
              DO j=1,k
                DO i=1,n
                  DO nd=1,nbdirs
                    cd(nd, j, i) = cd(nd, j, i) - workd(nd, i, j)
                  ENDDO
                  c(j, i) = c(j, i) - work(i, j)
                ENDDO
              ENDDO
            ELSE
C
              result1 = LSAME(side, 'R')
              IF (result1) THEN
C
C              Form  C * H  or  C * H'  where  C = ( C1  C2 )
C
C              W := C * V  =  (C1*V1 + C2*V2)  (stored in WORK)
C
C              W := C1
C
                DO j=1,k
                  CALL DCOPY_DV(m, c(1, j), cd(1, 1, j), 1, work(1, j),
     +                          workd(1, 1, j), 1, nbdirs)
                ENDDO
C
C              W := W * V1
C
                CALL DTRMM_DV('Right', 'Lower', 'No transpose', 'Unit',
     +                        m, k, one, v, vd, ldv, work, workd, ldwork
     +                        , nbdirs)
                IF (n .GT. k) THEN
C
C                 W := W + C2 * V2
C
                  arg1 = n - k
                  CALL DGEMM_DV('No transpose', 'No transpose', m, k,
     +                          arg1, one, c(1, k+1), cd(1, 1, k+1), ldc
     +                          , v(k+1, 1), vd(1, k+1, 1), ldv, one,
     +                          work, workd, ldwork, nbdirs)
                END IF
C
C              W := W * T  or  W * T'
C
                CALL DTRMM_DV('Right', 'Upper', trans, 'Non-unit', m, k
     +                        , one, t, td, ldt, work, workd, ldwork,
     +                        nbdirs)
C
C              C := C - W * V'
C
                IF (n .GT. k) THEN
C
C                 C2 := C2 - W * V2'
C
                  arg1 = n - k
                  arg2 = -one
                  CALL DGEMM_DV('No transpose', 'Transpose', m, arg1, k
     +                          , arg2, work, workd, ldwork, v(k+1, 1),
     +                          vd(1, k+1, 1), ldv, one, c(1, k+1), cd(1
     +                          , 1, k+1), ldc, nbdirs)
                END IF
C
C              W := W * V1'
C
                CALL DTRMM_DV('Right', 'Lower', 'Transpose', 'Unit', m,
     +                        k, one, v, vd, ldv, work, workd, ldwork,
     +                        nbdirs)
C
C              C1 := C1 - W
C
                DO j=1,k
                  DO i=1,m
                    DO nd=1,nbdirs
                      cd(nd, i, j) = cd(nd, i, j) - workd(nd, i, j)
                    ENDDO
                    c(i, j) = c(i, j) - work(i, j)
                  ENDDO
                ENDDO
              END IF
            END IF
          ELSE
C
C
C           Let  V =  ( V1 )
C                     ( V2 )    (last K rows)
C           where  V2  is unit upper triangular.
C
            result1 = LSAME(side, 'L')
            IF (result1) THEN
C
C              Form  H * C  or  H' * C  where  C = ( C1 )
C                                                  ( C2 )
C
C              W := C' * V  =  (C1'*V1 + C2'*V2)  (stored in WORK)
C
C              W := C2'
C
              DO j=1,k
                CALL DCOPY_DV(n, c(m-k+j, 1), cd(1, m-k+j, 1), ldc, work
     +                        (1, j), workd(1, 1, j), 1, nbdirs)
              ENDDO
C
C              W := W * V2
C
              CALL DTRMM_DV('Right', 'Upper', 'No transpose', 'Unit', n
     +                      , k, one, v(m-k+1, 1), vd(1, m-k+1, 1), ldv
     +                      , work, workd, ldwork, nbdirs)
              IF (m .GT. k) THEN
C
C                 W := W + C1'*V1
C
                arg1 = m - k
                CALL DGEMM_DV('Transpose', 'No transpose', n, k, arg1,
     +                        one, c, cd, ldc, v, vd, ldv, one, work,
     +                        workd, ldwork, nbdirs)
              END IF
C
C              W := W * T'  or  W * T
C
              CALL DTRMM_DV('Right', 'Lower', transt, 'Non-unit', n, k,
     +                      one, t, td, ldt, work, workd, ldwork, nbdirs
     +                     )
C
C              C := C - V * W'
C
              IF (m .GT. k) THEN
C
C                 C1 := C1 - V1 * W'
C
                arg1 = m - k
                arg2 = -one
                CALL DGEMM_DV('No transpose', 'Transpose', arg1, n, k,
     +                        arg2, v, vd, ldv, work, workd, ldwork, one
     +                        , c, cd, ldc, nbdirs)
              END IF
C
C              W := W * V2'
C
              CALL DTRMM_DV('Right', 'Upper', 'Transpose', 'Unit', n, k
     +                      , one, v(m-k+1, 1), vd(1, m-k+1, 1), ldv,
     +                      work, workd, ldwork, nbdirs)
C
C              C2 := C2 - W'
C
              DO j=1,k
                DO i=1,n
                  DO nd=1,nbdirs
                    cd(nd, m-k+j, i) = cd(nd, m-k+j, i) - workd(nd, i, j
     +                )
                  ENDDO
                  c(m-k+j, i) = c(m-k+j, i) - work(i, j)
                ENDDO
              ENDDO
            ELSE
C
              result1 = LSAME(side, 'R')
              IF (result1) THEN
C
C              Form  C * H  or  C * H'  where  C = ( C1  C2 )
C
C              W := C * V  =  (C1*V1 + C2*V2)  (stored in WORK)
C
C              W := C2
C
                DO j=1,k
                  CALL DCOPY_DV(m, c(1, n-k+j), cd(1, 1, n-k+j), 1, work
     +                          (1, j), workd(1, 1, j), 1, nbdirs)
                ENDDO
C
C              W := W * V2
C
                CALL DTRMM_DV('Right', 'Upper', 'No transpose', 'Unit',
     +                        m, k, one, v(n-k+1, 1), vd(1, n-k+1, 1),
     +                        ldv, work, workd, ldwork, nbdirs)
                IF (n .GT. k) THEN
C
C                 W := W + C1 * V1
C
                  arg1 = n - k
                  CALL DGEMM_DV('No transpose', 'No transpose', m, k,
     +                          arg1, one, c, cd, ldc, v, vd, ldv, one,
     +                          work, workd, ldwork, nbdirs)
                END IF
C
C              W := W * T  or  W * T'
C
                CALL DTRMM_DV('Right', 'Lower', trans, 'Non-unit', m, k
     +                        , one, t, td, ldt, work, workd, ldwork,
     +                        nbdirs)
C
C              C := C - W * V'
C
                IF (n .GT. k) THEN
C
C                 C1 := C1 - W * V1'
C
                  arg1 = n - k
                  arg2 = -one
                  CALL DGEMM_DV('No transpose', 'Transpose', m, arg1, k
     +                          , arg2, work, workd, ldwork, v, vd, ldv
     +                          , one, c, cd, ldc, nbdirs)
                END IF
C
C              W := W * V2'
C
                CALL DTRMM_DV('Right', 'Upper', 'Transpose', 'Unit', m,
     +                        k, one, v(n-k+1, 1), vd(1, n-k+1, 1), ldv
     +                        , work, workd, ldwork, nbdirs)
C
C              C2 := C2 - W
C
                DO j=1,k
                  DO i=1,m
                    DO nd=1,nbdirs
                      cd(nd, i, n-k+j) = cd(nd, i, n-k+j) - workd(nd, i
     +                  , j)
                    ENDDO
                    c(i, n-k+j) = c(i, n-k+j) - work(i, j)
                  ENDDO
                ENDDO
              END IF
            END IF
          END IF
        ELSE
C
          result1 = LSAME(storev, 'R')
          IF (result1) THEN
C
            result1 = LSAME(direct, 'F')
            IF (result1) THEN
C
C           Let  V =  ( V1  V2 )    (V1: first K columns)
C           where  V1  is unit upper triangular.
C
              result1 = LSAME(side, 'L')
              IF (result1) THEN
C
C              Form  H * C  or  H' * C  where  C = ( C1 )
C                                                  ( C2 )
C
C              W := C' * V'  =  (C1'*V1' + C2'*V2') (stored in WORK)
C
C              W := C1'
C
                DO j=1,k
                  CALL DCOPY_DV(n, c(j, 1), cd(1, j, 1), ldc, work(1, j)
     +                          , workd(1, 1, j), 1, nbdirs)
                ENDDO
C
C              W := W * V1'
C
                CALL DTRMM_DV('Right', 'Upper', 'Transpose', 'Unit', n,
     +                        k, one, v, vd, ldv, work, workd, ldwork,
     +                        nbdirs)
                IF (m .GT. k) THEN
C
C                 W := W + C2'*V2'
C
                  arg1 = m - k
                  CALL DGEMM_DV('Transpose', 'Transpose', n, k, arg1,
     +                          one, c(k+1, 1), cd(1, k+1, 1), ldc, v(1
     +                          , k+1), vd(1, 1, k+1), ldv, one, work,
     +                          workd, ldwork, nbdirs)
                END IF
C
C              W := W * T'  or  W * T
C
                CALL DTRMM_DV('Right', 'Upper', transt, 'Non-unit', n, k
     +                        , one, t, td, ldt, work, workd, ldwork,
     +                        nbdirs)
C
C              C := C - V' * W'
C
                IF (m .GT. k) THEN
C
C                 C2 := C2 - V2' * W'
C
                  arg1 = m - k
                  arg2 = -one
                  CALL DGEMM_DV('Transpose', 'Transpose', arg1, n, k,
     +                          arg2, v(1, k+1), vd(1, 1, k+1), ldv,
     +                          work, workd, ldwork, one, c(k+1, 1), cd(
     +                          1, k+1, 1), ldc, nbdirs)
                END IF
C
C              W := W * V1
C
                CALL DTRMM_DV('Right', 'Upper', 'No transpose', 'Unit',
     +                        n, k, one, v, vd, ldv, work, workd, ldwork
     +                        , nbdirs)
C
C              C1 := C1 - W'
C
                DO j=1,k
                  DO i=1,n
                    DO nd=1,nbdirs
                      cd(nd, j, i) = cd(nd, j, i) - workd(nd, i, j)
                    ENDDO
                    c(j, i) = c(j, i) - work(i, j)
                  ENDDO
                ENDDO
              ELSE
C
                result1 = LSAME(side, 'R')
                IF (result1) THEN
C
C              Form  C * H  or  C * H'  where  C = ( C1  C2 )
C
C              W := C * V'  =  (C1*V1' + C2*V2')  (stored in WORK)
C
C              W := C1
C
                  DO j=1,k
                    CALL DCOPY_DV(m, c(1, j), cd(1, 1, j), 1, work(1, j)
     +                            , workd(1, 1, j), 1, nbdirs)
                  ENDDO
C
C              W := W * V1'
C
                  CALL DTRMM_DV('Right', 'Upper', 'Transpose', 'Unit', m
     +                          , k, one, v, vd, ldv, work, workd,
     +                          ldwork, nbdirs)
                  IF (n .GT. k) THEN
C
C                 W := W + C2 * V2'
C
                    arg1 = n - k
                    CALL DGEMM_DV('No transpose', 'Transpose', m, k,
     +                            arg1, one, c(1, k+1), cd(1, 1, k+1),
     +                            ldc, v(1, k+1), vd(1, 1, k+1), ldv,
     +                            one, work, workd, ldwork, nbdirs)
                  END IF
C
C              W := W * T  or  W * T'
C
                  CALL DTRMM_DV('Right', 'Upper', trans, 'Non-unit', m,
     +                          k, one, t, td, ldt, work, workd, ldwork
     +                          , nbdirs)
C
C              C := C - W * V
C
                  IF (n .GT. k) THEN
C
C                 C2 := C2 - W * V2
C
                    arg1 = n - k
                    arg2 = -one
                    CALL DGEMM_DV('No transpose', 'No transpose', m,
     +                            arg1, k, arg2, work, workd, ldwork, v(
     +                            1, k+1), vd(1, 1, k+1), ldv, one, c(1
     +                            , k+1), cd(1, 1, k+1), ldc, nbdirs)
                  END IF
C
C              W := W * V1
C
                  CALL DTRMM_DV('Right', 'Upper', 'No transpose', 'Unit'
     +                          , m, k, one, v, vd, ldv, work, workd,
     +                          ldwork, nbdirs)
C
C              C1 := C1 - W
C
                  DO j=1,k
                    DO i=1,m
                      DO nd=1,nbdirs
                        cd(nd, i, j) = cd(nd, i, j) - workd(nd, i, j)
                      ENDDO
                      c(i, j) = c(i, j) - work(i, j)
                    ENDDO
                  ENDDO
                END IF
              END IF
            ELSE
C
C
C
C           Let  V =  ( V1  V2 )    (V2: last K columns)
C           where  V2  is unit lower triangular.
C
              result1 = LSAME(side, 'L')
              IF (result1) THEN
C
C              Form  H * C  or  H' * C  where  C = ( C1 )
C                                                  ( C2 )
C
C              W := C' * V'  =  (C1'*V1' + C2'*V2') (stored in WORK)
C
C              W := C2'
C
                DO j=1,k
                  CALL DCOPY_DV(n, c(m-k+j, 1), cd(1, m-k+j, 1), ldc,
     +                          work(1, j), workd(1, 1, j), 1, nbdirs)
                ENDDO
C
C              W := W * V2'
C
                CALL DTRMM_DV('Right', 'Lower', 'Transpose', 'Unit', n,
     +                        k, one, v(1, m-k+1), vd(1, 1, m-k+1), ldv
     +                        , work, workd, ldwork, nbdirs)
                IF (m .GT. k) THEN
C
C                 W := W + C1'*V1'
C
                  arg1 = m - k
                  CALL DGEMM_DV('Transpose', 'Transpose', n, k, arg1,
     +                          one, c, cd, ldc, v, vd, ldv, one, work,
     +                          workd, ldwork, nbdirs)
                END IF
C
C              W := W * T'  or  W * T
C
                CALL DTRMM_DV('Right', 'Lower', transt, 'Non-unit', n, k
     +                        , one, t, td, ldt, work, workd, ldwork,
     +                        nbdirs)
C
C              C := C - V' * W'
C
                IF (m .GT. k) THEN
C
C                 C1 := C1 - V1' * W'
C
                  arg1 = m - k
                  arg2 = -one
                  CALL DGEMM_DV('Transpose', 'Transpose', arg1, n, k,
     +                          arg2, v, vd, ldv, work, workd, ldwork,
     +                          one, c, cd, ldc, nbdirs)
                END IF
C
C              W := W * V2
C
                CALL DTRMM_DV('Right', 'Lower', 'No transpose', 'Unit',
     +                        n, k, one, v(1, m-k+1), vd(1, 1, m-k+1),
     +                        ldv, work, workd, ldwork, nbdirs)
C
C              C2 := C2 - W'
C
                DO j=1,k
                  DO i=1,n
                    DO nd=1,nbdirs
                      cd(nd, m-k+j, i) = cd(nd, m-k+j, i) - workd(nd, i
     +                  , j)
                    ENDDO
                    c(m-k+j, i) = c(m-k+j, i) - work(i, j)
                  ENDDO
                ENDDO
              ELSE
C
                result1 = LSAME(side, 'R')
                IF (result1) THEN
C
C              Form  C * H  or  C * H'  where  C = ( C1  C2 )
C
C              W := C * V'  =  (C1*V1' + C2*V2')  (stored in WORK)
C
C              W := C2
C
                  DO j=1,k
                    CALL DCOPY_DV(m, c(1, n-k+j), cd(1, 1, n-k+j), 1,
     +                            work(1, j), workd(1, 1, j), 1, nbdirs)
                  ENDDO
C
C              W := W * V2'
C
                  CALL DTRMM_DV('Right', 'Lower', 'Transpose', 'Unit', m
     +                          , k, one, v(1, n-k+1), vd(1, 1, n-k+1),
     +                          ldv, work, workd, ldwork, nbdirs)
                  IF (n .GT. k) THEN
C
C                 W := W + C1 * V1'
C
                    arg1 = n - k
                    CALL DGEMM_DV('No transpose', 'Transpose', m, k,
     +                            arg1, one, c, cd, ldc, v, vd, ldv, one
     +                            , work, workd, ldwork, nbdirs)
                  END IF
C
C              W := W * T  or  W * T'
C
                  CALL DTRMM_DV('Right', 'Lower', trans, 'Non-unit', m,
     +                          k, one, t, td, ldt, work, workd, ldwork
     +                          , nbdirs)
C
C              C := C - W * V
C
                  IF (n .GT. k) THEN
C
C                 C1 := C1 - W * V1
C
                    arg1 = n - k
                    arg2 = -one
                    CALL DGEMM_DV('No transpose', 'No transpose', m,
     +                            arg1, k, arg2, work, workd, ldwork, v
     +                            , vd, ldv, one, c, cd, ldc, nbdirs)
                  END IF
C
C              W := W * V2
C
                  CALL DTRMM_DV('Right', 'Lower', 'No transpose', 'Unit'
     +                          , m, k, one, v(1, n-k+1), vd(1, 1, n-k+1
     +                          ), ldv, work, workd, ldwork, nbdirs)
C
C              C1 := C1 - W
C
                  DO j=1,k
                    DO i=1,m
                      DO nd=1,nbdirs
                        cd(nd, i, n-k+j) = cd(nd, i, n-k+j) - workd(nd,
     +                    i, j)
                      ENDDO
                      c(i, n-k+j) = c(i, n-k+j) - work(i, j)
                    ENDDO
                  ENDDO
                END IF
              END IF
            END IF
          END IF
        END IF
C
C
C
        RETURN
      END IF
      END

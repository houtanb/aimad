!
! Copyright (C) 2006-2014 Houtan Bastani and Luca Guerrieri
!
!
! This free software: you can redistribute it and/or modify
! it under the terms of the GNU General Public License as published by
! the Free Software Foundation, either version 3 of the License, or
! (at your option) any later version.
!
! It is distributed in the hope that it will be useful,
! but WITHOUT ANY WARRANTY; without even the implied warranty of
! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
! GNU General Public License for more details.
!
! You should have received a copy of the GNU General Public License
! along with Dynare.  If not, see <http://www.gnu.org/licenses/>.
!

C        Generated by TAPENADE     (INRIA, Tropics team)
C  Tapenade - Version 2.2 (r1239) - Wed 28 Jun 2006 04:59:55 PM CEST
C
C  Differentiation of dgehrd in forward (tangent) mode: (multi-directional mode)
C   variations  of output variables: tau work a
C   with respect to input variables: tau work a
      SUBROUTINE DGEHRD_DV(n, ilo, ihi, a, ad, lda, tau, taud, work,
     +                     workd, lwork, info, nbdirs)
      USE DIFFSIZES
      IMPLICIT NONE
C
C     End of DGEHRD
C
      INTEGER ihi, ilo, info, lwork, n
      INTEGER lda, nbdirs
      DOUBLE PRECISION a(lda, *), ad(nbdirsmax, lda, *), tau(*), taud(
     +                 nbdirsmax, *), work(*), workd(nbdirsmax, *)
      INTEGER nbmax
      PARAMETER (nbmax=64)
      INTEGER ldt
      PARAMETER (ldt=nbmax+1)
      DOUBLE PRECISION one, zero
      PARAMETER (one=1.0d+0, zero=0.0d+0)
      DOUBLE PRECISION arg10, arg2
      INTEGER arg1, arg20, i, ib, ii1, ii2, iinfo, ILAENV, iws, j,
     +        ldwork, lwkopt, max1, max2, max3, max4, min1, nb, nbmin,
     +        nd, nh, nx, y1, y2, y3, y4
      DOUBLE PRECISION ei, eid(nbdirsmax)
      LOGICAL lquery
      DOUBLE PRECISION t(ldt, nbmax), td(nbdirsmax, ldt, nbmax)
      EXTERNAL ILAENV, XERBLA
      INTRINSIC MAX, MIN
C
C  -- LAPACK routine (version 3.1) --
C     Univ. of Tennessee, Univ. of California Berkeley and NAG Ltd..
C     November 2006
C
C     .. Scalar Arguments ..
C     ..
C     .. Array Arguments ..
C     ..
C
C  Purpose
C  =======
C
C  DGEHRD reduces a real general matrix A to upper Hessenberg form H by
C  an orthogonal similarity transformation:  Q' * A * Q = H .
C
C  Arguments
C  =========
C
C  N       (input) INTEGER
C          The order of the matrix A.  N >= 0.
C
C  ILO     (input) INTEGER
C  IHI     (input) INTEGER
C          It is assumed that A is already upper triangular in rows
C          and columns 1:ILO-1 and IHI+1:N. ILO and IHI are normally
C          set by a previous call to DGEBAL; otherwise they should be
C          set to 1 and N respectively. See Further Details.
C          1 <= ILO <= IHI <= N, if N > 0; ILO=1 and IHI=0, if N=0.
C
C  A       (input/output) DOUBLE PRECISION array, dimension (LDA,N)
C          On entry, the N-by-N general matrix to be reduced.
C          On exit, the upper triangle and the first subdiagonal of A
C          are overwritten with the upper Hessenberg matrix H, and the
C          elements below the first subdiagonal, with the array TAU,
C          represent the orthogonal matrix Q as a product of elementary
C          reflectors. See Further Details.
C
C  LDA     (input) INTEGER
C          The leading dimension of the array A.  LDA >= max(1,N).
C
C  TAU     (output) DOUBLE PRECISION array, dimension (N-1)
C          The scalar factors of the elementary reflectors (see Further
C          Details). Elements 1:ILO-1 and IHI:N-1 of TAU are set to
C          zero.
C
C  WORK    (workspace/output) DOUBLE PRECISION array, dimension (LWORK)
C          On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
C
C  LWORK   (input) INTEGER
C          The length of the array WORK.  LWORK >= max(1,N).
C          For optimum performance LWORK >= N*NB, where NB is the
C          optimal blocksize.
C
C          If LWORK = -1, then a workspace query is assumed; the routine
C          only calculates the optimal size of the WORK array, returns
C          this value as the first entry of the WORK array, and no error
C          message related to LWORK is issued by XERBLA.
C
C  INFO    (output) INTEGER
C          = 0:  successful exit
C          < 0:  if INFO = -i, the i-th argument had an illegal value.
C
C  Further Details
C  ===============
C
C  The matrix Q is represented as a product of (ihi-ilo) elementary
C  reflectors
C
C     Q = H(ilo) H(ilo+1) . . . H(ihi-1).
C
C  Each H(i) has the form
C
C     H(i) = I - tau * v * v'
C
C  where tau is a real scalar, and v is a real vector with
C  v(1:i) = 0, v(i+1) = 1 and v(ihi+1:n) = 0; v(i+2:ihi) is stored on
C  exit in A(i+2:ihi,i), and tau in TAU(i).
C
C  The contents of A are illustrated by the following example, with
C  n = 7, ilo = 2 and ihi = 6:
C
C  on entry,                        on exit,
C
C  ( a   a   a   a   a   a   a )    (  a   a   h   h   h   h   a )
C  (     a   a   a   a   a   a )    (      a   h   h   h   h   a )
C  (     a   a   a   a   a   a )    (      h   h   h   h   h   h )
C  (     a   a   a   a   a   a )    (      v2  h   h   h   h   h )
C  (     a   a   a   a   a   a )    (      v2  v3  h   h   h   h )
C  (     a   a   a   a   a   a )    (      v2  v3  v4  h   h   h )
C  (                         a )    (                          a )
C
C  where a denotes an element of the original matrix A, h denotes a
C  modified element of the upper Hessenberg matrix H, and vi denotes an
C  element of the vector defining H(i).
C
C  This file is a slight modification of LAPACK-3.0's DGEHRD
C  subroutine incorporating improvements proposed by Quintana-Orti and
C  Van de Geijn (2005).
C
C  =====================================================================
C
C     .. Parameters ..
C     ..
C     .. Local Scalars ..
C     ..
C     .. Local Arrays ..
C     ..
C     .. External Subroutines ..
C     ..
C     .. Intrinsic Functions ..
C     ..
C     .. External Functions ..
C     ..
C     .. Executable Statements ..
C
C     Test the input parameters
C
      info = 0
      arg1 = -1
      y1 = ILAENV(1, 'DGEHRD', ' ', n, ilo, ihi, arg1)
      IF (nbmax .GT. y1) THEN
        nb = y1
      ELSE
        nb = nbmax
      END IF
      lwkopt = n*nb
      DO nd=1,nbdirs
        workd(nd, 1) = 0.D0
      ENDDO
      work(1) = lwkopt
      lquery = lwork .EQ. -1
      IF (n .LT. 0) THEN
        info = -1
      ELSE
        IF (1 .LT. n) THEN
          max1 = n
        ELSE
          max1 = 1
        END IF
        IF (ilo .LT. 1 .OR. ilo .GT. max1) THEN
          info = -2
        ELSE
          IF (ilo .GT. n) THEN
            min1 = n
          ELSE
            min1 = ilo
          END IF
          IF (ihi .LT. min1 .OR. ihi .GT. n) THEN
            info = -3
          ELSE
            IF (1 .LT. n) THEN
              max2 = n
            ELSE
              max2 = 1
            END IF
            IF (lda .LT. max2) THEN
              info = -5
            ELSE
              IF (1 .LT. n) THEN
                max3 = n
              ELSE
                max3 = 1
              END IF
              IF (lwork .LT. max3 .AND. (.NOT.lquery)) info = -8
            END IF
          END IF
        END IF
      END IF
      IF (info .NE. 0) THEN
        arg1 = -info
        CALL XERBLA('DGEHRD', arg1)
        RETURN
      ELSE IF (lquery) THEN
        RETURN
      ELSE
C
C     Set elements 1:ILO-1 and IHI:N-1 of TAU to zero
C
        DO i=1,ilo-1
          DO nd=1,nbdirs
            taud(nd, i) = 0.D0
          ENDDO
          tau(i) = zero
        ENDDO
        IF (1 .LT. ihi) THEN
          max4 = ihi
        ELSE
          max4 = 1
        END IF
        DO i=max4,n-1
          DO nd=1,nbdirs
            taud(nd, i) = 0.D0
          ENDDO
          tau(i) = zero
        ENDDO
C
C     Quick return if possible
C
        nh = ihi - ilo + 1
        IF (nh .LE. 1) THEN
          DO nd=1,nbdirs
            workd(nd, 1) = 0.D0
          ENDDO
          work(1) = 1
          RETURN
        ELSE
          arg1 = -1
          y2 = ILAENV(1, 'DGEHRD', ' ', n, ilo, ihi, arg1)
          IF (nbmax .GT. y2) THEN
            nb = y2
          ELSE
            nb = nbmax
          END IF
          nbmin = 2
          iws = 1
          IF (nb .GT. 1 .AND. nb .LT. nh) THEN
            arg1 = -1
            y3 = ILAENV(3, 'DGEHRD', ' ', n, ilo, ihi, arg1)
            IF (nb .LT. y3) THEN
              nx = y3
            ELSE
              nx = nb
            END IF
            IF (nx .LT. nh) THEN
C
C           Determine if workspace is large enough for blocked code
C
              iws = n*nb
              IF (lwork .LT. iws) THEN
                arg1 = -1
                y4 = ILAENV(2, 'DGEHRD', ' ', n, ilo, ihi, arg1)
                IF (2 .LT. y4) THEN
                  nbmin = y4
                ELSE
                  nbmin = 2
                END IF
                IF (lwork .GE. n*nbmin) THEN
                  nb = lwork/n
                ELSE
                  nb = 1
                END IF
              END IF
            END IF
          END IF
          ldwork = n
C
          IF (nb .LT. nbmin .OR. nb .GE. nh) THEN
C
C        Use unblocked code below
C
            i = ilo
C
          ELSE
            DO ii1=1,nbmax
              DO ii2=1,ldt
                DO nd=1,nbdirs
                  td(nd, ii2, ii1) = 0.D0
                ENDDO
              ENDDO
            ENDDO
C
C        Use blocked code
C
            DO i=ilo,ihi-1-nx,nb
              IF (nb .GT. ihi - i) THEN
                ib = ihi - i
              ELSE
                ib = nb
              END IF
C
C           Reduce columns i:i+ib-1 to Hessenberg form, returning the
C           matrices V and T of the block reflector H = I - V*T*V'
C           which performs the reduction, and also the matrix Y = A*V*T
C
              CALL DLAHR2_DV(ihi, i, ib, a(1, i), ad(1, 1, i), lda, tau(
     +                       i), taud(1, i), t, td, ldt, work, workd,
     +                       ldwork, nbdirs)
              DO nd=1,nbdirs
                eid(nd) = ad(nd, i+ib, i+ib-1)
                ad(nd, i+ib, i+ib-1) = 0.D0
              ENDDO
C
C           Apply the block reflector H to A(1:ihi,i+ib:ihi) from the
C           right, computing  A := A - Y * V'. V(i+ib,ib-1) must be set
C           to 1
C
              ei = a(i+ib, i+ib-1)
              a(i+ib, i+ib-1) = one
              arg1 = ihi - i - ib + 1
              arg2 = -one
              CALL DGEMM_DV('No transpose', 'Transpose', ihi, arg1, ib,
     +                      arg2, work, workd, ldwork, a(i+ib, i), ad(1
     +                      , i+ib, i), lda, one, a(1, i+ib), ad(1, 1, i
     +                      +ib), lda, nbdirs)
              DO nd=1,nbdirs
                ad(nd, i+ib, i+ib-1) = eid(nd)
              ENDDO
              a(i+ib, i+ib-1) = ei
C
C           Apply the block reflector H to A(1:i,i+1:i+ib-1) from the
C           right
C
              arg1 = ib - 1
              CALL DTRMM_DV('Right', 'Lower', 'Transpose', 'Unit', i,
     +                      arg1, one, a(i+1, i), ad(1, i+1, i), lda,
     +                      work, workd, ldwork, nbdirs)
              DO j=0,ib-2
                arg10 = -one
                CALL DAXPY_DV(i, arg10, work(ldwork*j+1), workd(1,
     +                        ldwork*j+1), 1, a(1, i+j+1), ad(1, 1, i+j+
     +                        1), 1, nbdirs)
              ENDDO
C
C           Apply the block reflector H to A(i+1:ihi,i+ib:n) from the
C           left
C
              arg1 = ihi - i
              arg20 = n - i - ib + 1
              CALL DLARFB_DV('Left', 'Transpose', 'Forward',
     +                       'Columnwise', arg1, arg20, ib, a(i+1, i),
     +                       ad(1, i+1, i), lda, t, td, ldt, a(i+1, i+ib
     +                       ), ad(1, i+1, i+ib), lda, work, workd,
     +                       ldwork, nbdirs)
            ENDDO
          END IF
C
C     Use unblocked code to reduce the rest of the matrix
C
          CALL DGEHD2_DV(n, i, ihi, a, ad, lda, tau, taud, work, workd,
     +                   iinfo, nbdirs)
          DO nd=1,nbdirs
            workd(nd, 1) = 0.D0
          ENDDO
          work(1) = iws
C
          RETURN
        END IF
      END IF
      END

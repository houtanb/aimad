!
! Copyright (C) 2006-2014 Houtan Bastani and Luca Guerrieri
!
!
! This free software: you can redistribute it and/or modify
! it under the terms of the GNU General Public License as published by
! the Free Software Foundation, either version 3 of the License, or
! (at your option) any later version.
!
! It is distributed in the hope that it will be useful,
! but WITHOUT ANY WARRANTY; without even the implied warranty of
! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
! GNU General Public License for more details.
!
! You should have received a copy of the GNU General Public License
! along with Dynare.  If not, see <http://www.gnu.org/licenses/>.
!

C        Generated by TAPENADE     (INRIA, Tropics team)
C  Tapenade - Version 2.2 (r1239) - Wed 28 Jun 2006 04:59:55 PM CEST
C
C  Differentiation of dlaqr4 in forward (tangent) mode: (multi-directional mode)
C   variations  of output variables: wr h z work wi
C   with respect to input variables: wr h z work wi
      SUBROUTINE DLAQR4_DV(wantt, wantz, n, ilo, ihi, h, hd, ldh, wr,
     +                     wrd, wi, wid, iloz, ihiz, z, zd, ldz, work,
     +                     workd, lwork, info, nbdirs)
      USE DIFFSIZES
      IMPLICIT NONE
C
C     ==== End of DLAQR4 ====
C
      INTEGER ihi, ihiz, ilo, iloz, info, lwork, n
      INTEGER ldh, ldz, nbdirs
      LOGICAL wantt, wantz
      DOUBLE PRECISION h(ldh, *), hd(nbdirsmax, ldh, *), wi(*), wid(
     +                 nbdirsmax, *), work(*), workd(nbdirsmax, *), wr(*
     +                 ), wrd(nbdirsmax, *), z(ldz, *), zd(nbdirsmax,
     +                 ldz, *)
      INTEGER kexnw, kexsh, ntiny
      PARAMETER (kexnw=5, kexsh=6, ntiny=11)
      DOUBLE PRECISION one, zero
      PARAMETER (one=1.0d0, zero=0.0d0)
      DOUBLE PRECISION wilk1, wilk2
      PARAMETER (wilk1=0.75d0, wilk2=-0.4375d0)
      DOUBLE PRECISION abs1, abs10, abs2, abs2d(nbdirsmax), abs3, abs4,
     +                 abs5, abs6, abs6d(nbdirsmax), abs7, abs8, abs9
      DOUBLE PRECISION aa, aad(nbdirsmax), bb, bbd(nbdirsmax), cc, ccd(
     +                 nbdirsmax), cs, csd(nbdirsmax), dd, ddd(nbdirsmax
     +                 ), sn, snd(nbdirsmax), ss, ssd(nbdirsmax), swap,
     +                 swapd(nbdirsmax)
      CHARACTER*2 jbcmpz
      INTEGER arg1, arg2, i, ii2, ii3, ILAENV, inf, it, itmax, k, kacc22
     +        , kbot, kdu, ks, kt, ktop, ku, kv, kwh, kwtop, kwv, ld, ls
     +        , lwkopt, max1, max2, max3, min1, min2, min3, nd, ndfl, nh
     +        , nho, nibble, nmin, ns, nsmax, nsr, nve, nw, nwmax, nwr,
     +        y1, y2, z1
      LOGICAL nwinc, sorted
      DOUBLE PRECISION zdum(1, 1), zdumd(nbdirsmax, 1, 1)
      EXTERNAL ILAENV
      INTRINSIC MOD, MAX, ABS, INT, DBLE, MIN
C
C  -- LAPACK auxiliary routine (version 3.1) --
C     Univ. of Tennessee, Univ. of California Berkeley and NAG Ltd..
C     November 2006
C
C     .. Scalar Arguments ..
C     ..
C     .. Array Arguments ..
C     ..
C
C     This subroutine implements one level of recursion for DLAQR0.
C     It is a complete implementation of the small bulge multi-shift
C     QR algorithm.  It may be called by DLAQR0 and, for large enough
C     deflation window size, it may be called by DLAQR3.  This
C     subroutine is identical to DLAQR0 except that it calls DLAQR2
C     instead of DLAQR3.
C
C     Purpose
C     =======
C
C     DLAQR4 computes the eigenvalues of a Hessenberg matrix H
C     and, optionally, the matrices T and Z from the Schur decomposition
C     H = Z T Z**T, where T is an upper quasi-triangular matrix (the
C     Schur form), and Z is the orthogonal matrix of Schur vectors.
C
C     Optionally Z may be postmultiplied into an input orthogonal
C     matrix Q so that this routine can give the Schur factorization
C     of a matrix A which has been reduced to the Hessenberg form H
C     by the orthogonal matrix Q:  A = Q*H*Q**T = (QZ)*T*(QZ)**T.
C
C     Arguments
C     =========
C
C     WANTT   (input) LOGICAL
C          = .TRUE. : the full Schur form T is required;
C          = .FALSE.: only eigenvalues are required.
C
C     WANTZ   (input) LOGICAL
C          = .TRUE. : the matrix of Schur vectors Z is required;
C          = .FALSE.: Schur vectors are not required.
C
C     N     (input) INTEGER
C           The order of the matrix H.  N .GE. 0.
C
C     ILO   (input) INTEGER
C     IHI   (input) INTEGER
C           It is assumed that H is already upper triangular in rows
C           and columns 1:ILO-1 and IHI+1:N and, if ILO.GT.1,
C           H(ILO,ILO-1) is zero. ILO and IHI are normally set by a
C           previous call to DGEBAL, and then passed to DGEHRD when the
C           matrix output by DGEBAL is reduced to Hessenberg form.
C           Otherwise, ILO and IHI should be set to 1 and N,
C           respectively.  If N.GT.0, then 1.LE.ILO.LE.IHI.LE.N.
C           If N = 0, then ILO = 1 and IHI = 0.
C
C     H     (input/output) DOUBLE PRECISION array, dimension (LDH,N)
C           On entry, the upper Hessenberg matrix H.
C           On exit, if INFO = 0 and WANTT is .TRUE., then H contains
C           the upper quasi-triangular matrix T from the Schur
C           decomposition (the Schur form); 2-by-2 diagonal blocks
C           (corresponding to complex conjugate pairs of eigenvalues)
C           are returned in standard form, with H(i,i) = H(i+1,i+1)
C           and H(i+1,i)*H(i,i+1).LT.0. If INFO = 0 and WANTT is
C           .FALSE., then the contents of H are unspecified on exit.
C           (The output value of H when INFO.GT.0 is given under the
C           description of INFO below.)
C
C           This subroutine may explicitly set H(i,j) = 0 for i.GT.j and
C           j = 1, 2, ... ILO-1 or j = IHI+1, IHI+2, ... N.
C
C     LDH   (input) INTEGER
C           The leading dimension of the array H. LDH .GE. max(1,N).
C
C     WR    (output) DOUBLE PRECISION array, dimension (IHI)
C     WI    (output) DOUBLE PRECISION array, dimension (IHI)
C           The real and imaginary parts, respectively, of the computed
C           eigenvalues of H(ILO:IHI,ILO:IHI) are stored WR(ILO:IHI)
C           and WI(ILO:IHI). If two eigenvalues are computed as a
C           complex conjugate pair, they are stored in consecutive
C           elements of WR and WI, say the i-th and (i+1)th, with
C           WI(i) .GT. 0 and WI(i+1) .LT. 0. If WANTT is .TRUE., then
C           the eigenvalues are stored in the same order as on the
C           diagonal of the Schur form returned in H, with
C           WR(i) = H(i,i) and, if H(i:i+1,i:i+1) is a 2-by-2 diagonal
C           block, WI(i) = sqrt(-H(i+1,i)*H(i,i+1)) and
C           WI(i+1) = -WI(i).
C
C     ILOZ     (input) INTEGER
C     IHIZ     (input) INTEGER
C           Specify the rows of Z to which transformations must be
C           applied if WANTZ is .TRUE..
C           1 .LE. ILOZ .LE. ILO; IHI .LE. IHIZ .LE. N.
C
C     Z     (input/output) DOUBLE PRECISION array, dimension (LDZ,IHI)
C           If WANTZ is .FALSE., then Z is not referenced.
C           If WANTZ is .TRUE., then Z(ILO:IHI,ILOZ:IHIZ) is
C           replaced by Z(ILO:IHI,ILOZ:IHIZ)*U where U is the
C           orthogonal Schur factor of H(ILO:IHI,ILO:IHI).
C           (The output value of Z when INFO.GT.0 is given under
C           the description of INFO below.)
C
C     LDZ   (input) INTEGER
C           The leading dimension of the array Z.  if WANTZ is .TRUE.
C           then LDZ.GE.MAX(1,IHIZ).  Otherwize, LDZ.GE.1.
C
C     WORK  (workspace/output) DOUBLE PRECISION array, dimension LWORK
C           On exit, if LWORK = -1, WORK(1) returns an estimate of
C           the optimal value for LWORK.
C
C     LWORK (input) INTEGER
C           The dimension of the array WORK.  LWORK .GE. max(1,N)
C           is sufficient, but LWORK typically as large as 6*N may
C           be required for optimal performance.  A workspace query
C           to determine the optimal workspace size is recommended.
C
C           If LWORK = -1, then DLAQR4 does a workspace query.
C           In this case, DLAQR4 checks the input parameters and
C           estimates the optimal workspace size for the given
C           values of N, ILO and IHI.  The estimate is returned
C           in WORK(1).  No error message related to LWORK is
C           issued by XERBLA.  Neither H nor Z are accessed.
C
C
C     INFO  (output) INTEGER
C             =  0:  successful exit
C           .GT. 0:  if INFO = i, DLAQR4 failed to compute all of
C                the eigenvalues.  Elements 1:ilo-1 and i+1:n of WR
C                and WI contain those eigenvalues which have been
C                successfully computed.  (Failures are rare.)
C
C                If INFO .GT. 0 and WANT is .FALSE., then on exit,
C                the remaining unconverged eigenvalues are the eigen-
C                values of the upper Hessenberg matrix rows and
C                columns ILO through INFO of the final, output
C                value of H.
C
C                If INFO .GT. 0 and WANTT is .TRUE., then on exit
C
C           (*)  (initial value of H)*U  = U*(final value of H)
C
C                where U is an orthogonal matrix.  The final
C                value of H is upper Hessenberg and quasi-triangular
C                in rows and columns INFO+1 through IHI.
C
C                If INFO .GT. 0 and WANTZ is .TRUE., then on exit
C
C                  (final value of Z(ILO:IHI,ILOZ:IHIZ)
C                   =  (initial value of Z(ILO:IHI,ILOZ:IHIZ)*U
C
C                where U is the orthogonal matrix in (*) (regard-
C                less of the value of WANTT.)
C
C                If INFO .GT. 0 and WANTZ is .FALSE., then Z is not
C                accessed.
C
C     ================================================================
C     Based on contributions by
C        Karen Braman and Ralph Byers, Department of Mathematics,
C        University of Kansas, USA
C
C     ================================================================
C     References:
C       K. Braman, R. Byers and R. Mathias, The Multi-Shift QR
C       Algorithm Part I: Maintaining Well Focused Shifts, and Level 3
C       Performance, SIAM Journal of Matrix Analysis, volume 23, pages
C       929--947, 2002.
C
C       K. Braman, R. Byers and R. Mathias, The Multi-Shift QR
C       Algorithm Part II: Aggressive Early Deflation, SIAM Journal
C       of Matrix Analysis, volume 23, pages 948--973, 2002.
C
C     ================================================================
C     .. Parameters ..
C
C     ==== Matrices of order NTINY or smaller must be processed by
C     .    DLAHQR because of insufficient subdiagonal scratch space.
C     .    (This is a hard limit.) ====
C
C     ==== Exceptional deflation windows:  try to cure rare
C     .    slow convergence by increasing the size of the
C     .    deflation window after KEXNW iterations. =====
C
C     ==== Exceptional shifts: try to cure rare slow convergence
C     .    with ad-hoc exceptional shifts every KEXSH iterations.
C     .    The constants WILK1 and WILK2 are used to form the
C     .    exceptional shifts. ====
C
C     ..
C     .. Local Scalars ..
C     ..
C     .. External Functions ..
C     ..
C     .. Local Arrays ..
C     ..
C     .. External Subroutines ..
C     ..
C     .. Intrinsic Functions ..
C     ..
C     .. Executable Statements ..
      info = 0
C
C     ==== Quick return for N = 0: nothing to do. ====
C
      IF (n .EQ. 0) THEN
        DO nd=1,nbdirs
          workd(nd, 1) = 0.D0
        ENDDO
        work(1) = one
        RETURN
      ELSE
C
C     ==== Set up job flags for ILAENV. ====
C
        IF (wantt) THEN
          jbcmpz(1:1) = 'S'
        ELSE
          jbcmpz(1:1) = 'E'
        END IF
        IF (wantz) THEN
          jbcmpz(2:2) = 'V'
        ELSE
          jbcmpz(2:2) = 'N'
        END IF
C
C     ==== Tiny matrices must use DLAHQR. ====
C
        IF (n .LE. ntiny) THEN
C
C        ==== Estimate optimal workspace. ====
C
          lwkopt = 1
          IF (lwork .NE. -1) CALL DLAHQR_DV(wantt, wantz, n, ilo, ihi, h
     +                                      , hd, ldh, wr, wrd, wi, wid
     +                                      , iloz, ihiz, z, zd, ldz,
     +                                      info, nbdirs)
        ELSE
C
C        ==== Use small bulge multi-shift QR with aggressive early
C        .    deflation on larger-than-tiny matrices. ====
C
C        ==== Hope for the best. ====
C
          info = 0
C
C        ==== NWR = recommended deflation window size.  At this
C        .    point,  N .GT. NTINY = 11, so there is enough
C        .    subdiagonal workspace for NWR.GE.2 as required.
C        .    (In fact, there is enough subdiagonal space for
C        .    NWR.GE.3.) ====
C
          nwr = ILAENV(13, 'DLAQR4', jbcmpz, n, ilo, ihi, lwork)
          IF (2 .LT. nwr) THEN
            nwr = nwr
          ELSE
            nwr = 2
          END IF
          IF (ihi - ilo + 1 .GT. (n-1)/3) THEN
            IF ((n-1)/3 .GT. nwr) THEN
              nwr = nwr
            ELSE
              nwr = (n-1)/3
            END IF
          ELSE IF (ihi - ilo + 1 .GT. nwr) THEN
            nwr = nwr
          ELSE
            nwr = ihi - ilo + 1
          END IF
          nw = nwr
C
C        ==== NSR = recommended number of simultaneous shifts.
C        .    At this point N .GT. NTINY = 11, so there is at
C        .    enough subdiagonal workspace for NSR to be even
C        .    and greater than or equal to two as required. ====
C
          nsr = ILAENV(15, 'DLAQR4', jbcmpz, n, ilo, ihi, lwork)
          IF (nsr .GT. (n+6)/9) THEN
            IF ((n+6)/9 .GT. ihi - ilo) THEN
              nsr = ihi - ilo
            ELSE
              nsr = (n+6)/9
            END IF
          ELSE IF (nsr .GT. ihi - ilo) THEN
            nsr = ihi - ilo
          ELSE
            nsr = nsr
          END IF
          y1 = nsr - MOD(nsr, 2)
          IF (2 .LT. y1) THEN
            nsr = y1
          ELSE
            nsr = 2
          END IF
C
C        ==== Estimate optimal workspace ====
C
C        ==== Workspace query call to DLAQR2 ====
C
          arg1 = nwr + 1
          arg2 = -1
          CALL DLAQR2_DV(wantt, wantz, n, ilo, ihi, arg1, h, hd, ldh,
     +                   iloz, ihiz, z, zd, ldz, ls, ld, wr, wrd, wi,
     +                   wid, h, hd, ldh, n, h, hd, ldh, n, h, hd, ldh,
     +                   work, workd, arg2, nbdirs)
          y2 = INT(work(1))
          IF (3*nsr/2 .LT. y2) THEN
            lwkopt = y2
          ELSE
            lwkopt = 3*nsr/2
          END IF
C
C        ==== Quick return in case of workspace query. ====
C
          IF (lwork .EQ. -1) THEN
            DO nd=1,nbdirs
              workd(nd, 1) = 0.D0
            ENDDO
            work(1) = DBLE(lwkopt)
            RETURN
          ELSE
C
C        ==== DLAHQR/DLAQR0 crossover point ====
C
            nmin = ILAENV(12, 'DLAQR4', jbcmpz, n, ilo, ihi, lwork)
            IF (ntiny .LT. nmin) THEN
              nmin = nmin
            ELSE
              nmin = ntiny
            END IF
C
C        ==== Nibble crossover point ====
C
            nibble = ILAENV(14, 'DLAQR4', jbcmpz, n, ilo, ihi, lwork)
            IF (0 .LT. nibble) THEN
              nibble = nibble
            ELSE
              nibble = 0
            END IF
C
C        ==== Accumulate reflections during ttswp?  Use block
C        .    2-by-2 structure during matrix-matrix multiply? ====
C
            kacc22 = ILAENV(16, 'DLAQR4', jbcmpz, n, ilo, ihi, lwork)
            IF (0 .LT. kacc22) THEN
              kacc22 = kacc22
            ELSE
              kacc22 = 0
            END IF
            IF (2 .GT. kacc22) THEN
              kacc22 = kacc22
            ELSE
              kacc22 = 2
            END IF
            IF ((n-1)/3 .GT. lwork/2) THEN
              nwmax = lwork/2
            ELSE
              nwmax = (n-1)/3
            END IF
            IF ((n+6)/9 .GT. 2*lwork/3) THEN
              nsmax = 2*lwork/3
            ELSE
              nsmax = (n+6)/9
            END IF
            nsmax = nsmax - MOD(nsmax, 2)
C
C        ==== NDFL: an iteration count restarted at deflation. ====
C
            ndfl = 1
            IF (30 .LT. 2*kexsh) THEN
              max1 = 2*kexsh
            ELSE
              max1 = 30
            END IF
            IF (10 .LT. ihi - ilo + 1) THEN
              max3 = ihi - ilo + 1
            ELSE
              max3 = 10
            END IF
C
C        ==== ITMAX = iteration limit ====
C
            itmax = max1*max3
C
C        ==== Last row and column in the active block ====
C
            kbot = ihi
C
C        ==== Main Loop ====
C
            DO it=1,itmax
C
C           ==== Done when KBOT falls below ILO ====
C
              IF (kbot .LT. ilo) THEN
                GOTO 90
              ELSE
C
C           ==== Locate active block ====
C
                DO k=kbot,ilo+1,-1
                  IF (h(k, k-1) .EQ. zero) GOTO 20
                ENDDO
                k = ilo
 20             ktop = k
C
C           ==== Select deflation window size ====
C
                nh = kbot - ktop + 1
                IF (ndfl .LT. kexnw .OR. nh .LT. nw) THEN
C
C              ==== Typical deflation window.  If possible and
C              .    advisable, nibble the entire active block.
C              .    If not, use size NWR or NWR+1 depending upon
C              .    which has the smaller corresponding subdiagonal
C              .    entry (a heuristic). ====
C
                  nwinc = .true.
                  IF (nmin .GT. nwmax) THEN
                    min1 = nwmax
                  ELSE
                    min1 = nmin
                  END IF
                  IF (nh .LE. min1) THEN
                    nw = nh
                  ELSE
                    IF (nwr .GT. nh) THEN
                      IF (nh .GT. nwmax) THEN
                        nw = nwmax
                      ELSE
                        nw = nh
                      END IF
                    ELSE IF (nwr .GT. nwmax) THEN
                      nw = nwmax
                    ELSE
                      nw = nwr
                    END IF
                    IF (nw .LT. nwmax) THEN
                      IF (nw .GE. nh - 1) THEN
                        nw = nh
                      ELSE
                        kwtop = kbot - nw + 1
                        IF (h(kwtop, kwtop-1) .GE. 0.) THEN
                          abs1 = h(kwtop, kwtop-1)
                        ELSE
                          abs1 = -h(kwtop, kwtop-1)
                        END IF
                        IF (h(kwtop-1, kwtop-2) .GE. 0.) THEN
                          abs5 = h(kwtop-1, kwtop-2)
                        ELSE
                          abs5 = -h(kwtop-1, kwtop-2)
                        END IF
                        IF (abs1 .GT. abs5) nw = nw + 1
                      END IF
                    END IF
                  END IF
                ELSE
                  IF (nwmax .GT. nh) THEN
                    min2 = nh
                  ELSE
                    min2 = nwmax
                  END IF
C
C              ==== Exceptional deflation window.  If there have
C              .    been no deflations in KEXNW or more iterations,
C              .    then vary the deflation window size.   At first,
C              .    because, larger windows are, in general, more
C              .    powerful than smaller ones, rapidly increase the
C              .    window up to the maximum reasonable and possible.
C              .    Then maybe try a slightly smaller window.  ====
C
                  IF (nwinc .AND. nw .LT. min2) THEN
                    IF (nwmax .GT. nh) THEN
                      IF (nh .GT. 2*nw) THEN
                        nw = 2*nw
                      ELSE
                        nw = nh
                      END IF
                    ELSE IF (nwmax .GT. 2*nw) THEN
                      nw = 2*nw
                    ELSE
                      nw = nwmax
                    END IF
                  ELSE
                    nwinc = .false.
                    IF (nw .EQ. nh .AND. nh .GT. 2) nw = nh - 1
                  END IF
                END IF
C
C           ==== Aggressive early deflation:
C           .    split workspace under the subdiagonal into
C           .      - an nw-by-nw work array V in the lower
C           .        left-hand-corner,
C           .      - an NW-by-at-least-NW-but-more-is-better
C           .        (NW-by-NHO) horizontal work array along
C           .        the bottom edge,
C           .      - an at-least-NW-but-more-is-better (NHV-by-NW)
C           .        vertical work array along the left-hand-edge.
C           .        ====
C
                kv = n - nw + 1
                kt = nw + 1
                nho = n - nw - 1 - kt + 1
                kwv = nw + 2
                nve = n - nw - kwv + 1
C
C           ==== Aggressive early deflation ====
C
                CALL DLAQR2_DV(wantt, wantz, n, ktop, kbot, nw, h, hd,
     +                         ldh, iloz, ihiz, z, zd, ldz, ls, ld, wr,
     +                         wrd, wi, wid, h(kv, 1), hd(1, kv, 1), ldh
     +                         , nho, h(kv, kt), hd(1, kv, kt), ldh, nve
     +                         , h(kwv, 1), hd(1, kwv, 1), ldh, work,
     +                         workd, lwork, nbdirs)
C
C           ==== Adjust KBOT accounting for new deflations. ====
C
                kbot = kbot - ld
C
C           ==== KS points to the shifts. ====
C
                ks = kbot - ls + 1
                IF (nmin .GT. nwmax) THEN
                  min3 = nwmax
                ELSE
                  min3 = nmin
                END IF
C
C           ==== Skip an expensive QR sweep if there is a (partly
C           .    heuristic) reason to expect that many eigenvalues
C           .    will deflate without it.  Here, the QR sweep is
C           .    skipped if many eigenvalues have just been deflated
C           .    or if the remaining active block is small.
C
                IF (ld .EQ. 0 .OR. 100*ld .LE. nw*nibble .AND. kbot -
     +              ktop + 1 .GT. min3) THEN
                  IF (2 .LT. kbot - ktop) THEN
                    z1 = kbot - ktop
                  ELSE
                    z1 = 2
                  END IF
                  IF (nsmax .GT. nsr) THEN
                    IF (nsr .GT. z1) THEN
                      ns = z1
                    ELSE
                      ns = nsr
                    END IF
                  ELSE IF (nsmax .GT. z1) THEN
                    ns = z1
                  ELSE
                    ns = nsmax
                  END IF
                  ns = ns - MOD(ns, 2)
C
C              ==== If there have been no deflations
C              .    in a multiple of KEXSH iterations,
C              .    then try exceptional shifts.
C              .    Otherwise use shifts provided by
C              .    DLAQR2 above or from the eigenvalues
C              .    of a trailing principal submatrix. ====
C
                  IF (MOD(ndfl, kexsh) .EQ. 0) THEN
                    ks = kbot - ns + 1
                    IF (ks + 1 .LT. ktop + 2) THEN
                      max2 = ktop + 2
                    ELSE
                      max2 = ks + 1
                    END IF
                    DO i=kbot,max2,-2
                      IF (h(i, i-1) .GE. 0.) THEN
                        DO nd=1,nbdirs
                          abs2d(nd) = hd(nd, i, i-1)
                        ENDDO
                        abs2 = h(i, i-1)
                      ELSE
                        DO nd=1,nbdirs
                          abs2d(nd) = -hd(nd, i, i-1)
                        ENDDO
                        abs2 = -h(i, i-1)
                      END IF
                      IF (h(i-1, i-2) .GE. 0.) THEN
                        DO nd=1,nbdirs
                          abs6d(nd) = hd(nd, i-1, i-2)
                        ENDDO
                        abs6 = h(i-1, i-2)
                      ELSE
                        DO nd=1,nbdirs
                          abs6d(nd) = -hd(nd, i-1, i-2)
                        ENDDO
                        abs6 = -h(i-1, i-2)
                      END IF
                      DO nd=1,nbdirs
                        ssd(nd) = abs2d(nd) + abs6d(nd)
                        ccd(nd) = wilk2*ssd(nd)
                        bbd(nd) = ssd(nd)
                        aad(nd) = wilk1*ssd(nd) + hd(nd, i, i)
                        ddd(nd) = aad(nd)
                      ENDDO
                      ss = abs2 + abs6
                      aa = wilk1*ss + h(i, i)
                      bb = ss
                      cc = wilk2*ss
                      dd = aa
                      CALL DLANV2_DV(aa, aad, bb, bbd, cc, ccd, dd, ddd
     +                               , wr(i-1), wrd(1, i-1), wi(i-1),
     +                               wid(1, i-1), wr(i), wrd(1, i), wi(i
     +                               ), wid(1, i), cs, csd, sn, snd,
     +                               nbdirs)
                    ENDDO
                    IF (ks .EQ. ktop) THEN
                      wr(ks+1) = h(ks+1, ks+1)
                      DO nd=1,nbdirs
                        wid(nd, ks+1) = 0.D0
                        wrd(nd, ks+1) = hd(nd, ks+1, ks+1)
                        wid(nd, ks) = wid(nd, ks+1)
                        wrd(nd, ks) = wrd(nd, ks+1)
                      ENDDO
                      wi(ks+1) = zero
                      wr(ks) = wr(ks+1)
                      wi(ks) = wi(ks+1)
                    END IF
                  ELSE
C
C                 ==== Got NS/2 or fewer shifts? Use DLAHQR
C                 .    on a trailing principal submatrix to
C                 .    get more. (Since NS.LE.NSMAX.LE.(N+6)/9,
C                 .    there is enough space below the subdiagonal
C                 .    to fit an NS-by-NS scratch array.) ====
C
                    IF (kbot - ks + 1 .LE. ns/2) THEN
                      ks = kbot - ns + 1
                      kt = n - ns + 1
                      CALL DLACPY_DV('A', ns, ns, h(ks, ks), hd(1, ks,
     +                               ks), ldh, h(kt, 1), hd(1, kt, 1),
     +                               ldh, nbdirs)
                      DO nd=1,nbdirs
                        DO ii2=1,1
                          DO ii3=1,1
                            zdumd(nd, ii3, ii2) = 0.D0
                          ENDDO
                        ENDDO
                      ENDDO
                      CALL DLAHQR_DV(.false., .false., ns, 1, ns, h(kt,
     +                               1), hd(1, kt, 1), ldh, wr(ks), wrd(
     +                               1, ks), wi(ks), wid(1, ks), 1, 1,
     +                               zdum, zdumd, 1, inf, nbdirs)
                      ks = ks + inf
C
C                    ==== In case of a rare QR failure use
C                    .    eigenvalues of the trailing 2-by-2
C                    .    principal submatrix.  ====
C
                      IF (ks .GE. kbot) THEN
                        DO nd=1,nbdirs
                          aad(nd) = hd(nd, kbot-1, kbot-1)
                          ddd(nd) = hd(nd, kbot, kbot)
                          bbd(nd) = hd(nd, kbot-1, kbot)
                          ccd(nd) = hd(nd, kbot, kbot-1)
                        ENDDO
                        aa = h(kbot-1, kbot-1)
                        cc = h(kbot, kbot-1)
                        bb = h(kbot-1, kbot)
                        dd = h(kbot, kbot)
                        CALL DLANV2_DV(aa, aad, bb, bbd, cc, ccd, dd,
     +                                 ddd, wr(kbot-1), wrd(1, kbot-1),
     +                                 wi(kbot-1), wid(1, kbot-1), wr(
     +                                 kbot), wrd(1, kbot), wi(kbot),
     +                                 wid(1, kbot), cs, csd, sn, snd,
     +                                 nbdirs)
                        ks = kbot - 1
                      END IF
                    END IF
C
                    IF (kbot - ks + 1 .GT. ns) THEN
C
C                    ==== Sort the shifts (Helps a little)
C                    .    Bubble sort keeps complex conjugate
C                    .    pairs together. ====
C
                      sorted = .false.
                      DO k=kbot,ks+1,-1
                        IF (sorted) THEN
                          GOTO 60
                        ELSE
                          sorted = .true.
                          DO i=ks,k-1
                            IF (wr(i) .GE. 0.) THEN
                              abs3 = wr(i)
                            ELSE
                              abs3 = -wr(i)
                            END IF
                            IF (wi(i) .GE. 0.) THEN
                              abs7 = wi(i)
                            ELSE
                              abs7 = -wi(i)
                            END IF
                            IF (wr(i+1) .GE. 0.) THEN
                              abs9 = wr(i+1)
                            ELSE
                              abs9 = -wr(i+1)
                            END IF
                            IF (wi(i+1) .GE. 0.) THEN
                              abs10 = wi(i+1)
                            ELSE
                              abs10 = -wi(i+1)
                            END IF
                            IF (abs3 + abs7 .LT. abs9 + abs10) THEN
                              sorted = .false.
                              DO nd=1,nbdirs
                                swapd(nd) = wrd(nd, i)
                                wrd(nd, i) = wrd(nd, i+1)
                                wrd(nd, i+1) = swapd(nd)
                                swapd(nd) = wid(nd, i)
                                wid(nd, i) = wid(nd, i+1)
                                wid(nd, i+1) = swapd(nd)
                              ENDDO
C
                              swap = wr(i)
                              wr(i) = wr(i+1)
                              wr(i+1) = swap
C
                              swap = wi(i)
                              wi(i) = wi(i+1)
                              wi(i+1) = swap
                            END IF
                          ENDDO
                        END IF
                      ENDDO
 60                   CONTINUE
                    END IF
C
C                 ==== Shuffle shifts into pairs of real shifts
C                 .    and pairs of complex conjugate shifts
C                 .    assuming complex conjugate shifts are
C                 .    already adjacent to one another. (Yes,
C                 .    they are.)  ====
C
                    DO i=kbot,ks+2,-2
                      IF (wi(i) .NE. -wi(i-1)) THEN
                        DO nd=1,nbdirs
                          swapd(nd) = wrd(nd, i)
                          wrd(nd, i) = wrd(nd, i-1)
                          wrd(nd, i-1) = wrd(nd, i-2)
                          wrd(nd, i-2) = swapd(nd)
                          swapd(nd) = wid(nd, i)
                          wid(nd, i) = wid(nd, i-1)
                          wid(nd, i-1) = wid(nd, i-2)
                          wid(nd, i-2) = swapd(nd)
                        ENDDO
C
                        swap = wr(i)
                        wr(i) = wr(i-1)
                        wr(i-1) = wr(i-2)
                        wr(i-2) = swap
C
                        swap = wi(i)
                        wi(i) = wi(i-1)
                        wi(i-1) = wi(i-2)
                        wi(i-2) = swap
                      END IF
                    ENDDO
                  END IF
C
C              ==== If there are only two shifts and both are
C              .    real, then use only one.  ====
C
                  IF (kbot - ks + 1 .EQ. 2) THEN
                    IF (wi(kbot) .EQ. zero) THEN
                      IF (wr(kbot) - h(kbot, kbot) .GE. 0.) THEN
                        abs4 = wr(kbot) - h(kbot, kbot)
                      ELSE
                        abs4 = -(wr(kbot)-h(kbot, kbot))
                      END IF
                      IF (wr(kbot-1) - h(kbot, kbot) .GE. 0.) THEN
                        abs8 = wr(kbot-1) - h(kbot, kbot)
                      ELSE
                        abs8 = -(wr(kbot-1)-h(kbot, kbot))
                      END IF
                      IF (abs4 .LT. abs8) THEN
                        DO nd=1,nbdirs
                          wrd(nd, kbot-1) = wrd(nd, kbot)
                        ENDDO
                        wr(kbot-1) = wr(kbot)
                      ELSE
                        DO nd=1,nbdirs
                          wrd(nd, kbot) = wrd(nd, kbot-1)
                        ENDDO
                        wr(kbot) = wr(kbot-1)
                      END IF
                    END IF
                  END IF
                  IF (ns .GT. kbot - ks + 1) THEN
                    ns = kbot - ks + 1
                  ELSE
                    ns = ns
                  END IF
                  ns = ns - MOD(ns, 2)
                  ks = kbot - ns + 1
C
C              ==== Small-bulge multi-shift QR sweep:
C              .    split workspace under the subdiagonal into
C              .    - a KDU-by-KDU work array U in the lower
C              .      left-hand-corner,
C              .    - a KDU-by-at-least-KDU-but-more-is-better
C              .      (KDU-by-NHo) horizontal work array WH along
C              .      the bottom edge,
C              .    - and an at-least-KDU-but-more-is-better-by-KDU
C              .      (NVE-by-KDU) vertical work WV arrow along
C              .      the left-hand-edge. ====
C
                  kdu = 3*ns - 3
                  ku = n - kdu + 1
                  kwh = kdu + 1
                  nho = n - kdu + 1 - 4 - (kdu+1) + 1
                  kwv = kdu + 4
                  nve = n - kdu - kwv + 1
C
C              ==== Small-bulge multi-shift QR sweep ====
C
                  CALL DLAQR5_DV(wantt, wantz, kacc22, n, ktop, kbot, ns
     +                           , wr(ks), wrd(1, ks), wi(ks), wid(1, ks
     +                           ), h, hd, ldh, iloz, ihiz, z, zd, ldz,
     +                           work, workd, 3, h(ku, 1), hd(1, ku, 1)
     +                           , ldh, nve, h(kwv, 1), hd(1, kwv, 1),
     +                           ldh, nho, h(ku, kwh), hd(1, ku, kwh),
     +                           ldh, nbdirs)
                END IF
C
C           ==== Note progress (or the lack of it). ====
C
                IF (ld .GT. 0) THEN
                  ndfl = 1
                ELSE
                  ndfl = ndfl + 1
                END IF
              END IF
            ENDDO
C
C           ==== End of main loop ====
C
C        ==== Iteration limit exceeded.  Set INFO to show where
C        .    the problem occurred and exit. ====
C
            info = kbot
          END IF
        END IF
 90     DO nd=1,nbdirs
          workd(nd, 1) = 0.D0
        ENDDO
C
C     ==== Return the optimal value of LWORK. ====
C
        work(1) = DBLE(lwkopt)
      END IF
      END
